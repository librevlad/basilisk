"""Multi-stage exploitation chain engine.

Orchestrates chained attacks where one vulnerability's output feeds the next:
  SQLi → data extraction → credential reuse
  SSRF → cloud metadata → AWS keys → S3 bucket access
  XSS → session theft → admin panel access

Chains run automatically after the pentesting phase completes,
using pipeline results to determine which chains are viable.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Any

from basilisk.models.result import Finding, Severity

logger = logging.getLogger(__name__)


@dataclass
class ChainStep:
    """A single step in an exploitation chain."""

    name: str
    description: str
    source_plugin: str          # Plugin that provides the trigger data
    evidence: str = ""          # Evidence collected at this step
    data: dict[str, Any] = field(default_factory=dict)
    success: bool = False


@dataclass
class ExploitChain:
    """A completed or in-progress exploitation chain."""

    chain_id: str
    name: str
    description: str
    target: str
    steps: list[ChainStep] = field(default_factory=list)
    severity: Severity = Severity.HIGH
    completed: bool = False

    @property
    def step_count(self) -> int:
        return len(self.steps)

    @property
    def successful_steps(self) -> int:
        return sum(1 for s in self.steps if s.success)

    def add_step(self, step: ChainStep) -> None:
        self.steps.append(step)

    def to_finding(self) -> Finding:
        """Convert completed chain to a Finding for the report."""
        evidence_parts = []
        for i, step in enumerate(self.steps, 1):
            status = "OK" if step.success else "FAILED"
            evidence_parts.append(
                f"Step {i} [{status}]: {step.name} — {step.evidence or step.description}"
            )

        return Finding(
            severity=self.severity,
            title=f"Exploit chain: {self.name}",
            description=(
                f"{self.description}\n"
                f"Completed {self.successful_steps}/{self.step_count} steps"
            ),
            evidence="\n".join(evidence_parts),
            remediation=_CHAIN_REMEDIATION.get(self.chain_id, "Review and fix all steps"),
            tags=["exploit-chain", self.chain_id],
        )


# Remediation per chain type
_CHAIN_REMEDIATION: dict[str, str] = {
    "sqli_extract": (
        "Use parameterized queries. Implement least-privilege DB access. "
        "Encrypt sensitive data at rest."
    ),
    "ssrf_cloud": (
        "Validate and whitelist URLs server-side. Block access to metadata endpoints. "
        "Use IMDSv2 (AWS) with hop limit. Rotate any exposed credentials immediately."
    ),
    "ssrf_internal": (
        "Implement URL allowlists. Block private IP ranges in outbound requests. "
        "Use network segmentation to limit SSRF impact."
    ),
    "ssti_rce": (
        "Never pass user input to template engines. Use sandboxed template rendering. "
        "Implement strict input validation."
    ),
    "xss_session": (
        "Implement HttpOnly and Secure flags on session cookies. "
        "Use Content-Security-Policy headers. Apply context-aware output encoding."
    ),
    "lfi_rce": (
        "Never use user input in file paths. Implement allowlists for file access. "
        "Disable dangerous PHP wrappers (expect://, data://)."
    ),
    "smb_shell": (
        "Enforce SMB signing. Use strong passwords. Disable SMBv1. "
        "Restrict SMB access to authorized systems."
    ),
    "upload_rce": (
        "Validate file uploads server-side (MIME, extension, magic bytes). "
        "Store uploads outside webroot. Disable script execution in upload dirs."
    ),
    "kerberoast_da": (
        "Use 25+ char passwords for service accounts. Prefer gMSA. "
        "Set encryption to AES-only. Monitor for TGS requests."
    ),
    "privesc_root": (
        "Remove unnecessary SUID bits. Use sudoers with specific commands. "
        "Keep kernel patched. Remove dangerous capabilities."
    ),
}


class ExploitChainEngine:
    """Orchestrates multi-stage exploitation chains.

    After pentesting plugins complete, the engine examines pipeline results
    to identify viable chains and executes them.

    Usage::

        engine = ExploitChainEngine()
        chains = engine.analyze(pipeline, target_host, ctx)
        for chain in chains:
            findings.extend([chain.to_finding()])
    """

    def __init__(self) -> None:
        self._chains: list[ExploitChain] = []

    @property
    def chains(self) -> list[ExploitChain]:
        return list(self._chains)

    def analyze(
        self,
        pipeline: dict[str, Any],
        host: str,
        ctx: Any = None,
    ) -> list[ExploitChain]:
        """Analyze pipeline results and build viable chains."""
        self._chains = []

        self._check_sqli_extract(pipeline, host)
        self._check_ssrf_cloud(pipeline, host)
        self._check_ssrf_internal_scan(pipeline, host)
        self._check_ssti_rce(pipeline, host)
        self._check_xss_session(pipeline, host)
        self._check_lfi_rce(pipeline, host)
        self._check_cred_reuse(pipeline, host)
        self._check_smb_shell(pipeline, host)
        self._check_upload_rce(pipeline, host)
        self._check_kerberoast_da(pipeline, host)
        self._check_privesc_root(pipeline, host)

        completed = [c for c in self._chains if c.completed]
        if completed:
            logger.info(
                "Exploit chains for %s: %d viable (%s)",
                host, len(completed),
                ", ".join(c.chain_id for c in completed),
            )
        return completed

    def _check_sqli_extract(self, pipeline: dict, host: str) -> None:
        """Chain: SQLi found → extract DB version/data → find credentials."""
        sqli_key = f"sqli_basic:{host}"
        sqli_result = pipeline.get(sqli_key)
        if not sqli_result or not sqli_result.ok:
            return

        sqli_tests = sqli_result.data.get("sqli_tests", [])
        if not sqli_tests:
            return

        chain = ExploitChain(
            chain_id="sqli_extract",
            name="SQL Injection → Data Extraction",
            description="SQL injection confirmed; database data may be extractable",
            target=host,
            severity=Severity.CRITICAL,
        )

        # Step 1: SQLi confirmed
        first_test = sqli_tests[0]
        dbms = first_test.get("dbms", "unknown")
        chain.add_step(ChainStep(
            name="SQL Injection Confirmed",
            description=f"Error-based SQLi detected ({dbms})",
            source_plugin="sqli_basic",
            evidence=f"DBMS: {dbms}, Payload: {first_test.get('payload', 'N/A')}",
            data={"dbms": dbms},
            success=True,
        ))

        # Step 2: Check if advanced extraction ran
        adv_key = f"sqli_advanced:{host}"
        adv_result = pipeline.get(adv_key)
        if adv_result and adv_result.ok:
            extracted = adv_result.data.get("extracted", {})
            if extracted:
                chain.add_step(ChainStep(
                    name="Data Extraction",
                    description="Database information extracted via UNION/blind",
                    source_plugin="sqli_advanced",
                    evidence=f"Extracted: {', '.join(extracted.keys())}",
                    data=extracted,
                    success=True,
                ))

                # Check for credentials in extracted data
                cred_indicators = ["password", "pass", "pwd", "secret", "token", "hash"]
                for key, _value in extracted.items():
                    if any(ind in key.lower() for ind in cred_indicators):
                        chain.add_step(ChainStep(
                            name="Credential Discovery",
                            description=f"Credentials found in extracted data: {key}",
                            source_plugin="sqli_advanced",
                            evidence=f"Field: {key}",
                            success=True,
                        ))
                        chain.severity = Severity.CRITICAL
                        break

        chain.completed = True
        self._chains.append(chain)

    def _check_ssrf_cloud(self, pipeline: dict, host: str) -> None:
        """Chain: SSRF → cloud metadata → credentials/tokens."""
        ssrf_key = f"ssrf_check:{host}"
        ssrf_result = pipeline.get(ssrf_key)
        if not ssrf_result or not ssrf_result.ok:
            return

        ssrf_tests = ssrf_result.data.get("ssrf_tests", [])
        confirmed = [t for t in ssrf_tests if t.get("confirmed")]
        if not confirmed:
            return

        chain = ExploitChain(
            chain_id="ssrf_cloud",
            name="SSRF → Cloud Metadata → Credential Theft",
            description="SSRF to cloud metadata service for credential extraction",
            target=host,
            severity=Severity.CRITICAL,
        )

        # Step 1: SSRF confirmed
        chain.add_step(ChainStep(
            name="SSRF Confirmed",
            description="Server-side request forgery to internal endpoints",
            source_plugin="ssrf_check",
            evidence=f"Payload: {confirmed[0].get('payload', 'N/A')}",
            success=True,
        ))

        # Step 2: Cloud metadata
        meta_key = f"cloud_metadata_ssrf:{host}"
        meta_result = pipeline.get(meta_key)
        if meta_result and meta_result.ok:
            metadata = meta_result.data
            if metadata.get("cloud_metadata"):
                chain.add_step(ChainStep(
                    name="Cloud Metadata Access",
                    description="Cloud instance metadata retrieved via SSRF",
                    source_plugin="cloud_metadata_ssrf",
                    evidence=f"Provider: {metadata.get('cloud_provider', 'unknown')}",
                    data=metadata.get("cloud_metadata", {}),
                    success=True,
                ))

                # Step 3: Credentials
                creds = metadata.get("credentials_found", [])
                if creds:
                    chain.add_step(ChainStep(
                        name="Cloud Credential Theft",
                        description="IAM role credentials or tokens extracted",
                        source_plugin="cloud_metadata_ssrf",
                        evidence=f"Credentials: {', '.join(str(c) for c in creds[:3])}",
                        success=True,
                    ))

        chain.completed = True
        self._chains.append(chain)

    def _check_ssrf_internal_scan(self, pipeline: dict, host: str) -> None:
        """Chain: SSRF → internal port scan → internal service access."""
        ssrf_adv_key = f"ssrf_advanced:{host}"
        ssrf_result = pipeline.get(ssrf_adv_key)
        if not ssrf_result or not ssrf_result.ok:
            return

        internal_ports = ssrf_result.data.get("internal_ports", [])
        if not internal_ports:
            return

        chain = ExploitChain(
            chain_id="ssrf_internal",
            name="SSRF → Internal Network Scan",
            description="SSRF used to scan and access internal network services",
            target=host,
            severity=Severity.HIGH,
        )

        chain.add_step(ChainStep(
            name="SSRF to Internal Network",
            description="SSRF exploited to reach internal services",
            source_plugin="ssrf_advanced",
            evidence=f"Internal ports found: {len(internal_ports)}",
            data={"ports": internal_ports},
            success=True,
        ))

        # Check for sensitive internal services
        sensitive_ports = {p for p in internal_ports if p in (
            6379, 11211, 3306, 5432, 27017, 9200, 8500, 2375, 8080, 9090,
        )}
        if sensitive_ports:
            chain.add_step(ChainStep(
                name="Sensitive Internal Services",
                description="Sensitive services accessible via SSRF",
                source_plugin="ssrf_advanced",
                evidence=f"Ports: {sorted(sensitive_ports)}",
                success=True,
            ))
            chain.severity = Severity.CRITICAL

        chain.completed = True
        self._chains.append(chain)

    def _check_ssti_rce(self, pipeline: dict, host: str) -> None:
        """Chain: SSTI confirmed → RCE attempt."""
        ssti_key = f"ssti_verify:{host}"
        ssti_result = pipeline.get(ssti_key)
        if not ssti_result or not ssti_result.ok:
            # Try ssti_check
            ssti_key = f"ssti_check:{host}"
            ssti_result = pipeline.get(ssti_key)
            if not ssti_result or not ssti_result.ok:
                return

        ssti_tests = ssti_result.data.get("ssti_tests", [])
        confirmed = [t for t in ssti_tests if t.get("confirmed") or t.get("verdict") == "confirmed"]
        if not confirmed:
            return

        chain = ExploitChain(
            chain_id="ssti_rce",
            name="SSTI → Remote Code Execution",
            description="Template injection confirmed; RCE likely possible",
            target=host,
            severity=Severity.CRITICAL,
        )

        engine = confirmed[0].get("engine", "unknown")
        chain.add_step(ChainStep(
            name="SSTI Confirmed",
            description=f"Template injection in {engine} engine",
            source_plugin=ssti_key.split(":")[0],
            evidence=f"Engine: {engine}",
            success=True,
        ))

        chain.add_step(ChainStep(
            name="RCE Potential",
            description=f"{engine} template engine supports code execution",
            source_plugin=ssti_key.split(":")[0],
            evidence="Template engines with code execution: Jinja2, Freemarker, Twig, EL",
            success=engine.lower() in (
                "jinja2", "twig", "freemarker", "velocity", "thymeleaf",
                "smarty", "mako", "flask", "spring",
            ),
        ))

        chain.completed = True
        self._chains.append(chain)

    def _check_xss_session(self, pipeline: dict, host: str) -> None:
        """Chain: XSS → session hijacking potential."""
        xss_key = f"xss_basic:{host}"
        xss_result = pipeline.get(xss_key)
        if not xss_result or not xss_result.ok:
            xss_key = f"xss_advanced:{host}"
            xss_result = pipeline.get(xss_key)
            if not xss_result or not xss_result.ok:
                return

        xss_tests = xss_result.data.get("xss_tests", [])
        reflected = [t for t in xss_tests if t.get("reflected")]
        if not reflected:
            return

        # Check cookie security
        cookie_key = f"cookie_scan:{host}"
        cookie_result = pipeline.get(cookie_key)

        chain = ExploitChain(
            chain_id="xss_session",
            name="XSS → Session Hijacking",
            description="Reflected XSS combined with insecure cookies enables session theft",
            target=host,
            severity=Severity.HIGH,
        )

        chain.add_step(ChainStep(
            name="XSS Confirmed",
            description="Reflected input in response body",
            source_plugin=xss_key.split(":")[0],
            evidence=f"Param: {reflected[0].get('param', 'N/A')}",
            success=True,
        ))

        if cookie_result and cookie_result.ok:
            insecure = cookie_result.data.get("insecure_cookies", [])
            if insecure:
                chain.add_step(ChainStep(
                    name="Insecure Session Cookies",
                    description="Cookies without HttpOnly flag — stealable via XSS",
                    source_plugin="cookie_scan",
                    evidence=f"Insecure cookies: {len(insecure)}",
                    success=True,
                ))
                chain.severity = Severity.CRITICAL

        chain.completed = True
        self._chains.append(chain)

    def _check_lfi_rce(self, pipeline: dict, host: str) -> None:
        """Chain: LFI → sensitive file read → potential RCE via log poisoning."""
        lfi_key = f"lfi_check:{host}"
        lfi_result = pipeline.get(lfi_key)
        if not lfi_result or not lfi_result.ok:
            return

        lfi_tests = lfi_result.data.get("lfi_tests", [])
        if not lfi_tests:
            return

        chain = ExploitChain(
            chain_id="lfi_rce",
            name="LFI → File Read → Potential RCE",
            description="Local file inclusion allows reading sensitive files",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="LFI Confirmed",
            description="Local file inclusion via path traversal",
            source_plugin="lfi_check",
            evidence=f"Payload: {lfi_tests[0].get('payload', 'N/A')}",
            success=True,
        ))

        # Check tech stack for PHP (log poisoning / wrapper RCE)
        tech_key = f"tech_detect:{host}"
        tech_result = pipeline.get(tech_key)
        if tech_result and tech_result.ok:
            techs = tech_result.data.get("technologies", [])
            if "PHP" in techs:
                chain.add_step(ChainStep(
                    name="PHP Detected — Wrapper RCE Possible",
                    description=(
                        "PHP wrappers (php://input, data://, expect://) "
                        "may allow remote code execution via LFI"
                    ),
                    source_plugin="tech_detect",
                    evidence="Technology: PHP (wrappers available)",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)

    def _check_smb_shell(self, pipeline: dict, host: str) -> None:
        """Chain: SMB creds → psexec/wmiexec → shell."""
        smb_key = f"smb_enum:{host}"
        smb_result = pipeline.get(smb_key)
        if not smb_result or not smb_result.ok:
            return

        cred_key = f"credential_spray:{host}"
        cred_result = pipeline.get(cred_key)
        brute_key = f"service_brute:{host}"
        brute_result = pipeline.get(brute_key)

        found_creds = []
        if cred_result and cred_result.ok:
            found_creds.extend(cred_result.data.get("valid_creds", []))
        if brute_result and brute_result.ok:
            found_creds.extend(brute_result.data.get("found_creds", []))

        if not found_creds:
            return

        chain = ExploitChain(
            chain_id="smb_shell",
            name="SMB Credentials → Remote Shell",
            description="Valid SMB credentials enable remote code execution",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="SMB Credentials Found",
            description="Valid credentials for SMB authentication",
            source_plugin="credential_spray",
            evidence=f"Credentials: {len(found_creds)}",
            success=True,
        ))

        # Check for PTH result
        pth_key = f"pass_the_hash:{host}"
        pth_result = pipeline.get(pth_key)
        if pth_result and pth_result.ok:
            methods = pth_result.data.get("successful_methods", [])
            if methods:
                chain.add_step(ChainStep(
                    name="Remote Execution",
                    description=f"Shell via {methods[0].get('method', 'unknown')}",
                    source_plugin="pass_the_hash",
                    evidence=f"Method: {methods[0].get('method', 'N/A')}",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)

    def _check_upload_rce(self, pipeline: dict, host: str) -> None:
        """Chain: File upload bypass → webshell → reverse shell."""
        upload_key = f"file_upload_bypass:{host}"
        upload_result = pipeline.get(upload_key)
        if not upload_result or not upload_result.ok:
            return

        bypasses = upload_result.data.get("bypasses", [])
        if not bypasses:
            return

        chain = ExploitChain(
            chain_id="upload_rce",
            name="File Upload → Webshell → RCE",
            description="Upload bypass enables webshell deployment and code execution",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="Upload Bypass Confirmed",
            description=f"File upload restriction bypassed ({len(bypasses)} methods)",
            source_plugin="file_upload_bypass",
            evidence=f"Bypasses: {len(bypasses)}",
            success=True,
        ))

        webshell_key = f"webshell_deploy:{host}"
        webshell_result = pipeline.get(webshell_key)
        if webshell_result and webshell_result.ok and webshell_result.data.get("deployed"):
                chain.add_step(ChainStep(
                    name="Webshell Deployed",
                    description="Webshell accessible and executable",
                    source_plugin="webshell_deploy",
                    evidence=f"URL: {webshell_result.data.get('webshell_url', 'N/A')}",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)

    def _check_kerberoast_da(self, pipeline: dict, host: str) -> None:
        """Chain: Kerberoast → crack TGS → domain admin."""
        kerb_key = f"kerberoast:{host}"
        kerb_result = pipeline.get(kerb_key)
        if not kerb_result or not kerb_result.ok:
            return

        spn_users = kerb_result.data.get("spn_users", [])
        if not spn_users:
            return

        chain = ExploitChain(
            chain_id="kerberoast_da",
            name="Kerberoast → Crack → Domain Admin",
            description="Service account TGS tickets cracked for domain compromise",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="Kerberoastable Accounts Found",
            description=f"{len(spn_users)} accounts with SPNs",
            source_plugin="kerberoast",
            evidence=f"SPN accounts: {len(spn_users)}",
            success=True,
        ))

        tickets = kerb_result.data.get("tickets", [])
        if tickets:
            chain.add_step(ChainStep(
                name="TGS Tickets Obtained",
                description="Tickets ready for offline cracking",
                source_plugin="kerberoast",
                evidence=f"Tickets: {len(tickets)}",
                success=True,
            ))

        cracked = kerb_result.data.get("cracked", [])
        if cracked:
            chain.add_step(ChainStep(
                name="Passwords Cracked",
                description="Service account passwords recovered",
                source_plugin="kerberoast",
                evidence=f"Cracked: {len(cracked)}",
                success=True,
            ))

        chain.completed = True
        self._chains.append(chain)

    def _check_privesc_root(self, pipeline: dict, host: str) -> None:
        """Chain: Initial shell → privesc → root/SYSTEM."""
        privesc_plugins = [
            "suid_exploit", "sudo_exploit", "kernel_exploit",
            "capability_exploit", "cron_exploit",
            "win_service_exploit", "win_token_exploit",
        ]

        privesc_found = []
        for plugin_name in privesc_plugins:
            key = f"{plugin_name}:{host}"
            result = pipeline.get(key)
            if result and result.ok:
                plugin_data = result.data
                vectors = plugin_data.get("exploitable_suids", [])
                vectors += plugin_data.get("exploitable_rules", [])
                vectors += plugin_data.get("matching_cves", [])
                vectors += plugin_data.get("exploitable", [])
                vectors += plugin_data.get("writable_scripts", [])
                if vectors:
                    privesc_found.append((plugin_name, len(vectors)))

        if not privesc_found:
            return

        chain = ExploitChain(
            chain_id="privesc_root",
            name="Initial Access → Privilege Escalation → Root/SYSTEM",
            description="Multiple privesc vectors enable full system compromise",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="Initial Shell Obtained",
            description="Low-privilege shell session active",
            source_plugin="exploitation",
            evidence="Active shell session",
            success=True,
        ))

        for plugin_name, count in privesc_found:
            chain.add_step(ChainStep(
                name=f"PrivEsc: {plugin_name}",
                description=f"{count} exploitation vectors found",
                source_plugin=plugin_name,
                evidence=f"Vectors: {count}",
                success=True,
            ))

        chain.completed = True
        self._chains.append(chain)

    def _check_cred_reuse(self, pipeline: dict, host: str) -> None:
        """Chain: Default creds found → admin panel access."""
        cred_key = f"default_creds:{host}"
        cred_result = pipeline.get(cred_key)
        if not cred_result or not cred_result.ok:
            return

        cred_data = cred_result.data.get("found_creds", [])
        if not cred_data:
            return

        admin_key = f"admin_finder:{host}"
        admin_result = pipeline.get(admin_key)

        chain = ExploitChain(
            chain_id="cred_reuse",
            name="Default Credentials → Admin Access",
            description="Default/weak credentials found; admin panel likely accessible",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="Default Credentials Found",
            description="Weak or default credentials discovered",
            source_plugin="default_creds",
            evidence=f"Found {len(cred_data)} credential pairs",
            success=True,
        ))

        if admin_result and admin_result.ok:
            admin_panels = admin_result.data.get("admin_panels", [])
            if admin_panels:
                chain.add_step(ChainStep(
                    name="Admin Panel Located",
                    description="Admin panel found for credential testing",
                    source_plugin="admin_finder",
                    evidence=f"Panels: {', '.join(str(p) for p in admin_panels[:3])}",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)
