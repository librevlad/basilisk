"""Multi-stage exploitation chain engine.

Orchestrates chained attacks where one vulnerability's output feeds the next:
  SQLi → data extraction → credential reuse
  SSRF → cloud metadata → AWS keys → S3 bucket access
  XSS → session theft → admin panel access

Chains run automatically after the pentesting phase completes,
using pipeline results to determine which chains are viable.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Any

from basilisk.models.result import Finding, Severity

logger = logging.getLogger(__name__)


@dataclass
class ChainStep:
    """A single step in an exploitation chain."""

    name: str
    description: str
    source_plugin: str          # Plugin that provides the trigger data
    evidence: str = ""          # Evidence collected at this step
    data: dict[str, Any] = field(default_factory=dict)
    success: bool = False


@dataclass
class ExploitChain:
    """A completed or in-progress exploitation chain."""

    chain_id: str
    name: str
    description: str
    target: str
    steps: list[ChainStep] = field(default_factory=list)
    severity: Severity = Severity.HIGH
    completed: bool = False

    @property
    def step_count(self) -> int:
        return len(self.steps)

    @property
    def successful_steps(self) -> int:
        return sum(1 for s in self.steps if s.success)

    def add_step(self, step: ChainStep) -> None:
        self.steps.append(step)

    def to_finding(self) -> Finding:
        """Convert completed chain to a Finding for the report."""
        evidence_parts = []
        for i, step in enumerate(self.steps, 1):
            status = "OK" if step.success else "FAILED"
            evidence_parts.append(
                f"Step {i} [{status}]: {step.name} — {step.evidence or step.description}"
            )

        return Finding(
            severity=self.severity,
            title=f"Exploit chain: {self.name}",
            description=(
                f"{self.description}\n"
                f"Completed {self.successful_steps}/{self.step_count} steps"
            ),
            evidence="\n".join(evidence_parts),
            remediation=_CHAIN_REMEDIATION.get(self.chain_id, "Review and fix all steps"),
            tags=["exploit-chain", self.chain_id],
        )


# Remediation per chain type
_CHAIN_REMEDIATION: dict[str, str] = {
    "sqli_extract": (
        "Use parameterized queries. Implement least-privilege DB access. "
        "Encrypt sensitive data at rest."
    ),
    "ssrf_cloud": (
        "Validate and whitelist URLs server-side. Block access to metadata endpoints. "
        "Use IMDSv2 (AWS) with hop limit. Rotate any exposed credentials immediately."
    ),
    "ssrf_internal": (
        "Implement URL allowlists. Block private IP ranges in outbound requests. "
        "Use network segmentation to limit SSRF impact."
    ),
    "ssti_rce": (
        "Never pass user input to template engines. Use sandboxed template rendering. "
        "Implement strict input validation."
    ),
    "xss_session": (
        "Implement HttpOnly and Secure flags on session cookies. "
        "Use Content-Security-Policy headers. Apply context-aware output encoding."
    ),
    "lfi_rce": (
        "Never use user input in file paths. Implement allowlists for file access. "
        "Disable dangerous PHP wrappers (expect://, data://)."
    ),
}


class ExploitChainEngine:
    """Orchestrates multi-stage exploitation chains.

    After pentesting plugins complete, the engine examines pipeline results
    to identify viable chains and executes them.

    Usage::

        engine = ExploitChainEngine()
        chains = engine.analyze(pipeline, target_host, ctx)
        for chain in chains:
            findings.extend([chain.to_finding()])
    """

    def __init__(self) -> None:
        self._chains: list[ExploitChain] = []

    @property
    def chains(self) -> list[ExploitChain]:
        return list(self._chains)

    def analyze(
        self,
        pipeline: dict[str, Any],
        host: str,
        ctx: Any = None,
    ) -> list[ExploitChain]:
        """Analyze pipeline results and build viable chains."""
        self._chains = []

        self._check_sqli_extract(pipeline, host)
        self._check_ssrf_cloud(pipeline, host)
        self._check_ssrf_internal_scan(pipeline, host)
        self._check_ssti_rce(pipeline, host)
        self._check_xss_session(pipeline, host)
        self._check_lfi_rce(pipeline, host)
        self._check_cred_reuse(pipeline, host)

        completed = [c for c in self._chains if c.completed]
        if completed:
            logger.info(
                "Exploit chains for %s: %d viable (%s)",
                host, len(completed),
                ", ".join(c.chain_id for c in completed),
            )
        return completed

    def _check_sqli_extract(self, pipeline: dict, host: str) -> None:
        """Chain: SQLi found → extract DB version/data → find credentials."""
        sqli_key = f"sqli_basic:{host}"
        sqli_result = pipeline.get(sqli_key)
        if not sqli_result or not sqli_result.ok:
            return

        sqli_tests = sqli_result.data.get("sqli_tests", [])
        if not sqli_tests:
            return

        chain = ExploitChain(
            chain_id="sqli_extract",
            name="SQL Injection → Data Extraction",
            description="SQL injection confirmed; database data may be extractable",
            target=host,
            severity=Severity.CRITICAL,
        )

        # Step 1: SQLi confirmed
        first_test = sqli_tests[0]
        dbms = first_test.get("dbms", "unknown")
        chain.add_step(ChainStep(
            name="SQL Injection Confirmed",
            description=f"Error-based SQLi detected ({dbms})",
            source_plugin="sqli_basic",
            evidence=f"DBMS: {dbms}, Payload: {first_test.get('payload', 'N/A')}",
            data={"dbms": dbms},
            success=True,
        ))

        # Step 2: Check if advanced extraction ran
        adv_key = f"sqli_advanced:{host}"
        adv_result = pipeline.get(adv_key)
        if adv_result and adv_result.ok:
            extracted = adv_result.data.get("extracted", {})
            if extracted:
                chain.add_step(ChainStep(
                    name="Data Extraction",
                    description="Database information extracted via UNION/blind",
                    source_plugin="sqli_advanced",
                    evidence=f"Extracted: {', '.join(extracted.keys())}",
                    data=extracted,
                    success=True,
                ))

                # Check for credentials in extracted data
                cred_indicators = ["password", "pass", "pwd", "secret", "token", "hash"]
                for key, _value in extracted.items():
                    if any(ind in key.lower() for ind in cred_indicators):
                        chain.add_step(ChainStep(
                            name="Credential Discovery",
                            description=f"Credentials found in extracted data: {key}",
                            source_plugin="sqli_advanced",
                            evidence=f"Field: {key}",
                            success=True,
                        ))
                        chain.severity = Severity.CRITICAL
                        break

        chain.completed = True
        self._chains.append(chain)

    def _check_ssrf_cloud(self, pipeline: dict, host: str) -> None:
        """Chain: SSRF → cloud metadata → credentials/tokens."""
        ssrf_key = f"ssrf_check:{host}"
        ssrf_result = pipeline.get(ssrf_key)
        if not ssrf_result or not ssrf_result.ok:
            return

        ssrf_tests = ssrf_result.data.get("ssrf_tests", [])
        confirmed = [t for t in ssrf_tests if t.get("confirmed")]
        if not confirmed:
            return

        chain = ExploitChain(
            chain_id="ssrf_cloud",
            name="SSRF → Cloud Metadata → Credential Theft",
            description="SSRF to cloud metadata service for credential extraction",
            target=host,
            severity=Severity.CRITICAL,
        )

        # Step 1: SSRF confirmed
        chain.add_step(ChainStep(
            name="SSRF Confirmed",
            description="Server-side request forgery to internal endpoints",
            source_plugin="ssrf_check",
            evidence=f"Payload: {confirmed[0].get('payload', 'N/A')}",
            success=True,
        ))

        # Step 2: Cloud metadata
        meta_key = f"cloud_metadata_ssrf:{host}"
        meta_result = pipeline.get(meta_key)
        if meta_result and meta_result.ok:
            metadata = meta_result.data
            if metadata.get("cloud_metadata"):
                chain.add_step(ChainStep(
                    name="Cloud Metadata Access",
                    description="Cloud instance metadata retrieved via SSRF",
                    source_plugin="cloud_metadata_ssrf",
                    evidence=f"Provider: {metadata.get('cloud_provider', 'unknown')}",
                    data=metadata.get("cloud_metadata", {}),
                    success=True,
                ))

                # Step 3: Credentials
                creds = metadata.get("credentials_found", [])
                if creds:
                    chain.add_step(ChainStep(
                        name="Cloud Credential Theft",
                        description="IAM role credentials or tokens extracted",
                        source_plugin="cloud_metadata_ssrf",
                        evidence=f"Credentials: {', '.join(str(c) for c in creds[:3])}",
                        success=True,
                    ))

        chain.completed = True
        self._chains.append(chain)

    def _check_ssrf_internal_scan(self, pipeline: dict, host: str) -> None:
        """Chain: SSRF → internal port scan → internal service access."""
        ssrf_adv_key = f"ssrf_advanced:{host}"
        ssrf_result = pipeline.get(ssrf_adv_key)
        if not ssrf_result or not ssrf_result.ok:
            return

        internal_ports = ssrf_result.data.get("internal_ports", [])
        if not internal_ports:
            return

        chain = ExploitChain(
            chain_id="ssrf_internal",
            name="SSRF → Internal Network Scan",
            description="SSRF used to scan and access internal network services",
            target=host,
            severity=Severity.HIGH,
        )

        chain.add_step(ChainStep(
            name="SSRF to Internal Network",
            description="SSRF exploited to reach internal services",
            source_plugin="ssrf_advanced",
            evidence=f"Internal ports found: {len(internal_ports)}",
            data={"ports": internal_ports},
            success=True,
        ))

        # Check for sensitive internal services
        sensitive_ports = {p for p in internal_ports if p in (
            6379, 11211, 3306, 5432, 27017, 9200, 8500, 2375, 8080, 9090,
        )}
        if sensitive_ports:
            chain.add_step(ChainStep(
                name="Sensitive Internal Services",
                description="Sensitive services accessible via SSRF",
                source_plugin="ssrf_advanced",
                evidence=f"Ports: {sorted(sensitive_ports)}",
                success=True,
            ))
            chain.severity = Severity.CRITICAL

        chain.completed = True
        self._chains.append(chain)

    def _check_ssti_rce(self, pipeline: dict, host: str) -> None:
        """Chain: SSTI confirmed → RCE attempt."""
        ssti_key = f"ssti_verify:{host}"
        ssti_result = pipeline.get(ssti_key)
        if not ssti_result or not ssti_result.ok:
            # Try ssti_check
            ssti_key = f"ssti_check:{host}"
            ssti_result = pipeline.get(ssti_key)
            if not ssti_result or not ssti_result.ok:
                return

        ssti_tests = ssti_result.data.get("ssti_tests", [])
        confirmed = [t for t in ssti_tests if t.get("confirmed") or t.get("verdict") == "confirmed"]
        if not confirmed:
            return

        chain = ExploitChain(
            chain_id="ssti_rce",
            name="SSTI → Remote Code Execution",
            description="Template injection confirmed; RCE likely possible",
            target=host,
            severity=Severity.CRITICAL,
        )

        engine = confirmed[0].get("engine", "unknown")
        chain.add_step(ChainStep(
            name="SSTI Confirmed",
            description=f"Template injection in {engine} engine",
            source_plugin=ssti_key.split(":")[0],
            evidence=f"Engine: {engine}",
            success=True,
        ))

        chain.add_step(ChainStep(
            name="RCE Potential",
            description=f"{engine} template engine supports code execution",
            source_plugin=ssti_key.split(":")[0],
            evidence="Template engines with code execution: Jinja2, Freemarker, Twig, EL",
            success=engine.lower() in (
                "jinja2", "twig", "freemarker", "velocity", "thymeleaf",
                "smarty", "mako", "flask", "spring",
            ),
        ))

        chain.completed = True
        self._chains.append(chain)

    def _check_xss_session(self, pipeline: dict, host: str) -> None:
        """Chain: XSS → session hijacking potential."""
        xss_key = f"xss_basic:{host}"
        xss_result = pipeline.get(xss_key)
        if not xss_result or not xss_result.ok:
            xss_key = f"xss_advanced:{host}"
            xss_result = pipeline.get(xss_key)
            if not xss_result or not xss_result.ok:
                return

        xss_tests = xss_result.data.get("xss_tests", [])
        reflected = [t for t in xss_tests if t.get("reflected")]
        if not reflected:
            return

        # Check cookie security
        cookie_key = f"cookie_scan:{host}"
        cookie_result = pipeline.get(cookie_key)

        chain = ExploitChain(
            chain_id="xss_session",
            name="XSS → Session Hijacking",
            description="Reflected XSS combined with insecure cookies enables session theft",
            target=host,
            severity=Severity.HIGH,
        )

        chain.add_step(ChainStep(
            name="XSS Confirmed",
            description="Reflected input in response body",
            source_plugin=xss_key.split(":")[0],
            evidence=f"Param: {reflected[0].get('param', 'N/A')}",
            success=True,
        ))

        if cookie_result and cookie_result.ok:
            insecure = cookie_result.data.get("insecure_cookies", [])
            if insecure:
                chain.add_step(ChainStep(
                    name="Insecure Session Cookies",
                    description="Cookies without HttpOnly flag — stealable via XSS",
                    source_plugin="cookie_scan",
                    evidence=f"Insecure cookies: {len(insecure)}",
                    success=True,
                ))
                chain.severity = Severity.CRITICAL

        chain.completed = True
        self._chains.append(chain)

    def _check_lfi_rce(self, pipeline: dict, host: str) -> None:
        """Chain: LFI → sensitive file read → potential RCE via log poisoning."""
        lfi_key = f"lfi_check:{host}"
        lfi_result = pipeline.get(lfi_key)
        if not lfi_result or not lfi_result.ok:
            return

        lfi_tests = lfi_result.data.get("lfi_tests", [])
        if not lfi_tests:
            return

        chain = ExploitChain(
            chain_id="lfi_rce",
            name="LFI → File Read → Potential RCE",
            description="Local file inclusion allows reading sensitive files",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="LFI Confirmed",
            description="Local file inclusion via path traversal",
            source_plugin="lfi_check",
            evidence=f"Payload: {lfi_tests[0].get('payload', 'N/A')}",
            success=True,
        ))

        # Check tech stack for PHP (log poisoning / wrapper RCE)
        tech_key = f"tech_detect:{host}"
        tech_result = pipeline.get(tech_key)
        if tech_result and tech_result.ok:
            techs = tech_result.data.get("technologies", [])
            if "PHP" in techs:
                chain.add_step(ChainStep(
                    name="PHP Detected — Wrapper RCE Possible",
                    description=(
                        "PHP wrappers (php://input, data://, expect://) "
                        "may allow remote code execution via LFI"
                    ),
                    source_plugin="tech_detect",
                    evidence="Technology: PHP (wrappers available)",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)

    def _check_cred_reuse(self, pipeline: dict, host: str) -> None:
        """Chain: Default creds found → admin panel access."""
        cred_key = f"default_creds:{host}"
        cred_result = pipeline.get(cred_key)
        if not cred_result or not cred_result.ok:
            return

        cred_data = cred_result.data.get("found_creds", [])
        if not cred_data:
            return

        admin_key = f"admin_finder:{host}"
        admin_result = pipeline.get(admin_key)

        chain = ExploitChain(
            chain_id="cred_reuse",
            name="Default Credentials → Admin Access",
            description="Default/weak credentials found; admin panel likely accessible",
            target=host,
            severity=Severity.CRITICAL,
        )

        chain.add_step(ChainStep(
            name="Default Credentials Found",
            description="Weak or default credentials discovered",
            source_plugin="default_creds",
            evidence=f"Found {len(cred_data)} credential pairs",
            success=True,
        ))

        if admin_result and admin_result.ok:
            admin_panels = admin_result.data.get("admin_panels", [])
            if admin_panels:
                chain.add_step(ChainStep(
                    name="Admin Panel Located",
                    description="Admin panel found for credential testing",
                    source_plugin="admin_finder",
                    evidence=f"Panels: {', '.join(str(p) for p in admin_panels[:3])}",
                    success=True,
                ))

        chain.completed = True
        self._chains.append(chain)
