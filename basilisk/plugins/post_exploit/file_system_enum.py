"""File system enumeration â€” configs, backups, databases, .git, sensitive files."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

LINUX_SENSITIVE_PATHS = [
    "/etc/shadow", "/etc/sudoers", "/etc/krb5.conf",
    "/var/www/html/.git/HEAD", "/var/www/html/.env",
    "/var/www/html/wp-config.php", "/var/www/html/config.php",
    "/var/www/html/configuration.php", "/var/www/html/.htpasswd",
    "/opt/*/.env", "/opt/*/.git/HEAD",
    "/var/backups/*.sql", "/var/backups/*.tar.gz", "/var/backups/*.zip",
    "/tmp/*.sql", "/tmp/*.bak", "/tmp/*.dump",
    "/root/.ssh/authorized_keys", "/root/.gitconfig",
]

WINDOWS_SENSITIVE_PATHS = [
    r"C:\inetpub\wwwroot\web.config",
    r"C:\inetpub\wwwroot\.git\HEAD",
    r"C:\Windows\System32\config\SAM",
    r"C:\Windows\System32\config\SYSTEM",
    r"C:\Windows\Panther\Unattend.xml",
    r"C:\Windows\Panther\unattend\Unattend.xml",
    r"C:\Users\*\Desktop\*.txt",
    r"C:\Users\*\Documents\*.kdbx",
    r"C:\ProgramData\*.config",
]

BACKUP_EXTENSIONS = [".bak", ".old", ".orig", ".save", ".swp", ".sql", ".dump", ".tar.gz", ".zip"]


class FileSystemEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="file_system_enum",
        display_name="File System Enumeration",
        category=PluginCategory.POST_EXPLOIT,
        description="Configs, backups, databases, .git, sensitive files",
        produces=["sensitive_files"],
        timeout=90.0,
        requires_http=False,
        requires_shell=True,
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"sensitive_files": [], "git_repos": [], "backups": []}

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = (
            ctx.shell.get_session(shells[0]["id"])
            if isinstance(shells[0], dict) else None
        )
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        from basilisk.utils.shell import ShellOS
        is_windows = session.os == ShellOS.WINDOWS

        # Find .git directories
        if not is_windows:
            git_search = await ctx.shell.execute(
                session,
                "find / -name '.git' -type d 2>/dev/null | head -20",
                timeout=15.0,
            )
            if git_search:
                for git_dir in git_search.strip().splitlines():
                    data["git_repos"].append(git_dir)
                if data["git_repos"]:
                    findings.append(Finding.high(
                        f"Git repositories found: {len(data['git_repos'])}",
                        evidence="\n".join(data["git_repos"][:10]),
                        description="Git repos may contain credentials in history",
                        tags=["post-exploit", "git", "sensitive-file"],
                    ))

        # Find backup files
        if not is_windows:
            ext_pattern = " -o ".join(
                f'-name "*{ext}"' for ext in BACKUP_EXTENSIONS
            )
            backup_search = await ctx.shell.execute(
                session,
                f"find / \\( {ext_pattern} \\) -type f 2>/dev/null | head -30",
                timeout=15.0,
            )
            if backup_search:
                for backup in backup_search.strip().splitlines():
                    data["backups"].append(backup)
                if data["backups"]:
                    findings.append(Finding.medium(
                        f"Backup files found: {len(data['backups'])}",
                        evidence="\n".join(data["backups"][:15]),
                        tags=["post-exploit", "backup"],
                    ))

        # Check sensitive file paths
        paths = WINDOWS_SENSITIVE_PATHS if is_windows else LINUX_SENSITIVE_PATHS
        for path in paths:
            if ctx.should_stop:
                break
            if is_windows:
                cmd = f'if exist "{path}" echo FOUND:{path}'
            else:
                cmd = f"test -r {path} && echo FOUND:{path}"
            output = await ctx.shell.execute(session, cmd, timeout=3.0)
            if output and "FOUND:" in output:
                data["sensitive_files"].append(path)

        if data["sensitive_files"]:
            findings.append(Finding.high(
                f"Readable sensitive files: {len(data['sensitive_files'])}",
                evidence="\n".join(data["sensitive_files"][:20]),
                tags=["post-exploit", "sensitive-file"],
            ))

        if not findings:
            findings.append(Finding.info(
                "No notable sensitive files found", tags=["post-exploit"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
