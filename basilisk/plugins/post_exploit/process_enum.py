"""Process enumeration â€” running processes, listening services, connections."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Interesting processes for exploitation
INTERESTING_PROCESSES = {
    "docker", "dockerd", "containerd", "lxd",
    "mysql", "mysqld", "postgres", "postgresql", "mongod", "redis-server",
    "apache2", "httpd", "nginx", "tomcat", "java",
    "smbd", "nmbd", "winbindd",
    "sshd", "vsftpd", "proftpd",
    "cron", "anacron",
    "screen", "tmux",
}


class ProcessEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="process_enum",
        display_name="Process Enumeration",
        category=PluginCategory.POST_EXPLOIT,
        description="Running processes, listening services, connections",
        produces=["processes"],
        timeout=30.0,
        requires_http=False,
        requires_shell=True,
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "processes": [], "listening": [], "connections": [],
            "interesting": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = (
            ctx.shell.get_session(shells[0]["id"])
            if isinstance(shells[0], dict) else None
        )
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        from basilisk.utils.shell import ShellOS
        is_windows = session.os == ShellOS.WINDOWS

        # Get process list
        ps_cmd = "tasklist /v 2>nul" if is_windows else "ps aux 2>/dev/null"
        ps_output = await ctx.shell.execute(session, ps_cmd, timeout=10.0)
        if ps_output:
            data["processes"] = ps_output.strip().splitlines()[:100]
            findings.append(Finding.info(
                f"Processes enumerated: {len(data['processes'])} lines",
                evidence=ps_output[:500],
                tags=["post-exploit", "process"],
            ))

            # Check for interesting processes
            for line in data["processes"]:
                lower = line.lower()
                for proc in INTERESTING_PROCESSES:
                    if proc in lower:
                        data["interesting"].append(line.strip())
                        break

            if data["interesting"]:
                findings.append(Finding.medium(
                    f"Interesting processes: {len(data['interesting'])}",
                    evidence="\n".join(data["interesting"][:15]),
                    description="These processes may be exploitable or useful",
                    tags=["post-exploit", "process"],
                ))

        # Get listening ports
        if is_windows:
            net_cmd = "netstat -ano | findstr LISTENING"
        else:
            net_cmd = "ss -tulnp 2>/dev/null || netstat -tulnp 2>/dev/null"
        net_output = await ctx.shell.execute(session, net_cmd, timeout=10.0)
        if net_output:
            data["listening"] = net_output.strip().splitlines()[:50]
            findings.append(Finding.info(
                f"Listening services: {len(data['listening'])}",
                evidence=net_output[:500],
                tags=["post-exploit", "network"],
            ))

            # Check for internal-only services
            internal_services = [
                line for line in data["listening"]
                if "127.0.0.1" in line or "::1" in line
            ]
            if internal_services:
                findings.append(Finding.medium(
                    f"Internal-only services: {len(internal_services)}",
                    evidence="\n".join(internal_services[:10]),
                    description="Accessible via port forwarding or pivoting",
                    tags=["post-exploit", "internal-service"],
                ))

        # Active connections (outbound)
        if not is_windows:
            conn_cmd = "ss -tnp 2>/dev/null | grep ESTAB || netstat -tnp 2>/dev/null | grep ESTAB"
            conn_output = await ctx.shell.execute(session, conn_cmd, timeout=5.0)
            if conn_output:
                data["connections"] = conn_output.strip().splitlines()[:30]

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
