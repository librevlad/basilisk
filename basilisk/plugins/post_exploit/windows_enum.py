"""Windows enumeration â€” WinPEAS equivalent via shell session."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

WIN_ENUM_COMMANDS = {
    "sysinfo": "systeminfo",
    "whoami_priv": "whoami /priv",
    "whoami_groups": "whoami /groups",
    "users": "net user",
    "localadmins": "net localgroup administrators",
    "services": 'wmic service get name,pathname,startmode 2>nul | findstr /i "auto"',
    "unquoted": (
        'wmic service get name,displayname,pathname,startmode 2>nul '
        '| findstr /i "auto" | findstr /i /v "c:\\windows\\\\"'
    ),
    "tasks": "schtasks /query /fo LIST /v 2>nul | findstr /i taskname",
    "installed": 'wmic product get name,version 2>nul | findstr /v "^$"',
    "network": "ipconfig /all",
    "arp": "arp -a",
    "routes": "route print",
    "firewall": "netsh advfirewall show allprofiles state",
    "listening": "netstat -ano | findstr LISTENING",
    "env": "set",
    "drives": "wmic logicaldisk get caption,description",
    "autologon": (
        'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT'
        '\\CurrentVersion\\Winlogon" 2>nul'
    ),
    "always_install": (
        'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer '
        '/v AlwaysInstallElevated 2>nul'
    ),
    "uac": (
        'reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion'
        '\\Policies\\System /v EnableLUA 2>nul'
    ),
    "saved_creds": "cmdkey /list",
    "wifi": "netsh wlan show profiles 2>nul",
}

# Dangerous Windows privileges for token abuse
DANGEROUS_PRIVS = {
    "SeImpersonatePrivilege": "Potato attacks (JuicyPotato, PrintSpoofer)",
    "SeAssignPrimaryTokenPrivilege": "Token manipulation",
    "SeTcbPrivilege": "Act as part of the OS",
    "SeBackupPrivilege": "Read any file (SAM/SYSTEM/NTDS.dit)",
    "SeRestorePrivilege": "Write any file (DLL hijack)",
    "SeLoadDriverPrivilege": "Load vulnerable driver",
    "SeTakeOwnershipPrivilege": "Take ownership of files/registry",
    "SeDebugPrivilege": "Debug processes (dump LSASS)",
}


class WindowsEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="windows_enum",
        display_name="Windows Post-Exploitation Enumeration",
        category=PluginCategory.POST_EXPLOIT,
        description="Services, tasks, UAC, registry, privileges, AlwaysInstallElevated",
        produces=["windows_enum", "credentials", "privesc_vectors"],
        timeout=120.0,
        requires_http=False,
        requires_shell=True,
        platform="windows",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "os_info": "", "privileges": [], "services": [],
            "privesc_vectors": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="No active shell session available",
            )

        session = ctx.shell.get_session(shells[0]["id"]) if isinstance(shells[0], dict) else None
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        results = {}
        for name, cmd in WIN_ENUM_COMMANDS.items():
            if ctx.should_stop:
                break
            output = await ctx.shell.execute(session, cmd, timeout=15.0)
            results[name] = output

        # OS info
        if results.get("sysinfo"):
            data["os_info"] = results["sysinfo"][:500]
            findings.append(Finding.info(
                "System information enumerated",
                evidence=results["sysinfo"][:300],
                tags=["post-exploit", "windows"],
            ))

        # Privilege analysis
        if results.get("whoami_priv"):
            privs = results["whoami_priv"]
            data["privileges"] = privs.splitlines()
            for priv_name, description in DANGEROUS_PRIVS.items():
                if priv_name in privs and "Enabled" in privs:
                    data["privesc_vectors"].append({
                        "type": "privilege", "name": priv_name,
                        "description": description,
                    })
                    findings.append(Finding.critical(
                        f"Dangerous privilege: {priv_name}",
                        evidence=f"{priv_name}: {description}",
                        description=f"Exploitable for privesc: {description}",
                        tags=["post-exploit", "privilege", "privesc"],
                    ))

        # Unquoted service paths
        if results.get("unquoted"):
            lines = [
                ln for ln in results["unquoted"].splitlines()
                if ln.strip() and " " in ln and not ln.strip().startswith('"')
            ]
            if lines:
                data["privesc_vectors"].append({
                    "type": "unquoted_service_path",
                    "services": lines[:10],
                })
                findings.append(Finding.high(
                    f"Unquoted service paths: {len(lines)}",
                    evidence="\n".join(lines[:10]),
                    description="Exploitable if writable path component exists",
                    tags=["post-exploit", "unquoted-path", "privesc"],
                ))

        # AlwaysInstallElevated
        if results.get("always_install") and "0x1" in results["always_install"]:
            data["privesc_vectors"].append({"type": "always_install_elevated"})
            findings.append(Finding.critical(
                "AlwaysInstallElevated enabled",
                evidence=results["always_install"],
                description="Any MSI package will install with SYSTEM privileges",
                remediation="Set AlwaysInstallElevated to 0",
                tags=["post-exploit", "msi", "privesc"],
            ))

        # Saved credentials
        if results.get("saved_creds") and "Target:" in results["saved_creds"]:
            findings.append(Finding.high(
                "Saved credentials found",
                evidence=results["saved_creds"][:300],
                description="Use: runas /savecred /user:<user> cmd.exe",
                tags=["post-exploit", "credential"],
            ))

        # Autologon credentials
        if results.get("autologon"):
            autologon = results["autologon"]
            if "DefaultPassword" in autologon:
                findings.append(Finding.critical(
                    "Autologon credentials in registry",
                    evidence=autologon[:300],
                    tags=["post-exploit", "credential", "autologon"],
                ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
