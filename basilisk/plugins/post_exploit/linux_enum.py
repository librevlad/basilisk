"""Linux enumeration â€” LinPEAS equivalent via shell session."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Commands to run for enumeration
ENUM_COMMANDS = {
    "os_info": "uname -a",
    "hostname": "hostname",
    "whoami": "id",
    "users": "cat /etc/passwd | grep -v nologin | grep -v false",
    "sudo_perms": "sudo -l 2>/dev/null",
    "suid": "find / -perm -4000 -type f 2>/dev/null",
    "sgid": "find / -perm -2000 -type f 2>/dev/null",
    "capabilities": "getcap -r / 2>/dev/null",
    "cron_system": "cat /etc/crontab 2>/dev/null",
    "cron_user": "crontab -l 2>/dev/null",
    "cron_dirs": "ls -la /etc/cron* 2>/dev/null",
    "writable_dirs": "find / -writable -type d 2>/dev/null | head -30",
    "writable_files": "find /etc -writable -type f 2>/dev/null",
    "env_vars": "env 2>/dev/null",
    "processes": "ps aux 2>/dev/null",
    "network": "ss -tulnp 2>/dev/null || netstat -tulnp 2>/dev/null",
    "interfaces": "ip addr 2>/dev/null || ifconfig 2>/dev/null",
    "routes": "ip route 2>/dev/null || route -n 2>/dev/null",
    "arp": "ip neigh 2>/dev/null || arp -a 2>/dev/null",
    "hosts": "cat /etc/hosts",
    "ssh_keys": "find / -name id_rsa -o -name id_ecdsa -o -name id_ed25519 2>/dev/null",
    "history": "cat ~/.bash_history ~/.zsh_history 2>/dev/null | tail -50",
    "kernel": "uname -r",
    "docker_check": "id | grep -i docker; ls -la /var/run/docker.sock 2>/dev/null",
    "lxc_check": "id | grep -i lxd; ls -la /dev/lxd 2>/dev/null",
}

# Interesting SUID binaries (GTFOBins)
GTFOBINS_SUID = {
    "python", "python3", "perl", "ruby", "bash", "sh", "dash", "zsh",
    "env", "find", "nmap", "vim", "vi", "nano", "less", "more", "awk",
    "gawk", "cp", "mv", "tar", "zip", "gcc", "make", "pkexec",
    "php", "node", "lua", "strace", "ltrace", "gdb", "docker",
    "systemctl", "journalctl", "dmesg", "mount", "umount", "dd",
    "wget", "curl", "nc", "ncat", "socat", "ssh", "scp", "rsync",
    "tee", "screen", "tmux", "script", "ed", "sed", "openssl",
    "aria2c", "base64", "busybox", "date", "dialog", "diff",
    "expect", "flock", "fmt", "fold", "ftp", "git", "head",
    "ionice", "ip", "jjs", "jq", "ksh", "logsave", "man",
    "mawk", "nice", "nl", "od", "pdb", "pic", "pico", "rev",
    "rlwrap", "rpm", "rpmquery", "run-parts", "rvim",
    "setarch", "shuf", "sort", "sqlite3", "ssh-keyscan", "start-stop-daemon",
    "stdbuf", "taskset", "time", "timeout", "ul", "unexpand",
    "uniq", "unshare", "watch", "xargs",
}


class LinuxEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="linux_enum",
        display_name="Linux Post-Exploitation Enumeration",
        category=PluginCategory.POST_EXPLOIT,
        description="SUID, sudo, cron, capabilities, writable dirs, kernel version",
        produces=["linux_enum", "credentials", "privesc_vectors"],
        timeout=120.0,
        requires_http=False,
        requires_shell=True,
        platform="linux",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "os_info": "", "suid_binaries": [], "sudo_perms": "",
            "capabilities": [], "cron_jobs": [], "writable": [],
            "privesc_vectors": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="No active shell session available",
            )

        session = ctx.shell.get_session(shells[0]["id"]) if isinstance(shells[0], dict) else None
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        # Run all enumeration commands
        results = {}
        for name, cmd in ENUM_COMMANDS.items():
            if ctx.should_stop:
                break
            output = await ctx.shell.execute(session, cmd, timeout=10.0)
            results[name] = output

        # Analyze OS info
        if results.get("os_info"):
            data["os_info"] = results["os_info"]
            findings.append(Finding.info(
                f"System: {results['os_info'][:100]}",
                evidence=results["os_info"],
                tags=["post-exploit", "linux"],
            ))

        # Analyze SUID binaries
        if results.get("suid"):
            suid_bins = results["suid"].strip().splitlines()
            data["suid_binaries"] = suid_bins
            exploitable = []
            for binary in suid_bins:
                name = binary.split("/")[-1]
                if name in GTFOBINS_SUID:
                    exploitable.append(binary)
                    data["privesc_vectors"].append({
                        "type": "suid", "binary": binary,
                        "reference": f"https://gtfobins.github.io/gtfobins/{name}/",
                    })

            if exploitable:
                findings.append(Finding.critical(
                    f"Exploitable SUID binaries: {len(exploitable)}",
                    evidence="\n".join(exploitable[:20]),
                    description="These SUID binaries can be exploited for privilege escalation",
                    remediation="Remove unnecessary SUID bits",
                    tags=["post-exploit", "suid", "privesc"],
                ))

        # Analyze sudo permissions
        if results.get("sudo_perms") and "NOPASSWD" in results["sudo_perms"]:
            data["sudo_perms"] = results["sudo_perms"]
            findings.append(Finding.critical(
                "NOPASSWD sudo permissions found",
                evidence=results["sudo_perms"][:500],
                description="User can run commands as root without password",
                tags=["post-exploit", "sudo", "privesc"],
            ))

        # Analyze capabilities
        if results.get("capabilities"):
            caps = results["capabilities"].strip().splitlines()
            data["capabilities"] = caps
            dangerous_caps = [
                c for c in caps
                if any(d in c for d in ["cap_setuid", "cap_dac_read", "cap_sys_admin"])
            ]
            if dangerous_caps:
                findings.append(Finding.high(
                    f"Dangerous capabilities found: {len(dangerous_caps)}",
                    evidence="\n".join(dangerous_caps[:10]),
                    tags=["post-exploit", "capabilities", "privesc"],
                ))

        # Analyze cron jobs
        cron_output = results.get("cron_system", "") + results.get("cron_dirs", "")
        if cron_output:
            data["cron_jobs"] = cron_output.splitlines()[:20]
            findings.append(Finding.info(
                "Cron jobs enumerated",
                evidence=cron_output[:500],
                tags=["post-exploit", "cron"],
            ))

        # Check for SSH keys
        if results.get("ssh_keys"):
            findings.append(Finding.high(
                "SSH private keys found",
                evidence=results["ssh_keys"][:300],
                tags=["post-exploit", "ssh-key", "credential"],
            ))

        # Check history for passwords
        if results.get("history"):
            history = results["history"]
            password_hints = [
                line for line in history.splitlines()
                if any(kw in line.lower() for kw in [
                    "password", "passwd", "mysql -u", "ssh ",
                    "sshpass", "curl -u", "wget --password",
                ])
            ]
            if password_hints:
                findings.append(Finding.high(
                    "Potential credentials in shell history",
                    evidence="\n".join(password_hints[:10]),
                    tags=["post-exploit", "credential", "history"],
                ))

        # Docker/LXD check
        if results.get("docker_check") and "docker" in results["docker_check"].lower():
            findings.append(Finding.high(
                "User is in docker group (container escape possible)",
                evidence=results["docker_check"],
                tags=["post-exploit", "docker", "privesc"],
            ))
            data["privesc_vectors"].append({"type": "docker_group"})

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
