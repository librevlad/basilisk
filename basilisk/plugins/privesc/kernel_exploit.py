"""Kernel exploit — kernel version to CVE matcher for privilege escalation."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Kernel version → CVE database (HTB-relevant)
KERNEL_CVES: list[dict] = [
    {
        "cve": "CVE-2022-0847",
        "name": "DirtyPipe",
        "min_version": (5, 8, 0),
        "max_version": (5, 16, 10),
        "exploit": "https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit",
        "description": "Overwrite read-only files — instant root",
    },
    {
        "cve": "CVE-2021-4034",
        "name": "PwnKit (pkexec)",
        "min_version": (2, 6, 0),
        "max_version": (99, 99, 99),
        "exploit": "https://github.com/berdav/CVE-2021-4034",
        "description": "Polkit pkexec local privilege escalation (all versions)",
        "check_cmd": "pkexec --version 2>/dev/null",
    },
    {
        "cve": "CVE-2021-3156",
        "name": "Baron Samedit (sudo)",
        "min_version": (2, 6, 0),
        "max_version": (99, 99, 99),
        "exploit": "https://github.com/blasty/CVE-2021-3156",
        "description": "Sudo heap overflow — root without password",
        "check_cmd": "sudoedit -s '\\' 2>&1",
    },
    {
        "cve": "CVE-2016-5195",
        "name": "DirtyCOW",
        "min_version": (2, 6, 22),
        "max_version": (4, 8, 2),
        "exploit": "https://github.com/dirtycow/dirtycow.github.io",
        "description": "Race condition in COW — write to read-only memory",
    },
    {
        "cve": "CVE-2022-2588",
        "name": "DirtyCredential",
        "min_version": (5, 0, 0),
        "max_version": (5, 19, 1),
        "exploit": "Use-after-free in route4 — overwrite credentials",
        "description": "UaF in cls_route → replace kernel credential",
    },
    {
        "cve": "CVE-2022-32250",
        "name": "nft_set_elem_init UAF",
        "min_version": (5, 8, 0),
        "max_version": (5, 18, 0),
        "exploit": "https://github.com/theori-io/CVE-2022-32250-exploit",
        "description": "Use-after-free in nftables",
    },
    {
        "cve": "CVE-2023-0386",
        "name": "OverlayFS Unpriv",
        "min_version": (5, 11, 0),
        "max_version": (6, 2, 0),
        "exploit": "https://github.com/xkaneiki/CVE-2023-0386",
        "description": "OverlayFS setuid copy-up bypass",
    },
    {
        "cve": "CVE-2023-32233",
        "name": "nftables UaF",
        "min_version": (5, 0, 0),
        "max_version": (6, 3, 1),
        "exploit": "nf_tables use-after-free → arbitrary r/w",
        "description": "nf_tables batch handling UAF",
    },
    {
        "cve": "CVE-2021-22555",
        "name": "Netfilter Heap OOB",
        "min_version": (2, 6, 19),
        "max_version": (5, 12, 0),
        "exploit": "https://github.com/google/security-research/tree/master/pocs/linux/CVE-2021-22555",
        "description": "Heap out-of-bounds write in Netfilter",
    },
    {
        "cve": "CVE-2017-16995",
        "name": "eBPF Verifier",
        "min_version": (4, 4, 0),
        "max_version": (4, 14, 7),
        "exploit": "eBPF verifier bypass → arbitrary memory r/w",
        "description": "eBPF ALU32 bounds tracking error",
    },
    {
        "cve": "CVE-2019-13272",
        "name": "PTRACE_TRACEME",
        "min_version": (4, 10, 0),
        "max_version": (5, 1, 16),
        "exploit": "https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272",
        "description": "ptrace credentials handling — get root creds",
    },
    {
        "cve": "CVE-2017-7308",
        "name": "AF_PACKET",
        "min_version": (3, 2, 0),
        "max_version": (4, 10, 5),
        "exploit": "Heap OOB in AF_PACKET",
        "description": "af_packet.c ring buffer sanity check bypass",
    },
]

KERNEL_VERSION_RE = re.compile(r"(\d+)\.(\d+)\.(\d+)")


class KernelExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="kernel_exploit",
        display_name="Kernel Exploit Matcher",
        category=PluginCategory.PRIVESC,
        description="Kernel version → CVE matcher (DirtyPipe, DirtyCOW, PwnKit)",
        depends_on=["linux_enum"],
        produces=["privesc_vectors"],
        timeout=30.0,
        requires_http=False,
        requires_shell=True,
        platform="linux",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"kernel_version": "", "matching_cves": []}

        # Get kernel version
        kernel_str = ""
        enum_result = ctx.pipeline.get(f"linux_enum:{target.host}")
        if enum_result and enum_result.ok:
            kernel_str = enum_result.data.get("os_info", "")

        if not kernel_str:
            shells = ctx.state.get("active_shells", [])
            if not shells or not ctx.shell:
                return PluginResult.fail(
                    self.meta.name, target.host, error="No shell session",
                )
            session = (
                ctx.shell.get_session(shells[0]["id"])
                if isinstance(shells[0], dict) else None
            )
            if session:
                kernel_str = await ctx.shell.execute(
                    session, "uname -r 2>/dev/null", timeout=5.0,
                ) or ""

        data["kernel_version"] = kernel_str.strip()

        # Parse version
        match = KERNEL_VERSION_RE.search(kernel_str)
        if not match:
            findings.append(Finding.info(
                f"Could not parse kernel version: {kernel_str[:50]}",
                tags=["privesc", "kernel"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        version = (int(match.group(1)), int(match.group(2)), int(match.group(3)))

        findings.append(Finding.info(
            f"Kernel version: {version[0]}.{version[1]}.{version[2]}",
            evidence=kernel_str.strip(),
            tags=["privesc", "kernel"],
        ))

        # Match against CVE database
        for cve in KERNEL_CVES:
            if cve["min_version"] <= version <= cve["max_version"]:
                data["matching_cves"].append({
                    "cve": cve["cve"],
                    "name": cve["name"],
                    "exploit": cve.get("exploit", ""),
                    "description": cve["description"],
                })
                findings.append(Finding.critical(
                    f"Kernel may be vulnerable to {cve['cve']} ({cve['name']})",
                    evidence=(
                        f"Kernel: {data['kernel_version']}\n"
                        f"Affected: {cve['min_version']} - {cve['max_version']}\n"
                        f"Exploit: {cve.get('exploit', 'N/A')}"
                    ),
                    description=cve["description"],
                    tags=["privesc", "kernel", "cve"],
                ))

        if not data["matching_cves"]:
            findings.append(Finding.info(
                "No known kernel CVEs matched",
                tags=["privesc", "kernel"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
