"""Windows service exploit — unquoted paths, weak permissions, DLL hijack."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)


class WinServiceExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="win_service_exploit",
        display_name="Windows Service Exploitation",
        category=PluginCategory.PRIVESC,
        description="Unquoted service paths, weak service permissions, DLL hijack",
        depends_on=["windows_enum"],
        produces=["privesc_vectors"],
        timeout=60.0,
        requires_http=False,
        requires_shell=True,
        platform="windows",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "unquoted_paths": [], "weak_permissions": [],
            "dll_hijack": [], "modifiable_services": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = (
            ctx.shell.get_session(shells[0]["id"])
            if isinstance(shells[0], dict) else None
        )
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        # 1. Unquoted service paths
        svc_output = await ctx.shell.execute(
            session,
            (
                'wmic service get name,pathname,startmode 2>nul '
                '| findstr /i "auto"'
            ),
            timeout=15.0,
        )
        if svc_output:
            for line in svc_output.splitlines():
                line = line.strip()
                if not line:
                    continue
                # Unquoted path: contains spaces, no quotes, not in system32
                if (
                    " " in line
                    and not line.startswith('"')
                    and "system32" not in line.lower()
                    and "c:\\windows\\" not in line.lower()
                ):
                    data["unquoted_paths"].append(line[:200])

        if data["unquoted_paths"]:
            findings.append(Finding.high(
                f"Unquoted service paths: {len(data['unquoted_paths'])}",
                evidence="\n".join(data["unquoted_paths"][:10]),
                description=(
                    "Unquoted paths with spaces allow placing a malicious "
                    "executable at an intermediate path component"
                ),
                remediation="Quote all service binary paths",
                tags=["privesc", "unquoted-path", "windows"],
            ))

        # 2. Check service permissions with accesschk (if available)
        accesschk = await ctx.shell.execute(
            session,
            'where accesschk64.exe 2>nul || where accesschk.exe 2>nul',
            timeout=5.0,
        )
        if accesschk and accesschk.strip():
            ac_bin = accesschk.strip().splitlines()[0]
            # Check for modifiable services
            ac_output = await ctx.shell.execute(
                session,
                f'"{ac_bin}" /accepteula -uwcqv "Authenticated Users" * 2>nul',
                timeout=15.0,
            )
            if ac_output:
                for line in ac_output.splitlines():
                    stripped = line.strip()
                    if stripped and "RW" in stripped:
                        data["modifiable_services"].append(stripped)

            if data["modifiable_services"]:
                findings.append(Finding.critical(
                    f"Modifiable services: {len(data['modifiable_services'])}",
                    evidence="\n".join(data["modifiable_services"][:10]),
                    description="Service binary or config can be modified for privesc",
                    tags=["privesc", "service-perm", "windows"],
                ))

        # 3. Check for writable service binary directories
        if svc_output:
            checked_dirs = set()
            for line in svc_output.splitlines():
                parts = line.strip().split()
                for part in parts:
                    if ":\\" in part and part not in checked_dirs:
                        # Extract directory
                        dir_path = "\\".join(part.split("\\")[:-1])
                        if (
                            dir_path
                            and "windows" not in dir_path.lower()
                            and dir_path not in checked_dirs
                        ):
                            checked_dirs.add(dir_path)
                            if len(checked_dirs) > 20:
                                break

            for svc_dir in list(checked_dirs)[:20]:
                if ctx.should_stop:
                    break
                check = await ctx.shell.execute(
                    session,
                    f'icacls "{svc_dir}" 2>nul | findstr /i "(F) (M) (W)"',
                    timeout=5.0,
                )
                if check and ("BUILTIN\\Users" in check or "Everyone" in check):
                    data["weak_permissions"].append({
                        "path": svc_dir, "permissions": check.strip()[:200],
                    })

        if data["weak_permissions"]:
            evidence = "\n".join(
                f"{w['path']}: {w['permissions'][:60]}"
                for w in data["weak_permissions"][:10]
            )
            findings.append(Finding.high(
                f"Weak service directory permissions: {len(data['weak_permissions'])}",
                evidence=evidence,
                description="Service directories writable by low-priv users → DLL hijack",
                tags=["privesc", "dll-hijack", "windows"],
            ))

        # 4. Common DLL hijack paths
        dll_paths = [
            r"C:\Temp", r"C:\Windows\Temp",
            r"C:\Users\Public",
        ]
        for dll_path in dll_paths:
            check = await ctx.shell.execute(
                session, f'icacls "{dll_path}" 2>nul | findstr /i "(F) (M) (W)"',
                timeout=5.0,
            )
            if check and check.strip():
                data["dll_hijack"].append(dll_path)

        if not findings:
            findings.append(Finding.info(
                "No exploitable service configurations found",
                tags=["privesc", "windows"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
