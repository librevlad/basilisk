"""Cron exploit â€” writable scripts, PATH injection, wildcard injection."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Binaries vulnerable to wildcard injection in cron
WILDCARD_VULN_BINS = {"tar", "chown", "chmod", "rsync"}


class CronExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="cron_exploit",
        display_name="Cron Job Exploitation",
        category=PluginCategory.PRIVESC,
        description="Writable cron scripts, PATH injection, wildcard injection",
        depends_on=["linux_enum"],
        produces=["privesc_vectors"],
        timeout=60.0,
        requires_http=False,
        requires_shell=True,
        platform="linux",
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "cron_jobs": [], "writable_scripts": [],
            "path_injection": [], "wildcard_injection": [],
        }

        shells = ctx.state.get("active_shells", [])
        if not shells or not ctx.shell:
            return PluginResult.fail(
                self.meta.name, target.host, error="No shell session",
            )

        session = (
            ctx.shell.get_session(shells[0]["id"])
            if isinstance(shells[0], dict) else None
        )
        if not session:
            return PluginResult.fail(
                self.meta.name, target.host, error="Shell session not found",
            )

        # Read system crontab
        crontab = await ctx.shell.execute(
            session, "cat /etc/crontab 2>/dev/null", timeout=5.0,
        )
        cron_jobs = []
        cron_path = ""

        if crontab:
            for line in crontab.splitlines():
                stripped = line.strip()
                if stripped.startswith("PATH="):
                    cron_path = stripped.split("=", 1)[1]
                elif stripped and not stripped.startswith("#"):
                    cron_jobs.append(stripped)

        # Read cron directories
        for cron_dir in [
            "/etc/cron.d", "/etc/cron.daily", "/etc/cron.hourly",
            "/etc/cron.weekly", "/etc/cron.monthly",
        ]:
            ls_output = await ctx.shell.execute(
                session, f"ls -la {cron_dir}/ 2>/dev/null", timeout=5.0,
            )
            if ls_output:
                for line in ls_output.splitlines():
                    if line.strip() and not line.startswith("total"):
                        cron_jobs.append(f"[{cron_dir}] {line.strip()}")

        data["cron_jobs"] = cron_jobs[:50]

        # Extract scripts from cron entries and check writability
        scripts = set()
        for job in cron_jobs:
            parts = job.split()
            # crontab format: min hour dom month dow user command
            if len(parts) >= 7 and parts[0][0].isdigit() or parts[0] == "*":
                cmd_parts = parts[6:]
                for part in cmd_parts:
                    if part.startswith("/"):
                        scripts.add(part)
                        break

        for script in scripts:
            if ctx.should_stop:
                break
            # Check if writable
            check = await ctx.shell.execute(
                session, f"test -w {script} && echo WRITABLE", timeout=3.0,
            )
            if check and "WRITABLE" in check:
                data["writable_scripts"].append(script)

        if data["writable_scripts"]:
            findings.append(Finding.critical(
                f"Writable cron scripts: {len(data['writable_scripts'])}",
                evidence="\n".join(data["writable_scripts"][:10]),
                description=(
                    "These scripts run as root via cron and are writable. "
                    "Inject a reverse shell or add your user to sudoers."
                ),
                tags=["privesc", "cron", "writable"],
            ))

        # PATH injection: check if cron PATH has writable directories
        if cron_path:
            for path_dir in cron_path.split(":"):
                if ctx.should_stop:
                    break
                check = await ctx.shell.execute(
                    session, f"test -w {path_dir} && echo WRITABLE", timeout=3.0,
                )
                if check and "WRITABLE" in check:
                    data["path_injection"].append(path_dir)

            if data["path_injection"]:
                findings.append(Finding.critical(
                    f"Cron PATH injection: {len(data['path_injection'])} writable dirs",
                    evidence=(
                        f"PATH={cron_path}\n"
                        f"Writable: {', '.join(data['path_injection'])}"
                    ),
                    description=(
                        "Create a malicious binary in the writable PATH dir "
                        "with the same name as a command used in a cron job"
                    ),
                    tags=["privesc", "cron", "path-injection"],
                ))

        # Wildcard injection check
        for job in cron_jobs:
            for vuln_bin in WILDCARD_VULN_BINS:
                if vuln_bin in job and "*" in job:
                    data["wildcard_injection"].append({
                        "job": job, "binary": vuln_bin,
                    })

        if data["wildcard_injection"]:
            evidence_lines = [
                f"{w['binary']} in: {w['job'][:80]}"
                for w in data["wildcard_injection"][:5]
            ]
            findings.append(Finding.high(
                f"Cron wildcard injection: {len(data['wildcard_injection'])}",
                evidence="\n".join(evidence_lines),
                description=(
                    "Cron jobs using wildcards with tar/chown/chmod/rsync "
                    "can be exploited via crafted filenames"
                ),
                tags=["privesc", "cron", "wildcard"],
            ))

        if not findings:
            findings.append(Finding.info(
                "No exploitable cron configurations found",
                tags=["privesc", "cron"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
