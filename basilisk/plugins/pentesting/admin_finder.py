"""Admin panel finder — discovers administrative interfaces, login pages, DB tools.

200+ paths organized by technology, default credential detection,
login form analysis, HTTP auth detection, robots.txt hidden paths.
"""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

# ── Admin paths organized by category ──────────────────────────────────
ADMIN_PATHS = [
    # Generic admin
    "/admin", "/admin/", "/administrator", "/administrator/",
    "/admin/login", "/admin.php", "/admin/index.php",
    "/admin/dashboard", "/admin/config", "/admin/settings",
    "/panel", "/panel/", "/cpanel", "/cpanel/",
    "/webadmin", "/webadmin/", "/sysadmin",
    "/dashboard", "/dashboard/", "/control",
    "/manage", "/management", "/manager", "/manager/",
    "/backend", "/backoffice", "/back-office",
    "/controlpanel", "/admincp", "/modcp",
    "/_admin", "/admin_area", "/adminpanel",
    "/siteadmin", "/site-admin", "/admin-console",
    "/cms", "/cms/admin", "/cms/login",
    "/secure", "/secure/admin",
    "/internal", "/internal/admin",
    "/console", "/console/", "/web-console",
    # Auth pages
    "/login", "/login/", "/signin", "/sign-in",
    "/auth", "/auth/login", "/auth/signin",
    "/user/login", "/account/login",
    "/accounts/login", "/members/login",
    "/portal", "/portal/login",
    "/sso/login", "/oauth/login",
    # WordPress
    "/wp-admin", "/wp-admin/", "/wp-login.php",
    "/wp-admin/install.php", "/wp-admin/setup-config.php",
    "/wp-admin/upgrade.php",
    # Joomla
    "/administrator/index.php", "/administrator/manifests/",
    # Drupal
    "/user", "/user/login", "/admin/config/system",
    # 1C-Bitrix
    "/bitrix/admin", "/bitrix/admin/", "/bitrix/admin/index.php",
    # MODX
    "/modx/", "/modx/manager/", "/manager/",
    # Magento
    "/admin_12345/", "/magento/admin/", "/index.php/admin",
    # Laravel
    "/nova", "/nova/login", "/horizon", "/horizon/dashboard",
    "/telescope", "/log-viewer",
    # Django
    "/admin/login/?next=/admin/", "/djadmin/", "/dj-admin/",
    # PHP frameworks
    "/laravel/", "/symfony/", "/yii/", "/codeigniter/admin",
    # Database tools
    "/phpmyadmin", "/phpmyadmin/", "/pma", "/pma/",
    "/adminer", "/adminer.php", "/adminer.php.bak",
    "/dbadmin", "/mysqladmin", "/pgadmin", "/pgadmin4/",
    "/phpPgAdmin", "/phpRedisAdmin",
    "/redis-commander", "/mongo-express",
    # CMS-specific
    "/ghost/", "/ghost/signin",
    "/strapi/", "/strapi/admin",
    "/keystone/", "/directus/admin",
    "/cockpit/", "/craft/admin",
    "/typo3/", "/typo3/login",
    "/umbraco/", "/umbraco/login",
    "/sitefinity/", "/sitecore/admin",
    "/episerver/", "/kentico/admin",
    "/prestashop/admin/", "/opencart/admin/",
    "/mediawiki/Special:UserLogin",
    # Java / Spring
    "/actuator", "/actuator/health", "/actuator/info",
    "/actuator/env", "/actuator/heapdump",
    "/actuator/configprops", "/actuator/mappings",
    "/jolokia", "/jolokia/read",
    "/spring/admin", "/spring-admin",
    # Node.js / Express
    "/api/admin", "/api/v1/admin", "/api/v2/admin",
    "/graphql/admin", "/admin/api",
    # CI/CD & DevOps
    "/jenkins", "/jenkins/login",
    "/gitlab", "/gitlab/users/sign_in",
    "/grafana", "/grafana/login",
    "/kibana", "/kibana/app",
    "/prometheus", "/prometheus/graph",
    "/portainer", "/rancher",
    "/sonarqube", "/nexus",
    "/traefik", "/traefik/dashboard/",
    "/consul", "/consul/ui",
    "/vault/", "/vault/ui/",
    # Mail
    "/webmail", "/roundcube", "/horde",
    "/owa", "/owa/auth/logon.aspx",
    "/mail", "/mail/login",
    # Monitoring
    "/munin", "/cacti", "/nagios",
    "/zabbix", "/zabbix/index.php",
    "/prtg", "/checkmk",
    "/netdata/", "/monit",
    # Server management
    "/plesk", "/plesk/login",
    "/ispconfig", "/directadmin",
    "/cyberpanel", "/cwp",
    "/vestacp", "/hestiacp",
    "/virtualmin", "/webmin",
    "/cloudpanel",
    # API docs (may expose internal APIs)
    "/swagger", "/swagger-ui", "/swagger-ui.html",
    "/api-docs", "/api/docs", "/redoc",
    "/graphiql", "/graphql/playground",
    "/.well-known/openapi.json",
    # Debug / development
    "/debug", "/debug/", "/debug/default/view",
    "/phpinfo.php", "/info.php", "/test.php",
    "/_profiler", "/_debugbar",
    "/elmah.axd", "/trace.axd",
    # Server status
    "/server-status", "/server-info",
    "/.well-known/", "/status", "/health",
    "/nginx_status", "/stub_status",
]

# Login form indicators
LOGIN_KEYWORDS = [
    "password", "login", "sign in", "log in",
    "авторизация", "вход", "пароль",
    "authenticate", "credentials",
]

ADMIN_CONTENT_KEYWORDS = [
    "admin", "dashboard", "panel", "management",
    "console", "configuration", "settings",
]

# Default credentials for common platforms
DEFAULT_CREDS: dict[str, list[tuple[str, str]]] = {
    "tomcat": [("tomcat", "s3cret"), ("tomcat", "tomcat"), ("admin", "admin")],
    "jenkins": [("admin", "admin"), ("admin", "password")],
    "grafana": [("admin", "admin"), ("admin", "grafana")],
    "gitlab": [("root", "5iveL!fe"), ("admin", "admin")],
    "rabbitmq": [("guest", "guest")],
    "elasticsearch": [("elastic", "changeme")],
}


class AdminFinderPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="admin_finder",
        display_name="Admin Panel Finder",
        category=PluginCategory.PENTESTING,
        description=(
            "Discovers admin panels, login pages, DB tools, DevOps dashboards "
            f"({len(ADMIN_PATHS)} paths, technology-specific)"
        ),
        produces=["admin_panels"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        found: list[dict] = []

        base_urls = await resolve_base_urls(target, ctx)
        if not base_urls:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"admin_panels": []},
            )

        for base_url in base_urls:
            if ctx.should_stop:
                break

            # Fetch baselines
            spa_baseline = ""
            homepage_body = ""
            try:
                async with ctx.rate:
                    r = await ctx.http.get(
                        f"{base_url}/_nonexistent_8x7z_admin/", timeout=5.0,
                    )
                    if r.status == 200:
                        spa_baseline = await r.text(
                            encoding="utf-8", errors="replace",
                        )
            except Exception:
                pass

            try:
                async with ctx.rate:
                    r = await ctx.http.get(f"{base_url}/", timeout=5.0)
                    if r.status == 200:
                        homepage_body = await r.text(
                            encoding="utf-8", errors="replace",
                        )
            except Exception:
                pass

            # Check robots.txt for hidden admin paths
            robot_paths = await self._parse_robots(base_url, ctx)

            # Combine paths
            all_paths = list(ADMIN_PATHS)
            for rp in robot_paths:
                if rp not in all_paths:
                    all_paths.append(rp)

            for path in all_paths:
                if ctx.should_stop:
                    break
                url = f"{base_url}{path}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=5.0)
                        if resp.status not in (200, 301, 302, 401, 403):
                            continue

                        body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )

                        if resp.status == 200:
                            if self._is_same_page(body, spa_baseline):
                                continue
                            if self._is_same_page(body, homepage_body):
                                continue

                        body_lower = body.lower()

                        # HTTP Basic/Digest auth (401)
                        if resp.status == 401:
                            www_auth = resp.headers.get("WWW-Authenticate", "")
                            found.append({
                                "path": path, "status": 401,
                                "auth_type": "http_auth",
                            })
                            findings.append(Finding.medium(
                                f"HTTP auth protected: {path}",
                                description=f"HTTP authentication: {www_auth[:80]}",
                                evidence=url,
                                remediation="Ensure strong credentials and rate limiting",
                                tags=["pentesting", "admin", "http-auth"],
                            ))
                            continue

                        # 403 Forbidden but exists
                        if resp.status == 403:
                            found.append({
                                "path": path, "status": 403,
                                "has_login": False,
                            })
                            findings.append(Finding.low(
                                f"Admin path exists (403): {path}",
                                evidence=url,
                                tags=["pentesting", "admin"],
                            ))
                            continue

                        # Login form detection — STRICT validation
                        has_form = "<form" in body_lower
                        # Require form action/method to look admin-related
                        has_admin_form = has_form and any(
                            kw in body_lower
                            for kw in (
                                'action="', "action='",
                                'method="post"', "method='post'",
                            )
                        ) and any(
                            kw in body_lower
                            for kw in (
                                'type="password"', "type='password'",
                                'type=password',
                            )
                        )
                        has_admin = any(
                            kw in body_lower for kw in ADMIN_CONTENT_KEYWORDS
                        )

                        if has_admin_form:
                            found.append({
                                "path": path, "status": resp.status,
                                "has_login": True,
                            })
                            findings.append(Finding.medium(
                                f"Admin login page: {path}",
                                description="Admin login form with password field",
                                evidence=url,
                                remediation=(
                                    "Restrict admin access by IP, add 2FA, "
                                    "use rate limiting"
                                ),
                                tags=["pentesting", "admin", "login"],
                            ))
                        elif resp.status == 200 and has_admin and has_form:
                            found.append({
                                "path": path, "status": resp.status,
                                "has_login": False,
                            })
                            findings.append(Finding.low(
                                f"Admin path accessible: {path}",
                                evidence=f"{url} -> {resp.status}",
                                tags=["pentesting", "admin"],
                            ))

                        # Redirect to login
                        if resp.status in (301, 302):
                            location = resp.headers.get("Location", "")
                            if any(kw in location.lower() for kw in ("login", "auth", "signin")):
                                found.append({
                                    "path": path, "status": resp.status,
                                    "redirect_to": location,
                                })
                                findings.append(Finding.low(
                                    f"Admin redirect to login: {path}",
                                    description=f"Redirects to {location}",
                                    evidence=url,
                                    tags=["pentesting", "admin"],
                                ))

                except Exception:
                    continue

        # Store admin paths in state for credential_spray
        ctx.state.setdefault("admin_paths", []).extend(found)

        if not findings:
            findings.append(Finding.info(
                f"No admin panels found ({len(ADMIN_PATHS)} paths checked)",
                tags=["pentesting", "admin"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"admin_panels": found, "paths_checked": len(ADMIN_PATHS)},
        )

    async def _parse_robots(self, base_url: str, ctx) -> list[str]:
        """Extract disallowed paths from robots.txt that look admin-related."""
        paths: list[str] = []
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/robots.txt", timeout=5.0)
                if resp.status == 200:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    for line in body.splitlines():
                        line = line.strip().lower()
                        if line.startswith("disallow:"):
                            path = line.split(":", 1)[1].strip()
                            if path and any(
                                kw in path.lower()
                                for kw in ("admin", "login", "panel", "manage",
                                           "dashboard", "config", "private",
                                           "internal", "secret")
                            ):
                                if not path.startswith("/"):
                                    path = "/" + path
                                paths.append(path)
        except Exception:
            pass
        return paths[:20]

    @staticmethod
    def _is_same_page(body: str, reference: str) -> bool:
        """Check if body is essentially the same page as reference (soft-404)."""
        if not reference:
            return False
        if abs(len(body) - len(reference)) > 200:
            return False
        return body[:500] == reference[:500]
