"""Reflected XSS detection — context-aware, multi-injection-point, WAF bypass.

Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion,
ResponseDiffer for reflection detection. Context detection: HTML/attribute/JS/URL.
Level: dalfox-lite (detection with context awareness).
"""

from __future__ import annotations

import re
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

XSS_CANARY = "basilisk7x3s"

# Reflection context detection patterns
_CTX_HTML_TAG = re.compile(r"<[^>]*basilisk7x3s[^>]*>", re.IGNORECASE)
_CTX_HTML_ATTR = re.compile(
    r'(?:value|href|src|action|data)\s*=\s*["\'][^"\']*basilisk7x3s', re.IGNORECASE,
)
_CTX_JS_STRING = re.compile(
    r"(?:var\s+\w+|['\"])\s*[=:]\s*['\"][^'\"]*basilisk7x3s", re.IGNORECASE,
)
_CTX_URL = re.compile(r"(?:href|src|action)\s*=\s*[\"']?[^\"']*basilisk7x3s", re.IGNORECASE)

# DOM XSS dangerous sinks
DOM_SINKS = [
    "document.write(", "document.writeln(", ".innerHTML",
    "eval(", "setTimeout(", "setInterval(", "Function(",
    ".outerHTML", "document.location", "window.location",
    "document.URL", "document.documentURI", "document.referrer",
    "location.href", "location.search", "location.hash",
    ".insertAdjacentHTML(",
]

# Params commonly reflecting input
XSS_PARAMS = [
    "q", "search", "query", "s", "keyword", "name", "redirect",
    "url", "next", "return", "callback", "message", "error",
    "text", "title", "content", "value", "input", "data",
]

# Headers that sometimes reflect
XSS_HEADERS = [
    ("User-Agent", f"Mozilla/5.0 <{XSS_CANARY}>"),
    ("Referer", f"http://example.com/<{XSS_CANARY}>"),
]


class XssBasicPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="xss_basic",
        display_name="XSS Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects reflected XSS with context-aware analysis, "
            "header injection, DOM sink hints, and WAF bypass"
        ),
        produces=["xss_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"xss_tests": []},
            )

        # Get payloads from PayloadEngine or use defaults
        payloads = self._get_payloads(ctx)
        scan_paths = ["/"]
        extra = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths.extend(p for p in extra if p not in scan_paths)

        # ── Phase 1: Reflection probe (canary) ───────────────────────
        reflecting_points: list[tuple[str, str, str]] = []  # (path, param, context)
        for path in scan_paths[:5]:
            if ctx.should_stop:
                break
            for param in XSS_PARAMS[:12]:
                if ctx.should_stop:
                    break
                url = f"{base_url}{path}?{param}={XSS_CANARY}"
                body = await self._fetch(ctx, url)
                if body is None or XSS_CANARY not in body:
                    continue

                context = self._detect_context(body)
                reflecting_points.append((path, param, context))
                tested.append({"path": path, "param": param, "context": context})

                if len(reflecting_points) >= 6:
                    break
            if len(reflecting_points) >= 6:
                break

        # ── Phase 2: Payload injection on reflecting params ──────────
        for path, param, context in reflecting_points:
            if ctx.should_stop or len(findings) >= 3:
                break

            # Pick context-appropriate payloads
            context_payloads = self._select_for_context(payloads, context)

            for raw_payload in context_payloads:
                if ctx.should_stop:
                    break
                variants = self._get_variants(ctx, raw_payload)
                for variant in variants:
                    url = f"{base_url}{path}?{param}={quote(variant)}"
                    body = await self._fetch(ctx, url)
                    if body is None:
                        continue

                    reflected_raw = variant in body
                    # Check if payload was HTML-encoded (entities = not vuln)
                    html_encoded = (
                        "&lt;" in body
                        and variant.replace("<", "&lt;") in body
                    )
                    if html_encoded:
                        continue

                    # Check for HTML-significant reflection (tags/events not encoded)
                    tag_reflected = bool(re.search(
                        r"<\s*(img|svg|script|iframe|details|body|input|"
                        r"video|marquee|object|a|div|embed)\b[^>]*"
                        r"(onerror|onload|onfocus|onmouseover|onclick|"
                        r"ontoggle|onbegin|onstart)\s*=",
                        body, re.IGNORECASE,
                    )) and XSS_CANARY in body

                    if tag_reflected:
                        # Context-aware severity
                        sev = Finding.high
                        if "script" in body.lower() and XSS_CANARY in body:
                            sev = Finding.critical
                        findings.append(sev(
                            f"Reflected XSS: HTML event handler via {path}?{param}=",
                            description=(
                                f"Event handler payload reflected in {context} context. "
                                f"Payload: {raw_payload[:80]}"
                            ),
                            evidence=f"URL: {url}\nPayload: {raw_payload[:80]}",
                            remediation="Encode all user input with context-aware encoding",
                            tags=["pentesting", "xss", context],
                        ))
                        break
                    elif reflected_raw and "<" in variant and "<" in body:
                        # Check if angle brackets survived
                        test_tag = f"<{XSS_CANARY}>"
                        if test_tag in body:
                            findings.append(Finding.high(
                                f"Reflected XSS: tag injection via {path}?{param}=",
                                description=(
                                    f"HTML tags reflected without encoding in "
                                    f"{context} context"
                                ),
                                evidence=(
                                    f"URL: {url}\n"
                                    f"Payload: {raw_payload[:80]}"
                                ),
                                remediation="Encode all user input in HTML output",
                                tags=["pentesting", "xss", context],
                            ))
                            break
                    elif reflected_raw:
                        findings.append(Finding.medium(
                            f"Input reflected ({context}): {path}?{param}=",
                            description=(
                                f"User input reflected in {context} context "
                                f"(potential XSS)"
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Payload: {raw_payload[:60]}"
                            ),
                            remediation="Apply context-aware output encoding",
                            tags=["pentesting", "xss", context],
                        ))
                        break

        # ── Phase 3: Header reflection check ─────────────────────────
        if not findings and not ctx.should_stop:
            for hdr_name, hdr_payload in XSS_HEADERS:
                body = await self._fetch_with_header(ctx, base_url, hdr_name, hdr_payload)
                if body and XSS_CANARY in body:
                    tag_in = f"<{XSS_CANARY}>" in body
                    severity = Finding.high if tag_in else Finding.medium
                    findings.append(severity(
                        f"XSS via {hdr_name} header reflection",
                        description=f"{hdr_name} value reflected in response body",
                        evidence=f"Header: {hdr_name}: {hdr_payload}",
                        remediation="Never reflect HTTP headers in response body",
                        tags=["pentesting", "xss", "header"],
                    ))
                    break

        # ── Phase 4: DOM XSS sink detection ──────────────────────────
        if not ctx.should_stop:
            body = await self._fetch(ctx, base_url)
            if body:
                sinks_found = [s for s in DOM_SINKS if s.lower() in body.lower()]
                if sinks_found:
                    findings.append(Finding.low(
                        f"DOM XSS sinks detected: {len(sinks_found)} dangerous patterns",
                        description="JavaScript contains DOM manipulation patterns",
                        evidence=", ".join(sinks_found[:8]),
                        remediation="Review DOM manipulation code for XSS vulnerabilities",
                        tags=["pentesting", "xss", "dom"],
                    ))

        # ── Phase 5: CSP check ───────────────────────────────────────
        if not ctx.should_stop:
            csp_issue = await self._check_csp(ctx, base_url)
            if csp_issue:
                findings.append(csp_issue)

        if not findings:
            findings.append(Finding.info(
                "No reflected XSS detected", tags=["pentesting", "xss"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"xss_tests": tested, "reflecting_points": len(reflecting_points)},
        )

    # ── Payload helpers ───────────────────────────────────────────────

    @staticmethod
    def _get_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.XSS, max_waf=1, limit=25)
            return [p.value for p in payloads]
        return [
            f"<{XSS_CANARY}>", f"<img src=x onerror=alert({XSS_CANARY})>",
            f"<svg onload=alert({XSS_CANARY})>",
            f"<script>{XSS_CANARY}</script>",
            f"\" onmouseover=\"alert({XSS_CANARY})",
            f"'-alert({XSS_CANARY})-'",
            f"<input onfocus=alert({XSS_CANARY}) autofocus>",
        ]

    @staticmethod
    def _select_for_context(payloads: list[str], context: str) -> list[str]:
        """Prioritize payloads for detected context."""
        if context == "html_attr":
            # Prioritize attribute-breaking payloads
            attr_first = [p for p in payloads if '"' in p[:3] or "'" in p[:3]]
            rest = [p for p in payloads if p not in attr_first]
            return (attr_first + rest)[:15]
        elif context == "js_string":
            js_first = [p for p in payloads if "'-" in p or '"-' in p or "script>" in p]
            rest = [p for p in payloads if p not in js_first]
            return (js_first + rest)[:15]
        return payloads[:15]

    @staticmethod
    def _get_variants(ctx, payload: str) -> list[str]:
        variants = [payload]
        if hasattr(ctx, "waf_bypass") and ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            encoded = ctx.waf_bypass.encode(payload)
            for v in encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:3]

    @staticmethod
    def _detect_context(body: str) -> str:
        """Detect reflection context from response body."""
        if _CTX_JS_STRING.search(body):
            return "js_string"
        if _CTX_HTML_ATTR.search(body):
            return "html_attr"
        if _CTX_HTML_TAG.search(body):
            return "html_tag"
        if _CTX_URL.search(body):
            return "url"
        return "html_body"

    # ── Network helpers ───────────────────────────────────────────────

    async def _fetch(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return None

    async def _fetch_with_header(
        self, ctx, base_url: str, hdr: str, val: str,
    ) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url, headers={hdr: val}, timeout=8.0,
                )
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return None

    async def _check_csp(self, ctx, base_url: str) -> Finding | None:
        """Check if CSP is missing or allows inline scripts."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(base_url, timeout=5.0)
                csp = resp.headers.get("Content-Security-Policy", "")
                if not csp:
                    return Finding.low(
                        "No Content-Security-Policy header",
                        description="Missing CSP allows unrestricted script execution",
                        remediation="Add CSP header with script-src directive",
                        tags=["pentesting", "xss", "csp"],
                    )
                if "'unsafe-inline'" in csp and "script-src" in csp:
                    return Finding.low(
                        "CSP allows unsafe-inline scripts",
                        description="CSP script-src includes 'unsafe-inline'",
                        evidence=f"CSP: {csp[:200]}",
                        remediation="Remove unsafe-inline and use nonces or hashes",
                        tags=["pentesting", "xss", "csp"],
                    )
        except Exception:
            pass
        return None
