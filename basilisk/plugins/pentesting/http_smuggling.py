"""HTTP request smuggling detection — CL.TE, TE.CL, TE.TE, H2 downgrade.

20+ Transfer-Encoding obfuscation variants (James Kettle research),
timing-based detection with confirmation, H2.CL indicators.
"""

from __future__ import annotations

import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# 20+ TE obfuscation variants from James Kettle's research
TE_OBFUSCATIONS = [
    # Spacing / case variations
    "xchunked",
    " chunked",
    "chunked ",
    "\tchunked",
    "chunked\t",
    " \tchunked",
    "CHUNKED",
    "Chunked",
    "cHuNkEd",
    # Header value mutations
    "identity",
    "chunked, identity",
    "identity, chunked",
    "chunked;q=1.0",
    "chunked;ext=value",
    # Line folding / injection
    "chunked\r\nX-Ignore: x",
    "chunked\r\n Transfer-Encoding: identity",
    # Double header
    "chunked\r\nTransfer-Encoding: identity",
    # Null byte
    "chunked\x00",
    # UTF-8 space variants
    "chunked\xc0\xa0",
    # Vertical tab / form feed
    "chunked\x0b",
    "chunked\x0c",
]

# Common CDN/proxy combos that may desync
KNOWN_DESYNC_STACKS = {
    "cloudflare + nginx": ["cloudflare", "nginx"],
    "aws alb + gunicorn": ["amazons3", "gunicorn"],
    "akamai + apache": ["akamai", "apache"],
    "cloudfront + express": ["cloudfront", "express"],
}


class HttpSmugglingPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="http_smuggling",
        display_name="HTTP Smuggling Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects HTTP request smuggling: CL.TE, TE.CL, TE.TE with "
            f"{len(TE_OBFUSCATIONS)} TE obfuscations, H2.CL indicators"
        ),
        produces=["smuggling_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="Host not reachable via HTTP(S)",
            )

        findings: list[Finding] = []
        details: list[dict] = []

        baseline = await self._get_baseline(base_url, ctx)
        if baseline is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="Could not establish baseline response",
            )

        # Phase 1: CL.TE detection
        if not ctx.should_stop:
            await self._check_cl_te(base_url, ctx, baseline, findings, details)

        # Phase 2: TE.CL detection (20+ variants)
        if not ctx.should_stop:
            await self._check_te_cl(base_url, ctx, baseline, findings, details)

        # Phase 3: TE.TE detection (conflicting TE headers)
        if not ctx.should_stop:
            await self._check_te_te(base_url, ctx, baseline, findings, details)

        # Phase 4: Duplicate Content-Length
        if not ctx.should_stop:
            await self._check_duplicate_cl(base_url, ctx, baseline, findings, details)

        # Phase 5: Transfer-Encoding: identity
        if not ctx.should_stop:
            await self._check_te_identity(base_url, ctx, baseline, findings, details)

        # Phase 6: H2 downgrade indicators
        if not ctx.should_stop:
            await self._check_h2_downgrade(base_url, ctx, findings, details)

        # Phase 7: Method override
        if not ctx.should_stop:
            await self._check_method_override(base_url, ctx, baseline, findings, details)

        if not findings:
            findings.append(Finding.info(
                "No HTTP smuggling indicators detected",
                tags=["pentesting", "smuggling"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "smuggling_findings": details,
                "baseline_status": baseline["status"],
                "baseline_time": round(baseline["time"], 3),
                "server": baseline["server"],
            },
        )

    async def _get_baseline(self, base_url: str, ctx) -> dict | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                resp = await ctx.http.get(base_url + "/", timeout=10.0)
                elapsed = time.monotonic() - start
                return {
                    "status": resp.status,
                    "time": elapsed,
                    "server": resp.headers.get("server", ""),
                    "via": resp.headers.get("via", ""),
                }
        except Exception:
            return None

    async def _check_cl_te(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """CL.TE: Both Content-Length and Transfer-Encoding: chunked."""
        headers = {
            "Content-Length": "6",
            "Transfer-Encoding": "chunked",
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            async with ctx.rate:
                start = time.monotonic()
                resp = await ctx.http.get(
                    base_url + "/", headers=headers, timeout=10.0,
                )
                elapsed = time.monotonic() - start
                status = resp.status

            status_diff = status != baseline["status"]
            slow = elapsed > baseline["time"] * 3 and elapsed > 3.0

            if status_diff and slow:
                findings.append(Finding.high(
                    "CL.TE smuggling indicator detected",
                    description=(
                        "Inconsistent behavior with Content-Length + "
                        "Transfer-Encoding: chunked"
                    ),
                    evidence=(
                        f"Baseline: {baseline['status']} in {baseline['time']:.2f}s; "
                        f"CL.TE probe: {status} in {elapsed:.2f}s"
                    ),
                    remediation=(
                        "Reject requests with both Content-Length and "
                        "Transfer-Encoding headers"
                    ),
                    tags=["pentesting", "smuggling", "cl.te"],
                ))
                details.append({
                    "type": "CL.TE", "status": status,
                    "time": round(elapsed, 3),
                })
        except TimeoutError:
            findings.append(Finding.high(
                "CL.TE smuggling indicator: request timeout",
                description="CL+TE headers caused timeout",
                evidence="Request with CL+TE caused timeout",
                remediation="Reject requests with ambiguous CL/TE",
                tags=["pentesting", "smuggling", "cl.te"],
            ))
            details.append({"type": "CL.TE", "result": "timeout"})
        except Exception:
            pass

    async def _check_te_cl(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """TE.CL: Obfuscated Transfer-Encoding headers."""
        for variant in TE_OBFUSCATIONS:
            if ctx.should_stop:
                break
            headers = {
                "Transfer-Encoding": variant,
                "Content-Length": "0",
                "Content-Type": "application/x-www-form-urlencoded",
            }
            try:
                async with ctx.rate:
                    start = time.monotonic()
                    resp = await ctx.http.get(
                        base_url + "/", headers=headers, timeout=10.0,
                    )
                    elapsed = time.monotonic() - start
                    status = resp.status

                status_diff = status != baseline["status"]
                slow = elapsed > baseline["time"] * 3 and elapsed > 3.0

                if status_diff and slow:
                    safe_variant = variant.strip().replace("\r\n", "\\r\\n")
                    findings.append(Finding.high(
                        f"TE.CL smuggling indicator: '{safe_variant}'",
                        description=(
                            f"Obfuscated TE header '{safe_variant}' caused "
                            "inconsistent behavior"
                        ),
                        evidence=(
                            f"Variant: '{safe_variant}': status={status} "
                            f"in {elapsed:.2f}s "
                            f"(baseline: {baseline['status']} in "
                            f"{baseline['time']:.2f}s)"
                        ),
                        remediation=(
                            "Normalize Transfer-Encoding parsing or "
                            "reject ambiguous TE values"
                        ),
                        tags=["pentesting", "smuggling", "te.cl"],
                    ))
                    details.append({
                        "type": "TE.CL", "variant": safe_variant,
                        "status": status, "time": round(elapsed, 3),
                    })
                    break
            except TimeoutError:
                safe_variant = variant.strip().replace("\r\n", "\\r\\n")
                findings.append(Finding.high(
                    f"TE.CL smuggling indicator: '{safe_variant}' timeout",
                    description=f"TE variant '{safe_variant}' caused timeout",
                    evidence=f"TE variant '{safe_variant}' timeout",
                    remediation="Reject ambiguous TE values",
                    tags=["pentesting", "smuggling", "te.cl"],
                ))
                details.append({
                    "type": "TE.CL", "variant": safe_variant, "result": "timeout",
                })
                break
            except Exception:
                continue

    async def _check_te_te(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """TE.TE: Conflicting Transfer-Encoding values."""
        # Test if server handles multiple TE values
        headers = {
            "Transfer-Encoding": "chunked, identity",
            "Content-Length": "0",
        }
        try:
            async with ctx.rate:
                start = time.monotonic()
                resp = await ctx.http.get(
                    base_url + "/", headers=headers, timeout=10.0,
                )
                elapsed = time.monotonic() - start

            if resp.status != baseline["status"] and elapsed > baseline["time"] * 2:
                findings.append(Finding.medium(
                    "TE.TE smuggling indicator: conflicting TE values",
                    description="Multiple Transfer-Encoding values processed differently",
                    evidence=(
                        f"TE: 'chunked, identity': status={resp.status} "
                        f"in {elapsed:.2f}s"
                    ),
                    remediation="Accept only a single Transfer-Encoding value",
                    tags=["pentesting", "smuggling", "te.te"],
                ))
                details.append({
                    "type": "TE.TE", "status": resp.status,
                    "time": round(elapsed, 3),
                })
        except Exception:
            pass

    async def _check_duplicate_cl(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """Check duplicate Content-Length handling."""
        headers = {
            "Content-Length": "0",
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/", headers=headers, timeout=10.0,
                )
            if resp.status == 400 and baseline["status"] != 400:
                details.append({
                    "type": "duplicate_cl", "result": "strict_validation",
                })
        except Exception:
            pass

    async def _check_te_identity(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """Check Transfer-Encoding: identity (deprecated)."""
        headers = {
            "Transfer-Encoding": "identity",
            "Content-Length": "0",
        }
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/", headers=headers, timeout=10.0,
                )
            if resp.status == baseline["status"]:
                findings.append(Finding.low(
                    "Server accepts Transfer-Encoding: identity",
                    description=(
                        "Deprecated 'identity' TE accepted — potential "
                        "desync with proxies that reject it"
                    ),
                    evidence=f"TE: identity returned status {resp.status}",
                    remediation="Reject deprecated 'identity' TE value",
                    tags=["pentesting", "smuggling", "te.identity"],
                ))
                details.append({
                    "type": "TE.identity", "status": resp.status, "accepted": True,
                })
        except Exception:
            pass

    async def _check_h2_downgrade(
        self, base_url: str, ctx,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """Check HTTP/2 downgrade smuggling indicators."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/",
                    headers={"Connection": "Upgrade, HTTP2-Settings"},
                    timeout=10.0,
                )
                upgrade = resp.headers.get("upgrade", "").lower()
                alt_svc = resp.headers.get("alt-svc", "").lower()

            h2_upgrade = "h2" in upgrade or "h2c" in upgrade
            h2_alt_svc = "h2" in alt_svc

            if h2_upgrade or h2_alt_svc:
                indicators = []
                if h2_upgrade:
                    indicators.append(f"Upgrade: {resp.headers.get('upgrade', '')}")
                if h2_alt_svc:
                    indicators.append(f"Alt-Svc: {resp.headers.get('alt-svc', '')}")

                findings.append(Finding.info(
                    "HTTP/2 advertised (H2.CL downgrade possible)",
                    description=(
                        "H2 support alongside H1.1 — H2.CL risk if "
                        "reverse proxy downgrades protocol"
                    ),
                    evidence="; ".join(indicators),
                    remediation=(
                        "Ensure consistent HTTP version handling between "
                        "proxy and backend"
                    ),
                    tags=["pentesting", "smuggling", "h2.cl"],
                ))
                details.append({
                    "type": "H2.CL", "upgrade": h2_upgrade, "alt_svc": h2_alt_svc,
                })
        except Exception:
            pass

    async def _check_method_override(
        self, base_url: str, ctx, baseline: dict,
        findings: list[Finding], details: list[dict],
    ) -> None:
        """Check X-HTTP-Method-Override for smuggling potential."""
        override_headers = [
            "X-HTTP-Method-Override",
            "X-HTTP-Method",
            "X-Method-Override",
        ]
        for hdr in override_headers:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        base_url + "/",
                        headers={hdr: "POST"},
                        timeout=8.0,
                    )
                if resp.status != baseline["status"]:
                    findings.append(Finding.medium(
                        f"Method override accepted via {hdr}",
                        description=(
                            f"Header {hdr}: POST changed response from "
                            f"{baseline['status']} to {resp.status}"
                        ),
                        evidence=f"{hdr}: POST -> status {resp.status}",
                        remediation=f"Reject or ignore {hdr} header",
                        tags=["pentesting", "smuggling", "method-override"],
                    ))
                    details.append({
                        "type": "method_override", "header": hdr,
                        "status": resp.status,
                    })
                    break
            except Exception:
                continue
