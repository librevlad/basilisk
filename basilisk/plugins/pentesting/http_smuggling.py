"""HTTP request smuggling vulnerability detection."""

from __future__ import annotations

import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Transfer-Encoding obfuscation variants used for TE.CL detection.
# These exploit differences in how front-end vs back-end servers
# parse the Transfer-Encoding header.
TE_OBFUSCATIONS = [
    "xchunked",
    " chunked",
    "chunked ",
    "\tchunked",
    "identity",
    "chunked\r\nX-Ignore: x",
]


class HttpSmugglingPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="http_smuggling",
        display_name="HTTP Smuggling Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects HTTP request smuggling conditions "
            "(CL.TE, TE.CL, H2.CL indicators)"
        ),
        produces=["smuggling_findings"],
        timeout=20.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        base_url = ""
        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(
                        f"{scheme}://{target.host}/",
                        timeout=5.0,
                    )
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="Host not reachable via HTTP(S)",
            )

        findings: list[Finding] = []
        details: list[dict] = []

        baseline = await self._get_baseline(base_url, ctx)
        if baseline is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="Could not establish baseline response",
            )

        await self._check_cl_te(
            base_url, ctx, baseline, findings, details,
        )
        await self._check_te_cl(
            base_url, ctx, baseline, findings, details,
        )
        await self._check_duplicate_cl(
            base_url, ctx, baseline, findings, details,
        )
        await self._check_te_identity(
            base_url, ctx, baseline, findings, details,
        )
        await self._check_h2_downgrade(
            base_url, ctx, findings, details,
        )

        if not findings:
            findings.append(Finding.info(
                "No HTTP smuggling indicators detected",
                tags=["pentesting", "smuggling"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "smuggling_findings": details,
                "baseline_status": baseline["status"],
                "baseline_time": round(baseline["time"], 3),
            },
        )

    async def _get_baseline(
        self, base_url: str, ctx,
    ) -> dict | None:
        """Send a normal GET to establish baseline status and timing."""
        try:
            async with ctx.rate:
                start = time.monotonic()
                resp = await ctx.http.get(
                    base_url + "/", timeout=10.0,
                )
                elapsed = time.monotonic() - start
                status = resp.status
                server = resp.headers.get("server", "")
                return {
                    "status": status,
                    "time": elapsed,
                    "server": server,
                }
        except Exception:
            return None

    async def _check_cl_te(
        self,
        base_url: str,
        ctx,
        baseline: dict,
        findings: list[Finding],
        details: list[dict],
    ) -> None:
        """Detect CL.TE smuggling conditions.

        Send a request with both Content-Length and
        Transfer-Encoding: chunked. If the server behaves
        differently (status change or significant delay),
        it may process the headers inconsistently.
        """
        headers = {
            "Content-Length": "6",
            "Transfer-Encoding": "chunked",
            "Content-Type": "application/x-www-form-urlencoded",
        }
        try:
            async with ctx.rate:
                start = time.monotonic()
                resp = await ctx.http.get(
                    base_url + "/",
                    headers=headers,
                    timeout=10.0,
                )
                elapsed = time.monotonic() - start
                status = resp.status

            status_diff = status != baseline["status"]
            slow = elapsed > baseline["time"] * 3 and elapsed > 2.0

            if status_diff or slow:
                evidence_parts = [
                    f"Baseline: {baseline['status']} "
                    f"in {baseline['time']:.2f}s",
                    f"CL.TE probe: {status} in {elapsed:.2f}s",
                ]
                if status_diff:
                    evidence_parts.append(
                        "Status code changed with ambiguous headers"
                    )
                if slow:
                    evidence_parts.append(
                        "Response significantly delayed"
                    )
                evidence = "; ".join(evidence_parts)

                sev = Finding.high if slow else Finding.medium
                findings.append(sev(
                    "CL.TE smuggling indicator detected",
                    description=(
                        "Server shows inconsistent behavior when "
                        "Content-Length and Transfer-Encoding: chunked "
                        "are both present"
                    ),
                    evidence=evidence,
                    remediation=(
                        "Configure the server to reject requests "
                        "with both Content-Length and "
                        "Transfer-Encoding headers"
                    ),
                    tags=["pentesting", "smuggling", "cl.te"],
                ))
                details.append({
                    "type": "CL.TE",
                    "status": status,
                    "time": round(elapsed, 3),
                })
        except TimeoutError:
            findings.append(Finding.high(
                "CL.TE smuggling indicator: request timeout",
                description=(
                    "Server timed out when processing request "
                    "with conflicting CL and TE headers"
                ),
                evidence="Request with CL+TE caused timeout",
                remediation=(
                    "Configure the server to reject requests "
                    "with both Content-Length and "
                    "Transfer-Encoding headers"
                ),
                tags=["pentesting", "smuggling", "cl.te"],
            ))
            details.append({"type": "CL.TE", "result": "timeout"})
        except Exception:
            pass

    async def _check_te_cl(
        self,
        base_url: str,
        ctx,
        baseline: dict,
        findings: list[Finding],
        details: list[dict],
    ) -> None:
        """Detect TE.CL smuggling via obfuscated TE headers.

        Different servers may or may not recognize obfuscated
        Transfer-Encoding values, leading to desync.
        """
        for variant in TE_OBFUSCATIONS:
            headers = {
                "Transfer-Encoding": variant,
                "Content-Length": "0",
                "Content-Type": (
                    "application/x-www-form-urlencoded"
                ),
            }
            try:
                async with ctx.rate:
                    start = time.monotonic()
                    resp = await ctx.http.get(
                        base_url + "/",
                        headers=headers,
                        timeout=10.0,
                    )
                    elapsed = time.monotonic() - start
                    status = resp.status

                status_diff = status != baseline["status"]
                slow = (
                    elapsed > baseline["time"] * 3
                    and elapsed > 2.0
                )

                if status_diff or slow:
                    evidence = (
                        f"TE variant '{variant.strip()}': "
                        f"status={status} in {elapsed:.2f}s "
                        f"(baseline: {baseline['status']} "
                        f"in {baseline['time']:.2f}s)"
                    )
                    sev = Finding.high if slow else Finding.medium
                    findings.append(sev(
                        "TE.CL smuggling indicator detected",
                        description=(
                            "Server reacted differently to "
                            "obfuscated Transfer-Encoding header "
                            f"'{variant.strip()}'"
                        ),
                        evidence=evidence,
                        remediation=(
                            "Normalize Transfer-Encoding parsing "
                            "or reject ambiguous TE values"
                        ),
                        tags=[
                            "pentesting", "smuggling", "te.cl",
                        ],
                    ))
                    details.append({
                        "type": "TE.CL",
                        "variant": variant.strip(),
                        "status": status,
                        "time": round(elapsed, 3),
                    })
                    break  # One finding is enough
            except TimeoutError:
                findings.append(Finding.high(
                    "TE.CL smuggling indicator: request timeout",
                    description=(
                        "Obfuscated Transfer-Encoding "
                        f"'{variant.strip()}' caused timeout"
                    ),
                    evidence=f"TE variant '{variant.strip()}' timeout",
                    remediation=(
                        "Normalize Transfer-Encoding parsing "
                        "or reject ambiguous TE values"
                    ),
                    tags=["pentesting", "smuggling", "te.cl"],
                ))
                details.append({
                    "type": "TE.CL",
                    "variant": variant.strip(),
                    "result": "timeout",
                })
                break
            except Exception:
                continue

    async def _check_duplicate_cl(
        self,
        base_url: str,
        ctx,
        baseline: dict,
        findings: list[Finding],
        details: list[dict],
    ) -> None:
        """Check if server accepts duplicate Content-Length headers.

        Servers that accept conflicting Content-Length values are
        potentially vulnerable to request smuggling.
        """
        # aiohttp deduplicates headers, so we test by sending
        # a single CL that mismatches the actual body size.
        headers = {
            "Content-Length": "0",
            "Content-Type": (
                "application/x-www-form-urlencoded"
            ),
        }
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/",
                    headers=headers,
                    timeout=10.0,
                )
                status = resp.status

            # A 400 response means the server validates CL strictly
            # which is the correct behavior. Non-400 with CL=0 on a
            # GET is normal; we look for 4xx errors that differ from
            # baseline as an indicator of strict parsing.
            if status == 400 and baseline["status"] != 400:
                details.append({
                    "type": "duplicate_cl",
                    "result": "strict_validation",
                    "status": status,
                })
                # Strict CL validation is actually good — not a finding
        except Exception:
            pass

    async def _check_te_identity(
        self,
        base_url: str,
        ctx,
        baseline: dict,
        findings: list[Finding],
        details: list[dict],
    ) -> None:
        """Check Transfer-Encoding: identity handling.

        RFC 7230 deprecated the 'identity' transfer coding.
        Servers that accept it may handle it inconsistently
        across proxies, enabling smuggling conditions.
        """
        headers = {
            "Transfer-Encoding": "identity",
            "Content-Length": "0",
        }
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/",
                    headers=headers,
                    timeout=10.0,
                )
                status = resp.status

            # Server should reject or ignore 'identity'.
            # If it returns a normal response, it processes
            # the deprecated value — potential desync risk.
            if status == baseline["status"]:
                # Server silently accepted identity — mild concern
                findings.append(Finding.medium(
                    "Server accepts Transfer-Encoding: identity",
                    description=(
                        "The deprecated 'identity' transfer coding "
                        "is accepted, which may cause desync with "
                        "proxies that reject or strip it"
                    ),
                    evidence=(
                        f"TE: identity returned status {status} "
                        f"(same as baseline {baseline['status']})"
                    ),
                    remediation=(
                        "Reject or ignore the deprecated "
                        "'identity' Transfer-Encoding value"
                    ),
                    tags=["pentesting", "smuggling", "te.identity"],
                ))
                details.append({
                    "type": "TE.identity",
                    "status": status,
                    "accepted": True,
                })
        except Exception:
            pass

    async def _check_h2_downgrade(
        self,
        base_url: str,
        ctx,
        findings: list[Finding],
        details: list[dict],
    ) -> None:
        """Check for HTTP/2 downgrade smuggling indicators.

        If the server advertises HTTP/2 (via Upgrade or Alt-Svc)
        but also serves HTTP/1.1, there may be a risk of H2.CL
        smuggling through protocol downgrade at reverse proxies.
        """
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url + "/",
                    headers={"Connection": "Upgrade, HTTP2-Settings"},
                    timeout=10.0,
                )
                upgrade = resp.headers.get("upgrade", "").lower()
                alt_svc = resp.headers.get("alt-svc", "").lower()

            h2_upgrade = "h2" in upgrade or "h2c" in upgrade
            h2_alt_svc = "h2" in alt_svc

            if h2_upgrade or h2_alt_svc:
                indicators = []
                if h2_upgrade:
                    indicators.append(
                        f"Upgrade: {resp.headers.get('upgrade', '')}"
                    )
                if h2_alt_svc:
                    indicators.append(
                        f"Alt-Svc: {resp.headers.get('alt-svc', '')}"
                    )
                evidence = "; ".join(indicators)

                findings.append(Finding.medium(
                    "H2.CL smuggling risk: HTTP/2 downgrade possible",
                    description=(
                        "Server advertises HTTP/2 support alongside "
                        "HTTP/1.1, which may allow H2.CL smuggling "
                        "if a reverse proxy downgrades the protocol"
                    ),
                    evidence=evidence,
                    remediation=(
                        "Ensure consistent HTTP version handling "
                        "between front-end proxy and back-end server; "
                        "disable HTTP/1.1 fallback if not needed"
                    ),
                    tags=["pentesting", "smuggling", "h2.cl"],
                ))
                details.append({
                    "type": "H2.CL",
                    "upgrade": h2_upgrade,
                    "alt_svc": h2_alt_svc,
                })
        except Exception:
            pass
