"""Git/sensitive file exposure detection."""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

SENSITIVE_PATHS = [
    # Git
    (".git/HEAD", "Git repository exposed"),
    (".git/config", "Git config exposed"),
    (".git/index", "Git index exposed"),
    (".git/logs/HEAD", "Git logs exposed"),
    (".git/refs/heads/main", "Git refs exposed"),
    (".git/refs/heads/master", "Git refs exposed"),
    (".git/packed-refs", "Git packed refs exposed"),
    (".git/objects/info/packs", "Git objects exposed"),
    (".git/description", "Git description exposed"),
    (".git/COMMIT_EDITMSG", "Git last commit message"),
    (".gitignore", ".gitignore exposed"),
    # SVN
    (".svn/entries", "SVN repository exposed"),
    (".svn/wc.db", "SVN database exposed"),
    # Mercurial
    (".hg/dirstate", "Mercurial repository exposed"),
    (".hg/store/fncache", "Mercurial store exposed"),
    # CVS
    ("CVS/Root", "CVS root exposed"),
    ("CVS/Entries", "CVS entries exposed"),
    # Env files
    (".env", "Environment file exposed"),
    (".env.local", "Local environment file exposed"),
    (".env.production", "Production environment file exposed"),
    (".env.staging", "Staging environment file exposed"),
    (".env.development", "Development environment file exposed"),
    (".env.backup", "Env backup exposed"),
    # Config files
    ("wp-config.php.bak", "WordPress config backup exposed"),
    ("web.config", "IIS web.config exposed"),
    (".htaccess", "Apache .htaccess exposed"),
    ("server-status", "Apache server-status exposed"),
    ("elmah.axd", "ELMAH error log exposed"),
    (".DS_Store", "macOS .DS_Store exposed"),
    ("Thumbs.db", "Windows Thumbs.db exposed"),
    # PHP
    ("phpinfo.php", "phpinfo() exposed"),
    ("info.php", "PHP info exposed"),
    # Informational
    ("robots.txt", "robots.txt (informational)"),
    ("sitemap.xml", "sitemap.xml (informational)"),
    ("crossdomain.xml", "Flash crossdomain policy"),
    ("security.txt", "security.txt (informational)"),
    (".well-known/security.txt", "security.txt (informational)"),
]


class GitExposurePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="git_exposure",
        display_name="Git/Sensitive File Exposure",
        category=PluginCategory.PENTESTING,
        description="Checks for exposed .git, .env, .DS_Store, and other sensitive files",
        produces=["exposed_files"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        base_url = ""
        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.fail(
                self.meta.name, target.host, error="Host not reachable via HTTP(S)"
            )

        findings: list[Finding] = []
        exposed: list[dict] = []

        for path, desc in SENSITIVE_PATHS:
            url = f"{base_url}/{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    status = resp.status
                    if status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        body_preview = body[:200]

                        # Validate it's a real match, not a custom 404
                        if self._is_real_content(path, body):
                            exposed.append({
                                "path": path,
                                "url": url,
                                "description": desc,
                            })

                            severity = self._severity_for_path(path)
                            finding_fn = {
                                "critical": Finding.critical,
                                "high": Finding.high,
                                "medium": Finding.medium,
                                "low": Finding.low,
                            }.get(severity, Finding.info)

                            findings.append(finding_fn(
                                desc,
                                description=f"Sensitive file accessible at {url}",
                                evidence=body_preview,
                                remediation=(
                                    f"Block access to /{path} in web server config"
                                ),
                                tags=["pentesting", "exposure"],
                            ))
            except Exception:
                continue

        if not findings:
            findings.append(Finding.info(
                "No sensitive files exposed",
                tags=["pentesting", "exposure"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"exposed_files": exposed},
        )

    @staticmethod
    def _is_real_content(path: str, body: str) -> bool:
        """Check if response is actual content and not a custom 404 or SPA."""
        if len(body) < 5:
            return False
        body_lower = body.lower()
        body_stripped = body.strip()

        # Reject HTML responses — real .env/.git files are NOT HTML
        is_html = body_stripped.startswith((
            "<!doctype", "<html", "<?xml",
        ))

        if "404" in body_lower[:200] and "not found" in body_lower[:200]:
            return False

        if path == ".git/HEAD":
            return "ref:" in body and not is_html
        if path == ".git/config":
            return "[core]" in body and not is_html
        if path.startswith(".env"):
            # Real .env files contain KEY=VALUE, NOT HTML
            if is_html:
                return False
            import re
            return bool(re.search(r'^[A-Z_]+=', body, re.MULTILINE))
        if path == ".DS_Store":
            return not is_html and "\x00" in body[:20]
        if path.endswith((".php", ".php.bak")):
            # If PHP source is exposed, it should start with <?
            # If it's a web page, the server executed it — not exposed
            if is_html:
                return False
            return "<?php" in body_lower[:100] or "<?" in body[:10]
        if path == "web.config":
            return "<?xml" in body_lower and "configuration" in body_lower
        if path == ".htaccess":
            return not is_html and (
                "rewrite" in body_lower or "deny" in body_lower
                or "allow" in body_lower
            )
        if path in (".svn/entries", ".hg/dirstate"):
            return not is_html
        if path == "robots.txt":
            return "user-agent" in body_lower or "disallow" in body_lower
        if path == "sitemap.xml":
            return "<?xml" in body_lower and "urlset" in body_lower
        if path == "crossdomain.xml":
            return "<?xml" in body_lower and "cross-domain" in body_lower
        if path in ("security.txt", ".well-known/security.txt"):
            return "contact:" in body_lower and not is_html
        if path == "server-status":
            return "apache" in body_lower and "server" in body_lower
        if path == "elmah.axd":
            return "error" in body_lower and "elmah" in body_lower

        return not is_html

    @staticmethod
    def _severity_for_path(path: str) -> str:
        """Determine severity based on what file is exposed."""
        critical_paths = {".env", ".env.local", ".env.production"}
        high_paths = {
            ".git/HEAD", ".git/config", "wp-config.php.bak", "web.config",
        }
        medium_paths = {
            ".svn/entries", ".hg/dirstate", "phpinfo.php", "info.php",
            "elmah.axd",
        }

        if path in critical_paths:
            return "critical"
        if path in high_paths:
            return "high"
        if path in medium_paths:
            return "medium"
        return "low"
