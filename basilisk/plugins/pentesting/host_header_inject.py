"""Host header injection detection â€” password reset poisoning, cache poisoning, SSRF.

Checks for:
1. X-Forwarded-Host reflection in response body
2. X-Host / X-Forwarded-Server injection
3. Host header reflection in redirects
4. Password reset poisoning via injected host
5. Absolute URL generation with injected host
6. Web cache poisoning via host manipulation
"""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

EVIL_HOST = "evil.basilisk.test"

# Headers to inject
INJECT_HEADERS: list[tuple[str, str, str]] = [
    ("X-Forwarded-Host", EVIL_HOST, "x_forwarded_host"),
    ("X-Host", EVIL_HOST, "x_host"),
    ("X-Forwarded-Server", EVIL_HOST, "x_forwarded_server"),
    ("X-Original-URL", f"/{EVIL_HOST}", "x_original_url"),
    ("X-Rewrite-URL", f"/{EVIL_HOST}", "x_rewrite_url"),
    ("X-Forwarded-Port", "443\r\nX-Injected: true", "port_crlf"),
    ("X-Forwarded-Scheme", "nothttps", "x_forwarded_scheme"),
]


class HostHeaderInjectPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="host_header_inject",
        display_name="Host Header Injection",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects host header injection for password reset poisoning, "
            "cache poisoning, and routing manipulation"
        ),
        produces=["host_inject_findings"],
        timeout=25.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"host_inject": []},
            )

        # Get baseline
        baseline_body = ""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/", timeout=5.0)
                baseline_body = await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            pass

        # Test 1: Header injection on main page
        for header_name, header_value, label in INJECT_HEADERS:
            if ctx.should_stop:
                break

            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}/",
                        headers={header_name: header_value},
                        timeout=8.0,
                        allow_redirects=False,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    location = resp.headers.get("Location", "")
            except Exception:
                continue

            is_vuln = False
            desc = ""

            # Check body reflection
            if EVIL_HOST in body and EVIL_HOST not in baseline_body:
                is_vuln = True
                desc = f"{header_name} reflected in response body"

            # Check redirect Location
            if EVIL_HOST in location:
                is_vuln = True
                desc = f"{header_name} used in redirect Location"

            if is_vuln:
                severity_fn = Finding.medium
                if "redirect" in desc.lower() or "Location" in desc:
                    severity_fn = Finding.high

                tested.append({
                    "header": header_name, "label": label,
                    "reflected_in": "redirect" if "redirect" in desc else "body",
                })
                findings.append(severity_fn(
                    f"Host injection via {header_name}",
                    description=desc,
                    evidence=(
                        f"Header: {header_name}: {header_value}\n"
                        f"Result: {desc}"
                    ),
                    remediation=(
                        "Do not trust X-Forwarded-Host or similar headers "
                        "for URL generation. Use the configured server name."
                    ),
                    tags=["pentesting", "host-injection", label],
                ))

        # Test 2: Password reset flow poisoning
        if not ctx.should_stop:
            reset_paths = [
                "/password/reset", "/forgot-password", "/reset-password",
                "/auth/forgot", "/account/recover", "/users/password/new",
            ]
            for reset_path in reset_paths:
                if ctx.should_stop:
                    break

                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}{reset_path}", timeout=5.0,
                        )
                        if resp.status != 200:
                            continue

                    # Try POST with injected host
                    async with ctx.rate:
                        resp = await ctx.http.post(
                            f"{base_url}{reset_path}",
                            data={"email": f"test@{target.host}"},
                            headers={"X-Forwarded-Host": EVIL_HOST},
                            timeout=8.0,
                            allow_redirects=False,
                        )
                        body = await resp.text(encoding="utf-8", errors="replace")
                        location = resp.headers.get("Location", "")

                        if EVIL_HOST in body or EVIL_HOST in location:
                            tested.append({
                                "type": "password_reset_poison",
                                "path": reset_path,
                            })
                            findings.append(Finding.high(
                                f"Password reset poisoning: {reset_path}",
                                description=(
                                    "Password reset form accepts X-Forwarded-Host. "
                                    "Reset links may use attacker-controlled domain."
                                ),
                                evidence=f"Path: {reset_path}, Host: {EVIL_HOST} reflected",
                                remediation=(
                                    "Use configured hostname for password reset URLs. "
                                    "Ignore X-Forwarded-Host in reset flow."
                                ),
                                tags=["pentesting", "host-injection", "password-reset"],
                            ))
                            break
                except Exception:
                    continue

        # Test 3: Absolute URL generation
        if not ctx.should_stop:
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}/",
                        headers={
                            "X-Forwarded-Host": EVIL_HOST,
                            "X-Forwarded-Proto": "https",
                        },
                        timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    full_url = f"https://{EVIL_HOST}"
                    if full_url in body and full_url not in baseline_body:
                        tested.append({"type": "absolute_url_poison"})
                        findings.append(Finding.medium(
                            "Absolute URL poisoning via X-Forwarded-Host + Proto",
                            description=(
                                "Server generates absolute URLs using injected host. "
                                "Can be used for cache poisoning."
                            ),
                            evidence=f"Found: {full_url} in response",
                            remediation="Use configured hostname for URL generation.",
                            tags=["pentesting", "host-injection", "cache-poison"],
                        ))
            except Exception:
                pass

        if not findings:
            findings.append(Finding.info(
                "No host header injection detected",
                tags=["pentesting", "host-injection"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"host_inject": tested},
        )
