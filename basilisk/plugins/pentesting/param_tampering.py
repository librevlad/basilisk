"""Parameter tampering and business logic testing.

Tests for price manipulation, quantity overflow, privilege escalation via
hidden parameters, type confusion, and other business logic flaws that
arise from insufficient server-side validation of user-controlled inputs.
"""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Hidden/privilege parameters to inject
PRIV_PARAMS = [
    ("admin", "true"), ("is_admin", "1"), ("role", "admin"),
    ("debug", "1"), ("internal", "1"), ("test", "1"),
    ("access_level", "9999"), ("user_type", "admin"),
]

# Numeric tampering values
NUMERIC_TAMPERS = [
    ("0", "zero value"),
    ("-1", "negative value"),
    ("99999999", "overflow value"),
    ("0.001", "fractional value"),
    ("NaN", "NaN injection"),
]

# Business logic field patterns (regex → category)
BUSINESS_FIELDS = re.compile(
    r"(price|cost|amount|total|quantity|qty|count|discount|balance|"
    r"credit|points|score|rating|weight|tax|fee|shipping|tip)",
    re.IGNORECASE,
)

# Auth/role field patterns
AUTH_FIELDS = re.compile(
    r"(role|admin|privilege|permission|access|level|group|type|status|active|"
    r"verified|approved|is_staff|superuser|moderator)",
    re.IGNORECASE,
)


class ParamTamperingPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="param_tampering",
        display_name="Parameter Tampering",
        category=PluginCategory.PENTESTING,
        description=(
            "Test for parameter manipulation, business logic flaws, "
            "mass assignment, and privilege escalation via hidden parameters"
        ),
        produces=["param_tampering"],
        depends_on=[],
        requires_http=True,
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"param_tampering_tests": []},
            )

        # Collect injection points from crawled data
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=[
                "/", "/checkout", "/cart", "/order", "/payment",
                "/profile", "/settings", "/account", "/register",
                "/api/user", "/api/order", "/api/product",
            ],
            hardcoded_params=[
                "price", "quantity", "amount", "total", "discount",
                "role", "admin", "id", "user_id",
            ],
            max_points=20,
        )

        # Phase 1: Hidden privilege parameter injection
        for point in inj_points[:10]:
            if ctx.should_stop or len(findings) >= 6:
                break
            await self._test_hidden_params(ctx, base_url, point, findings, tested)

        # Phase 2: Numeric field tampering
        for point in inj_points[:10]:
            if ctx.should_stop or len(findings) >= 6:
                break
            await self._test_numeric_tamper(ctx, base_url, point, findings, tested)

        # Phase 3: Type confusion
        for point in inj_points[:8]:
            if ctx.should_stop or len(findings) >= 6:
                break
            await self._test_type_confusion(ctx, base_url, point, findings, tested)

        if not findings:
            findings.append(Finding.info(
                "No parameter tampering vulnerabilities detected",
                tags=["pentesting", "param_tampering"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"param_tampering_tests": tested},
        )

    # ── Test phases ──────────────────────────────────────────────────

    async def _test_hidden_params(
        self, ctx, base_url: str, point, findings: list, tested: list,
    ) -> None:
        """Inject hidden privilege parameters and check for behavior change."""
        url = f"{base_url}{point.path}"

        # Get baseline response
        baseline = await self._fetch(ctx, url)
        if not baseline:
            return

        # Detect if endpoint is a JSON API (for JSON POST testing)
        is_json_api = (
            "application/json" in baseline[:500].lower()
            or baseline.lstrip().startswith(("{", "["))
            or any(seg in point.path.lower() for seg in ("/api/", "/api?", "/v1/", "/v2/"))
            or point.path.lower().endswith(("/register", "/signup", "/users"))
        )

        for param_name, param_value in PRIV_PARAMS:
            if ctx.should_stop:
                return
            if param_name in point.params:
                continue

            if point.method == "POST":
                data = dict(point.params)
                data[param_name] = param_value
                resp_text, resp_status = await self._post(ctx, url, data)
                # Also try JSON POST for API endpoints
                if is_json_api and resp_text is not None:
                    json_text, json_status = await self._post_json(ctx, url, data)
                    if json_text is not None and json_status < 400:
                        resp_text = json_text
                        resp_status = json_status
                elif is_json_api:
                    resp_text, resp_status = await self._post_json(ctx, url, data)
            elif is_json_api:
                # Try JSON POST even for GET-classified API endpoints
                data = dict(point.params)
                data[param_name] = param_value
                resp_text, resp_status = await self._post_json(ctx, url, data)
                if resp_text is None:
                    sep = "&" if "?" in url else "?"
                    test_url = f"{url}{sep}{param_name}={param_value}"
                    resp_text, resp_status = await self._get(ctx, test_url)
            else:
                sep = "&" if "?" in url else "?"
                test_url = f"{url}{sep}{param_name}={param_value}"
                resp_text, resp_status = await self._get(ctx, test_url)

            if resp_text is None:
                continue

            tested.append({
                "path": point.path, "param": param_name,
                "value": param_value, "type": "hidden_param",
            })

            # Check for privilege escalation indicators
            if self._indicates_escalation(baseline, resp_text):
                findings.append(Finding.high(
                    f"Mass assignment: {param_name}={param_value} on {point.path}",
                    description=(
                        f"Adding hidden parameter '{param_name}' changed server "
                        f"behavior, suggesting mass assignment or privilege escalation"
                    ),
                    evidence=f"URL: {url}\nInjected: {param_name}={param_value}",
                    confidence=0.65,
                    remediation=(
                        "Whitelist accepted parameters server-side; "
                        "never bind request params directly to models"
                    ),
                    tags=["pentesting", "param_tampering", "mass_assignment"],
                ))
                return

    async def _test_numeric_tamper(
        self, ctx, base_url: str, point, findings: list, tested: list,
    ) -> None:
        """Test numeric parameters with boundary values."""
        for param_name, param_original in point.params.items():
            if ctx.should_stop:
                return
            if not BUSINESS_FIELDS.search(param_name):
                continue

            url = f"{base_url}{point.path}"
            # Get baseline with original value
            baseline = await self._fetch_with_param(
                ctx, base_url, point, param_name, param_original or "1",
            )
            if not baseline:
                continue

            for tamper_value, tamper_desc in NUMERIC_TAMPERS:
                if ctx.should_stop:
                    return

                resp = await self._fetch_with_param(
                    ctx, base_url, point, param_name, tamper_value,
                )
                if resp is None:
                    continue

                tested.append({
                    "path": point.path, "param": param_name,
                    "value": tamper_value, "type": "numeric_tamper",
                })

                # Check if server accepted the invalid value without error
                if self._accepted_tamper(baseline, resp, tamper_value):
                    sev = Finding.high if tamper_value in ("0", "-1") else Finding.medium
                    findings.append(sev(
                        f"Parameter tampering: {param_name}={tamper_value} on {point.path}",
                        description=(
                            f"Server accepted {tamper_desc} for business-critical "
                            f"field '{param_name}' without validation"
                        ),
                        evidence=(
                            f"URL: {url}\n"
                            f"Parameter: {param_name}={tamper_value} ({tamper_desc})"
                        ),
                        confidence=0.6,
                        remediation=(
                            f"Validate '{param_name}' server-side: "
                            f"enforce positive values and reasonable bounds"
                        ),
                        tags=["pentesting", "param_tampering", "business_logic"],
                    ))
                    return

    async def _test_type_confusion(
        self, ctx, base_url: str, point, findings: list, tested: list,
    ) -> None:
        """Test type confusion: send array/object where scalar expected."""
        for param_name in list(point.params.keys())[:3]:
            if ctx.should_stop:
                return

            url = f"{base_url}{point.path}"

            # Test: send array value
            if point.method == "POST":
                data = dict(point.params)
                data[param_name] = ["value1", "value2"]
                try:
                    async with ctx.rate:
                        resp = await ctx.http.post(
                            url, json=data, timeout=8.0,
                        )
                        body = await resp.text(encoding="utf-8", errors="replace")
                except Exception:
                    continue

                tested.append({
                    "path": point.path, "param": param_name,
                    "type": "type_confusion",
                })

                # Server error with stack trace = type confusion
                if resp.status >= 500 and self._has_stack_trace(body):
                    findings.append(Finding.medium(
                        f"Type confusion: array in '{param_name}' on {point.path}",
                        description=(
                            f"Sending array value for '{param_name}' caused "
                            f"server error with stack trace disclosure"
                        ),
                        evidence=f"URL: {url}\nStatus: {resp.status}",
                        confidence=0.6,
                        remediation="Validate parameter types server-side",
                        tags=["pentesting", "param_tampering", "type_confusion"],
                    ))
                    return

    # ── Helpers ──────────────────────────────────────────────────────

    async def _fetch(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                if resp.status >= 500:
                    return None
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("param_tampering fetch %s: %s", url, e)
            return None

    async def _get(self, ctx, url: str) -> tuple[str | None, int]:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception:
            return None, 0

    async def _post(self, ctx, url: str, data: dict) -> tuple[str | None, int]:
        try:
            async with ctx.rate:
                resp = await ctx.http.post(url, data=data, timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception:
            return None, 0

    async def _post_json(self, ctx, url: str, data: dict) -> tuple[str | None, int]:
        try:
            async with ctx.rate:
                resp = await ctx.http.post(url, json=data, timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception:
            return None, 0

    async def _fetch_with_param(
        self, ctx, base_url: str, point, param: str, value: str,
    ) -> str | None:
        url = f"{base_url}{point.path}"
        if point.method == "POST":
            data = dict(point.params)
            data[param] = value
            text, _ = await self._post(ctx, url, data)
            return text
        test_url = point.build_url(base_url, param, value)
        return await self._fetch(ctx, test_url)

    @staticmethod
    def _indicates_escalation(baseline: str, response: str) -> bool:
        """Check if response contains privilege escalation indicators."""
        indicators = [
            "admin", "administrator", "dashboard", "panel",
            "manage", "settings", "configuration", "debug",
            "internal", "superuser", "staff",
        ]
        baseline_lower = baseline.lower()
        response_lower = response.lower()
        return any(
            ind in response_lower and ind not in baseline_lower for ind in indicators
        )

    @staticmethod
    def _accepted_tamper(baseline: str, response: str, tamper_value: str) -> bool:
        """Check if server accepted a tampered value without error."""
        if not response:
            return False
        # If response contains the tampered value reflected back = accepted
        if tamper_value in response:
            return True
        # If response is significantly different but no error indicators
        error_words = ["error", "invalid", "required", "must be", "cannot"]
        resp_lower = response.lower()
        if any(w in resp_lower and w not in baseline.lower() for w in error_words):
            return False
        # Significant body change without error = likely accepted
        return abs(len(response) - len(baseline)) > len(baseline) * 0.15

    @staticmethod
    def _has_stack_trace(body: str) -> bool:
        """Check if response contains a stack trace."""
        indicators = [
            "Traceback", "at line", "Stack trace", "Exception in",
            "TypeError:", "ValueError:", "NullPointerException",
            "java.lang.", "at org.", "at com.",
        ]
        return any(ind in body for ind in indicators)
