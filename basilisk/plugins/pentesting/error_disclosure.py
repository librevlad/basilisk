"""Error message information disclosure detection.

Triggers various error conditions and analyzes responses for:
1. Server paths (filesystem paths leaked in errors)
2. Framework/language/database version disclosure
3. Stack traces (PHP, Python, Java, .NET, Ruby)
4. Internal IP addresses
5. SQL queries in error messages
6. Debug mode indicators
"""

from __future__ import annotations

import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target


class ErrorDisclosurePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="error_disclosure",
        display_name="Error Information Disclosure",
        category=PluginCategory.PENTESTING,
        description=(
            "Triggers errors and analyzes responses for information disclosure: "
            "paths, stack traces, versions, internal IPs, SQL queries"
        ),
        produces=["error_findings"],
        timeout=25.0,
    )

    ERROR_TRIGGERS = [
        ("/?id='", "SQL quote"),
        ("/?id[]=1", "Array param"),
        ("/index.php%00", "Null byte"),
        ("/%2e%2e/%2e%2e/etc/passwd", "Path traversal"),
        ("/" + "A" * 500, "Long URL"),
        ("/?<script>", "Script tag"),
        ("/test.aspx", "ASP.NET probe"),
        ("/test.php", "PHP probe"),
        ("/?id=-1", "Negative ID"),
        ("/?id=99999999", "Large ID"),
        ("/index.php?debug=1", "Debug flag"),
        ("/index.php?test=true", "Test flag"),
        ("/?id=1%27%20OR%201%3D1", "SQLi probe"),
        ("/?q={{7*7}}", "SSTI probe"),
        ("/wp-content/../wp-config.php", "WP config traverse"),
        ("/.env", "Dotenv probe"),
        ("/error", "Error page"),
        ("/404", "Custom 404"),
        ("/undefined", "Undefined route"),
        ("/?id=1%00", "Null byte param"),
    ]

    DISCLOSURE_PATTERNS = [
        (
            "Server Path",
            r"(?:/var/www/|/home/\w+/|/srv/|/opt/|C:\\\\?(?:inetpub|Users|Windows)"
            r"|/usr/(?:share|local|lib)/)[\w/\\.-]+",
        ),
        (
            "Framework",
            r"(?:Laravel|Django|Rails|Express|Flask|FastAPI|Spring(?:Boot)?|ASP\.NET"
            r"|Next\.js|Nuxt|CakePHP|CodeIgniter|Symfony)\s*[\d.]*",
        ),
        (
            "Database Error",
            r"(?:MySQL|PostgreSQL|SQLite|Oracle|MSSQL|MariaDB|MongoDB)"
            r"(?:\s+(?:server|version))?\s*[\d.]*",
        ),
        (
            "PHP Error",
            r"(?:Fatal error|Warning|Notice|Parse error|Deprecated):\s*.+?"
            r"in\s+\S+\s+on line\s+\d+",
        ),
        (
            "Python Traceback",
            r"Traceback \(most recent call last\)",
        ),
        (
            "Java Exception",
            r"(?:java\.\w+\.[\w.]+Exception|at\s+[\w.$]+\([\w.]+:\d+\))",
        ),
        (
            ".NET Exception",
            r"(?:System\.\w+Exception|Server Error in .+ Application"
            r"|An unhandled exception)",
        ),
        (
            "Ruby Error",
            r"(?:NoMethodError|ArgumentError|NameError|RuntimeError)"
            r"\s*[\(:]",
        ),
        (
            "Node.js Error",
            r"(?:TypeError|ReferenceError|SyntaxError|RangeError)"
            r"\s*:.*at\s+",
        ),
        (
            "SQL Query",
            r"(?:SELECT\s+.+?\s+FROM|INSERT\s+INTO|UPDATE\s+.+?\s+SET"
            r"|DELETE\s+FROM)\s+\w+",
        ),
        (
            "Stack Frame",
            r"#\d+\s+\S+\s+(?:called at|in)\s+",
        ),
        (
            "Internal IP",
            r"\b(?:10\.\d{1,3}\.\d{1,3}\.\d{1,3}"
            r"|172\.(?:1[6-9]|2\d|3[01])\.\d{1,3}\.\d{1,3}"
            r"|192\.168\.\d{1,3}\.\d{1,3})\b",
        ),
        (
            "Debug Mode",
            r"(?:DEBUG\s*(?:=|:)\s*(?:true|True|1|on)|WP_DEBUG|DJANGO_DEBUG"
            r"|APP_DEBUG\s*=\s*true)",
        ),
        (
            "Email Address",
            r"\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b",
        ),
    ]

    # High-severity patterns
    HIGH_SEVERITY = {
        "Server Path", "Internal IP", "PHP Error", "Python Traceback",
        "Java Exception", ".NET Exception", "SQL Query", "Debug Mode",
    }

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        disclosures: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"disclosures": []},
            )

        # Get baseline body to filter out normal page content
        baseline_body = ""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/", timeout=5.0)
                baseline_body = await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            pass

        seen: set[str] = set()
        for path, trigger_name in self.ERROR_TRIGGERS:
            if ctx.should_stop or len(disclosures) >= 10:
                break

            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")

                    for name, pattern in self.DISCLOSURE_PATTERNS:
                        if name in seen:
                            continue
                        match = re.search(pattern, body, re.IGNORECASE)
                        if not match:
                            continue

                        # Skip if the same match exists in baseline
                        if baseline_body and re.search(
                            pattern, baseline_body, re.IGNORECASE,
                        ):
                            continue

                        seen.add(name)
                        matched_text = match.group()[:150]
                        disclosures.append({
                            "type": name,
                            "trigger": trigger_name,
                            "match": matched_text,
                        })

                        sev = Finding.medium if name in self.HIGH_SEVERITY else Finding.low
                        findings.append(sev(
                            f"Error discloses {name}",
                            description=f"Triggered by: {trigger_name}",
                            evidence=matched_text,
                            remediation=(
                                "Configure custom error pages, disable debug mode, "
                                "suppress detailed error messages in production."
                            ),
                            tags=["pentesting", "info-disclosure", name.lower().replace(" ", "-")],
                        ))
            except Exception:
                continue

        if not findings:
            findings.append(Finding.info(
                f"No information disclosed in error messages "
                f"({len(self.ERROR_TRIGGERS)} triggers tested)",
                tags=["pentesting", "info-disclosure"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"disclosures": disclosures},
        )
