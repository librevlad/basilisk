"""API Logic Engine — automated IDOR/BOLA detection using OpenAPI specs.

Uses dual auth sessions (attacker/victim) to test authorization boundaries:
1. Discover ID-parameterized endpoints from OpenAPI spec
2. Enumerate victim's resource IDs via authenticated requests
3. Replay requests with attacker's session targeting victim's resources
4. Compare responses — high similarity = IDOR/BOLA vulnerability

Requires: openapi_parser results + dual auth sessions (attacker + victim).
"""

from __future__ import annotations

import json
import logging
import re
from difflib import SequenceMatcher
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Regex to identify ID parameters in OpenAPI paths
_ID_PARAM_RE = re.compile(
    r"\{(\w*(?:id|Id|ID)\w*)\}|"
    r"\{(\w+_id)\}|"
    r"\{(user|account|order|profile|document|file|invoice|item|resource)\}"
)

# Fields commonly containing resource IDs in JSON responses
_ID_FIELD_RE = re.compile(
    r"^(?:\w*(?:id|Id|ID)\w*|_id|pk|uuid|key)$"
)

# Maximum endpoints to test
MAX_ENDPOINTS = 50


class ApiLogicEnginePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="api_logic_engine",
        display_name="API Logic Engine (Auto-IDOR/BOLA)",
        category=PluginCategory.PENTESTING,
        description=(
            "Automatically tests for IDOR/BOLA using discovered OpenAPI specs "
            "and dual auth sessions (attacker/victim). Replays victim's "
            "resource requests with attacker's credentials."
        ),
        depends_on=["openapi_parser"],
        produces=["idor_bola_findings"],
        requires_auth=True,
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        # Check for dual auth sessions
        if not ctx.auth or not ctx.auth.has_dual_sessions(target.host):
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "IDOR testing skipped: dual auth sessions not configured",
                    description=(
                        "Configure both attacker and victim sessions via "
                        "auth.victim_bearer_token and auth.bearer_token"
                    ),
                    tags=["pentesting", "idor"],
                )],
                data={"idor_bola_tests": [], "reason": "no_dual_sessions"},
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"idor_bola_tests": []},
            )

        attacker = ctx.auth.get_named_session(target.host, "attacker")
        victim = ctx.auth.get_named_session(target.host, "victim")
        if not attacker or not victim:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Named sessions not available")],
                data={"idor_bola_tests": []},
            )

        # Phase 1: Discover ID-parameterized endpoints
        endpoints = self._find_id_endpoints(target.host, ctx)
        if not endpoints:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No ID-parameterized endpoints found in OpenAPI spec",
                    tags=["pentesting", "idor"],
                )],
                data={"idor_bola_tests": [], "reason": "no_id_endpoints"},
            )

        for ep in endpoints[:MAX_ENDPOINTS]:
            if ctx.should_stop or len(findings) >= 5:
                break

            path = ep["path"]
            method = ep.get("method", "get")
            id_params = ep.get("id_params", [])

            # Phase 2: Enumerate victim's resources
            resources = await self._enumerate_victim_resources(
                base_url, path, method, id_params, victim, ctx,
            )

            for resource_id, victim_response in resources:
                if ctx.should_stop:
                    break

                # Phase 3: Replay with attacker session
                attacker_status, attacker_body = await self._replay_as_attacker(
                    base_url, path, method, id_params,
                    resource_id, attacker, ctx,
                )

                if attacker_status == 0:
                    continue  # Request failed

                test_record: dict[str, Any] = {
                    "path": path,
                    "method": method,
                    "resource_id": str(resource_id),
                    "victim_status": 200,
                    "attacker_status": attacker_status,
                }

                # Phase 4: Compare responses
                if attacker_status in (401, 403):
                    test_record["result"] = "blocked"
                    tested.append(test_record)
                    continue

                if attacker_status == 200:
                    similarity = self._compute_similarity(
                        victim_response, attacker_body,
                    )
                    test_record["similarity"] = round(similarity, 3)

                    if similarity > 0.80:
                        is_uuid = self._looks_like_uuid(str(resource_id))
                        test_record["result"] = "idor_critical"
                        tested.append(test_record)
                        findings.append(Finding.critical(
                            f"IDOR/BOLA: {method.upper()} {path} "
                            f"(id={resource_id})",
                            description=(
                                f"Attacker session can access victim's "
                                f"resource at {path} with {similarity:.0%} "
                                f"response similarity. Full data exposure."
                            ),
                            evidence=(
                                f"Endpoint: {method.upper()} {path}\n"
                                f"Resource ID: {resource_id}\n"
                                f"Attacker status: {attacker_status}\n"
                                f"Similarity: {similarity:.1%}\n"
                                f"Attacker body (first 300 chars): "
                                f"{attacker_body[:300]}"
                            ),
                            remediation=(
                                "Implement object-level authorization checks. "
                                "Verify the authenticated user owns or has "
                                "permission to access the requested resource."
                            ),
                            confidence=0.95 if not is_uuid else 0.85,
                            verified=True,
                            false_positive_risk=(
                                "low" if not is_uuid else "medium"
                            ),
                            tags=["pentesting", "idor", "bola", "owasp-a1"],
                        ))
                        break  # One CRITICAL per endpoint is enough

                    elif similarity > 0.50:
                        test_record["result"] = "partial_leak"
                        tested.append(test_record)
                        findings.append(Finding.high(
                            f"Partial IDOR: {method.upper()} {path}",
                            description=(
                                f"Attacker gets partial data from victim's "
                                f"resource ({similarity:.0%} similarity)."
                            ),
                            evidence=(
                                f"Endpoint: {method.upper()} {path}\n"
                                f"Resource ID: {resource_id}\n"
                                f"Similarity: {similarity:.1%}\n"
                                f"Attacker body: {attacker_body[:200]}"
                            ),
                            remediation=(
                                "Review authorization logic for partial "
                                "data exposure."
                            ),
                            confidence=0.7,
                            false_positive_risk="medium",
                            tags=["pentesting", "idor", "partial"],
                        ))
                    else:
                        test_record["result"] = "different_response"
                        tested.append(test_record)
                else:
                    test_record["result"] = f"status_{attacker_status}"
                    tested.append(test_record)

        if not findings:
            findings.append(Finding.info(
                "No IDOR/BOLA vulnerabilities detected",
                tags=["pentesting", "idor"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "idor_bola_tests": tested,
                "endpoints_scanned": len(endpoints),
            },
        )

    # -- Helpers ---------------------------------------------------------

    def _find_id_endpoints(
        self, host: str, ctx,
    ) -> list[dict[str, Any]]:
        """Find endpoints with ID parameters from OpenAPI data."""
        api_eps = ctx.state.get("api_endpoints_detailed", {}).get(host, [])
        result: list[dict[str, Any]] = []

        for ep in api_eps:
            path = ep.get("path", "")
            method = ep.get("method", "get")
            params = ep.get("parameters", [])

            id_params: list[dict] = []

            # Check path for ID placeholders
            for match in _ID_PARAM_RE.finditer(path):
                param_name = match.group(1) or match.group(2) or match.group(3)
                if param_name:
                    id_params.append({
                        "name": param_name, "in": "path", "type": "id",
                    })

            # Check query/path params for ID-like names
            for p in params:
                name = p.get("name", "")
                if _ID_PARAM_RE.search(f"{{{name}}}") and not any(
                    ip["name"] == name for ip in id_params
                ):
                    id_params.append({
                        "name": name,
                        "in": p.get("in", "query"),
                        "type": p.get("type", "string"),
                    })

            if id_params and method in ("get", "put", "patch", "delete"):
                result.append({
                    "path": path,
                    "method": method,
                    "id_params": id_params,
                    "requires_auth": ep.get("requires_auth", False),
                })

        return result[:MAX_ENDPOINTS]

    async def _enumerate_victim_resources(
        self,
        base_url: str,
        path: str,
        method: str,
        id_params: list[dict],
        victim_session,
        ctx,
    ) -> list[tuple[str, str]]:
        """Fetch resources as victim to extract real IDs."""
        resources: list[tuple[str, str]] = []

        # Try common ID values
        test_ids = ["1", "2", "me", "current"]

        for test_id in test_ids:
            if ctx.should_stop:
                break

            url = self._build_url(base_url, path, id_params, test_id)
            try:
                headers = victim_session.inject_headers({})
                async with ctx.rate:
                    resp = await ctx.http.request(
                        method.upper(), url, headers=headers, timeout=10.0,
                    )
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        # Extract IDs from response body
                        extracted = self._extract_ids_from_json(body)
                        for eid in extracted[:5]:
                            resources.append((eid, body))
                        if not extracted:
                            resources.append((test_id, body))
                        break  # Found valid response
            except Exception as e:
                logger.debug("api_logic_engine: %s", e)
                continue

        return resources[:10]

    async def _replay_as_attacker(
        self,
        base_url: str,
        path: str,
        method: str,
        id_params: list[dict],
        resource_id: str,
        attacker_session,
        ctx,
    ) -> tuple[int, str]:
        """Replay request with attacker session targeting victim's resource."""
        url = self._build_url(base_url, path, id_params, resource_id)
        try:
            headers = attacker_session.inject_headers({})
            async with ctx.rate:
                resp = await ctx.http.request(
                    method.upper(), url, headers=headers, timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                return resp.status, body
        except Exception as e:
            logger.debug("api_logic_engine: %s", e)
            return 0, ""

    @staticmethod
    def _build_url(
        base_url: str,
        path: str,
        id_params: list[dict],
        resource_id: str,
    ) -> str:
        """Build URL with ID substitution."""
        resolved_path = path
        query_parts: list[str] = []

        for param in id_params:
            if param["in"] == "path":
                resolved_path = resolved_path.replace(
                    f"{{{param['name']}}}", str(resource_id),
                )
            elif param["in"] == "query":
                query_parts.append(f"{param['name']}={resource_id}")

        url = f"{base_url}{resolved_path}"
        if query_parts:
            url += "?" + "&".join(query_parts)
        return url

    @staticmethod
    def _compute_similarity(body_a: str, body_b: str) -> float:
        """Compute response similarity, with JSON normalization if possible."""
        try:
            a_json = json.loads(body_a)
            b_json = json.loads(body_b)
            a_str = json.dumps(a_json, sort_keys=True, default=str)
            b_str = json.dumps(b_json, sort_keys=True, default=str)
        except (json.JSONDecodeError, TypeError):
            a_str = body_a
            b_str = body_b

        if not a_str and not b_str:
            return 1.0
        if not a_str or not b_str:
            return 0.0

        return SequenceMatcher(None, a_str, b_str).ratio()

    @staticmethod
    def _extract_ids_from_json(body: str) -> list[str]:
        """Extract resource IDs from JSON response body."""
        ids: list[str] = []
        try:
            data = json.loads(body)
        except (json.JSONDecodeError, TypeError):
            return ids

        def _walk(obj: Any, depth: int = 0) -> None:
            if depth > 5:
                return
            if isinstance(obj, dict):
                for key, val in obj.items():
                    if _ID_FIELD_RE.match(key) and val is not None:
                        val_str = str(val)
                        if val_str and val_str not in ids and len(val_str) < 100:
                            ids.append(val_str)
                    elif isinstance(val, (dict, list)):
                        _walk(val, depth + 1)
            elif isinstance(obj, list):
                for item in obj[:10]:
                    _walk(item, depth + 1)

        _walk(data)
        return ids

    @staticmethod
    def _looks_like_uuid(value: str) -> bool:
        """Check if value looks like a UUID."""
        return bool(re.match(
            r"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
            value, re.IGNORECASE,
        ))
