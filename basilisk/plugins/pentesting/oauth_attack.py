"""OAuth/OIDC security checks — comprehensive flow attack detection.

Tests for:
1. redirect_uri manipulation (open redirect, path traversal, parameter pollution)
2. Missing state parameter (CSRF on OAuth flow)
3. PKCE absence / bypass (authorization code interception)
4. Scope escalation (requesting elevated permissions)
5. Token in URL fragment (implicit flow risks, Referer leakage)
6. Client ID enumeration via error message differences
7. Token endpoint misconfiguration (grant type abuse)
8. OIDC configuration analysis (deprecated flows, HTTP endpoints)
9. response_type confusion (mixing code and token)
"""

from __future__ import annotations

import json
from typing import ClassVar
from urllib.parse import parse_qs, urlencode, urlparse

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# OAuth/OIDC discovery paths (ordered by likelihood)
DISCOVERY_PATHS = [
    "/.well-known/openid-configuration",
    "/.well-known/oauth-authorization-server",
    "/oauth/authorize",
    "/oauth2/authorize",
    "/auth/realms/master/.well-known/openid-configuration",
    "/auth/realms/master",
    "/.auth/login",
    "/authorize",
    "/connect/authorize",
    "/adfs/.well-known/openid-configuration",
    "/oauth/.well-known/openid-configuration",
    "/v1/.well-known/openid-configuration",
    "/v2/.well-known/openid-configuration",
    "/.well-known/openid-configuration/",
]

# redirect_uri manipulation payloads: (payload_template, type, description)
# {legit} is replaced with the legitimate callback URL
REDIRECT_PAYLOADS: list[tuple[str, str, str]] = [
    # Open redirect — completely attacker-controlled
    ("https://evil.com", "open_redirect",
     "Arbitrary external redirect_uri accepted"),
    ("//evil.com", "open_redirect_schemeless",
     "Protocol-relative redirect to attacker domain"),
    ("https://evil.com%23", "fragment_bypass",
     "URL fragment encoding bypass in redirect_uri"),

    # Path traversal on legitimate domain
    ("{legit}/../../../evil", "path_traversal",
     "Path traversal in redirect_uri may escape callback path"),
    ("{legit}/../../../../", "path_traversal_root",
     "Deep path traversal to reach root of callback domain"),

    # Parameter pollution — appending to legitimate URI
    ("{legit}?evil=true", "param_append",
     "Parameter appended to redirect_uri — data may leak via query string"),
    ("{legit}%26evil%3Dtrue", "param_pollution_encoded",
     "URL-encoded parameter pollution in redirect_uri"),
    ("{legit}@evil.com", "at_sign_bypass",
     "@ character in URI may redirect to attacker-controlled host"),

    # Subdomain/domain confusion
    ("https://evil.com%2F{host}%2Fcallback", "domain_confusion",
     "Encoded slashes cause domain confusion in redirect_uri parser"),
    ("https://{host}.evil.com/callback", "subdomain_takeover",
     "Target host as subdomain of attacker domain"),

    # Localhost/internal redirect
    ("http://localhost/callback", "localhost_redirect",
     "Redirect to localhost may expose tokens to local services"),
    ("http://127.0.0.1/callback", "loopback_redirect",
     "Redirect to loopback address may expose tokens"),
]

# Scope escalation payloads
SCOPE_ESCALATION = [
    "openid profile email admin",
    "openid profile email offline_access",
    "openid profile email write",
    "openid profile email user:admin",
    "openid profile email *",
    "openid profile email read write delete admin",
]

# Common client IDs to enumerate
COMMON_CLIENT_IDS = [
    "test", "dev", "admin", "api", "mobile", "web",
    "client", "app", "frontend", "backend", "internal",
    "default", "public", "service",
]


class OauthAttackPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="oauth_attack",
        display_name="OAuth/OIDC Security Checks",
        category=PluginCategory.PENTESTING,
        description=(
            "Comprehensive OAuth/OIDC security testing: redirect_uri manipulation, "
            "missing state/PKCE, scope escalation, implicit flow risks, "
            "client enumeration, token endpoint abuse"
        ),
        produces=["oauth_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        oauth_data: dict = {
            "discovery": {},
            "vulnerabilities": [],
        }

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=oauth_data,
            )

        # Phase 1: OAuth/OIDC discovery
        oidc_config = await self._discover_oauth(ctx, base_url)
        if not oidc_config:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No OAuth/OIDC endpoints discovered",
                    tags=["pentesting", "oauth"],
                )],
                data=oauth_data,
            )

        oauth_data["discovery"] = {
            k: v for k, v in oidc_config.items() if not k.startswith("_")
        }

        auth_endpoint = oidc_config.get("authorization_endpoint", "")
        token_endpoint = oidc_config.get("token_endpoint", "")
        issuer = oidc_config.get("issuer", "")

        findings.append(Finding.info(
            f"OAuth/OIDC configuration discovered: {issuer or auth_endpoint}",
            evidence=(
                f"Authorization: {auth_endpoint}\n"
                f"Token: {token_endpoint}\n"
                f"Issuer: {issuer}\n"
                f"Discovery URL: {oidc_config.get('_discovery_url', 'N/A')}"
            ),
            tags=["pentesting", "oauth", "discovery"],
        ))

        # Derive legitimate callback URL from auth endpoint
        if auth_endpoint:
            auth_host = urlparse(auth_endpoint).netloc
            legit_callback = f"https://{auth_host}/callback"
        else:
            legit_callback = f"{base_url}/callback"

        # Phase 2: redirect_uri manipulation
        if auth_endpoint and not ctx.should_stop:
            redirect_vulns = await self._test_redirect_uri(
                ctx, auth_endpoint, target.host, legit_callback,
            )
            for vuln in redirect_vulns:
                oauth_data["vulnerabilities"].append(vuln)
                severity_fn = (
                    Finding.critical if vuln["type"] == "open_redirect"
                    else Finding.high
                )
                findings.append(severity_fn(
                    f"OAuth redirect_uri bypass: {vuln['type']}",
                    description=(
                        f"{vuln['description']}\n\n"
                        f"An attacker can steal authorization codes by redirecting "
                        f"the OAuth callback to a controlled domain. The server "
                        f"accepted redirect_uri={vuln['payload']}"
                    ),
                    evidence=(
                        f"Payload: {vuln['payload']}\n"
                        f"Response: HTTP {vuln['status']}\n"
                        f"Location: {vuln.get('location', 'N/A')}"
                    ),
                    remediation=(
                        "1. Validate redirect_uri with exact string matching.\n"
                        "2. Pre-register all allowed redirect URIs.\n"
                        "3. Do not allow wildcard or prefix matching.\n"
                        "4. Reject URIs with encoded characters (.., %2F, %23)."
                    ),
                    tags=["pentesting", "oauth", "redirect-uri", vuln["type"]],
                ))

        # Phase 3: Missing state parameter (CSRF)
        if auth_endpoint and not ctx.should_stop:
            csrf_vuln = await self._test_missing_state(
                ctx, auth_endpoint, legit_callback,
            )
            if csrf_vuln:
                oauth_data["vulnerabilities"].append(csrf_vuln)
                findings.append(Finding.high(
                    "OAuth CSRF: state parameter not enforced",
                    description=(
                        "The authorization endpoint processes requests without "
                        "a 'state' parameter. An attacker can craft a URL that "
                        "initiates an OAuth flow and force the victim to "
                        "authenticate, linking the attacker's account."
                    ),
                    evidence=(
                        f"HTTP {csrf_vuln['status']} without state parameter\n"
                        f"Server behavior: {csrf_vuln['behavior']}"
                    ),
                    remediation=(
                        "1. Require state parameter in all authorization requests.\n"
                        "2. Validate state is a cryptographically random value "
                        "bound to the user's session.\n"
                        "3. Reject requests without state."
                    ),
                    tags=["pentesting", "oauth", "csrf", "state"],
                ))

        # Phase 4: Implicit flow / token in fragment
        if auth_endpoint and not ctx.should_stop:
            implicit_vuln = await self._test_implicit_flow(
                ctx, auth_endpoint, legit_callback,
            )
            if implicit_vuln:
                oauth_data["vulnerabilities"].append(implicit_vuln)
                sev = (
                    Finding.high
                    if implicit_vuln.get("token_in_redirect")
                    else Finding.medium
                )
                findings.append(sev(
                    "OAuth implicit flow enabled — token leakage risk",
                    description=(
                        "The server supports response_type=token (implicit flow). "
                        "Access tokens are returned in URL fragments, which can "
                        "leak via Referer headers, browser history, or open "
                        "redirectors on the same domain."
                    ),
                    evidence=implicit_vuln.get("evidence", ""),
                    remediation=(
                        "1. Disable implicit flow (response_type=token).\n"
                        "2. Use authorization code flow with PKCE.\n"
                        "3. Set appropriate Referrer-Policy headers."
                    ),
                    tags=["pentesting", "oauth", "implicit-flow", "token-leak"],
                ))

        # Phase 5: response_type confusion
        if auth_endpoint and not ctx.should_stop:
            confusion_vuln = await self._test_response_type_confusion(
                ctx, auth_endpoint, legit_callback,
            )
            if confusion_vuln:
                oauth_data["vulnerabilities"].append(confusion_vuln)
                findings.append(Finding.medium(
                    "OAuth response_type confusion accepted",
                    description=(
                        f"Server accepts non-standard response_type values: "
                        f"{confusion_vuln['accepted_types']}. This may allow "
                        "downgrade from code flow to implicit flow."
                    ),
                    evidence=confusion_vuln.get("evidence", ""),
                    remediation=(
                        "Strictly validate response_type. Only allow explicitly "
                        "configured values (preferably only 'code')."
                    ),
                    tags=["pentesting", "oauth", "response-type"],
                ))

        # Phase 6: PKCE bypass
        if token_endpoint and not ctx.should_stop:
            pkce_vuln = await self._test_pkce_bypass(ctx, token_endpoint)
            if pkce_vuln:
                oauth_data["vulnerabilities"].append(pkce_vuln)
                findings.append(Finding.medium(
                    "PKCE not enforced — authorization code interception risk",
                    description=(
                        "The token endpoint accepts authorization codes without "
                        "code_verifier. An attacker who intercepts an authorization "
                        "code (via open redirect or malicious app) can exchange it "
                        "for tokens without proof of the original requester."
                    ),
                    evidence=pkce_vuln.get("evidence", ""),
                    remediation=(
                        "1. Enforce PKCE (RFC 7636) for all clients.\n"
                        "2. Require code_challenge in authorization requests.\n"
                        "3. Validate code_verifier at token exchange."
                    ),
                    tags=["pentesting", "oauth", "pkce"],
                ))

        # Phase 7: Scope escalation
        if auth_endpoint and not ctx.should_stop:
            scope_vulns = await self._test_scope_escalation(
                ctx, auth_endpoint, legit_callback,
            )
            for sv in scope_vulns:
                oauth_data["vulnerabilities"].append(sv)
                findings.append(Finding.high(
                    f"OAuth scope escalation: {sv['scope']}",
                    description=(
                        f"Authorization endpoint accepts elevated scope "
                        f"'{sv['scope']}' without error. This may grant "
                        "excessive permissions to the application."
                    ),
                    evidence=sv.get("evidence", ""),
                    remediation=(
                        "1. Validate requested scopes against client registration.\n"
                        "2. Reject unknown or elevated scopes.\n"
                        "3. Require explicit admin approval for privileged scopes."
                    ),
                    tags=["pentesting", "oauth", "scope-escalation"],
                ))

        # Phase 8: Client ID enumeration
        if auth_endpoint and not ctx.should_stop:
            enum_vuln = await self._test_client_enumeration(
                ctx, auth_endpoint, legit_callback,
            )
            if enum_vuln:
                oauth_data["vulnerabilities"].append(enum_vuln)
                findings.append(Finding.low(
                    "OAuth client ID enumeration via error differences",
                    description=(
                        "Authorization endpoint returns different error messages "
                        "for valid vs. invalid client IDs, enabling enumeration."
                    ),
                    evidence=(
                        f"Valid-like IDs: {enum_vuln.get('valid_candidates', [])}\n"
                        f"Differentiator: {enum_vuln.get('differentiator', '')}"
                    ),
                    remediation=(
                        "Return consistent error messages regardless of whether "
                        "a client_id exists."
                    ),
                    tags=["pentesting", "oauth", "enumeration"],
                ))

        # Phase 9: OIDC configuration security analysis
        if not ctx.should_stop:
            config_findings = self._analyze_oidc_config(oidc_config, issuer)
            findings.extend(config_findings)

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=oauth_data,
        )

    async def _discover_oauth(self, ctx, base_url: str) -> dict:
        """Try OIDC discovery paths and return the first valid configuration."""
        for path in DISCOVERY_PATHS:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        try:
                            data = json.loads(body)
                            if isinstance(data, dict) and (
                                "authorization_endpoint" in data
                                or "issuer" in data
                                or "token_endpoint" in data
                            ):
                                data["_discovery_url"] = url
                                return data
                        except (json.JSONDecodeError, ValueError):
                            pass

                    # Check for redirect to OAuth endpoint
                    if resp.status in (301, 302, 303, 307):
                        location = resp.headers.get("location", "")
                        if "authorize" in location.lower():
                            return {
                                "authorization_endpoint": location,
                                "_discovery_url": url,
                                "_redirect": True,
                            }
            except Exception:
                continue
        return {}

    async def _test_redirect_uri(
        self,
        ctx,
        auth_endpoint: str,
        target_host: str,
        legit_callback: str,
    ) -> list[dict]:
        """Test redirect_uri for various manipulation attacks."""
        vulns: list[dict] = []

        for payload_tmpl, vuln_type, description in REDIRECT_PAYLOADS:
            if ctx.should_stop or len(vulns) >= 3:
                break

            payload = payload_tmpl.replace(
                "{legit}", legit_callback,
            ).replace("{host}", target_host)

            params = urlencode({
                "response_type": "code",
                "client_id": "test",
                "redirect_uri": payload,
                "scope": "openid",
                "state": "basilisk_test",
            })
            url = f"{auth_endpoint}?{params}"

            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        url, timeout=8.0, allow_redirects=False,
                    )
                    location = resp.headers.get("location", "")
                    body = ""
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")

                    # Detect if the evil payload was accepted
                    is_vuln = False
                    evidence_location = ""

                    if resp.status in (301, 302, 303, 307, 308):
                        parsed_loc = urlparse(location)
                        loc_host = parsed_loc.netloc.lower()

                        # Check if redirected to evil domain
                        if "evil.com" in loc_host or "localhost" in loc_host:
                            is_vuln = True
                            evidence_location = location

                        # Check if code= parameter exists (token issued)
                        loc_params = parse_qs(parsed_loc.query)
                        if "code" in loc_params:
                            is_vuln = True
                            evidence_location = location[:100]

                    elif resp.status == 200 and body:
                        # Check if evil URI reflected in the consent page
                        if (
                            ("evil.com" in body or "localhost" in body)
                            and any(
                                marker in body.lower()
                                for marker in (
                                    "redirect", "callback", "evil.com",
                                    "localhost",
                                )
                            )
                        ):
                            is_vuln = True
                            evidence_location = "reflected in response body"

                    if is_vuln:
                        vulns.append({
                            "type": vuln_type,
                            "payload": payload,
                            "status": resp.status,
                            "location": evidence_location,
                            "description": description,
                        })

            except Exception:
                continue

        return vulns

    async def _test_missing_state(
        self, ctx, auth_endpoint: str, legit_callback: str,
    ) -> dict | None:
        """Test if OAuth flow works without state parameter (CSRF)."""
        # Request WITHOUT state
        params_no_state = urlencode({
            "response_type": "code",
            "client_id": "test",
            "redirect_uri": legit_callback,
            "scope": "openid",
        })

        # Request WITH state (baseline)
        params_with_state = urlencode({
            "response_type": "code",
            "client_id": "test",
            "redirect_uri": legit_callback,
            "scope": "openid",
            "state": "basilisk_csrf_test_12345",
        })

        try:
            async with ctx.rate:
                resp_no = await ctx.http.get(
                    f"{auth_endpoint}?{params_no_state}",
                    timeout=8.0, allow_redirects=False,
                )
            async with ctx.rate:
                resp_with = await ctx.http.get(
                    f"{auth_endpoint}?{params_with_state}",
                    timeout=8.0, allow_redirects=False,
                )

            # If both get similar responses, state is not required
            no_state_ok = resp_no.status in (200, 301, 302, 303, 307)
            with_state_ok = resp_with.status in (200, 301, 302, 303, 307)

            if no_state_ok and with_state_ok:
                # Check that state is not required by comparing response patterns
                no_body = await resp_no.text(encoding="utf-8", errors="replace")
                if "state" not in no_body.lower() or "error" not in no_body.lower():
                    behavior = "proceeds normally"
                    if resp_no.status in (301, 302, 303, 307):
                        loc = resp_no.headers.get("location", "")
                        behavior = f"redirects to {loc[:80]}"
                    return {
                        "type": "missing_state",
                        "status": resp_no.status,
                        "behavior": behavior,
                    }

            # If no-state gets an error but with-state works, state IS enforced
            if not no_state_ok and with_state_ok:
                return None

        except Exception:
            pass
        return None

    async def _test_implicit_flow(
        self, ctx, auth_endpoint: str, legit_callback: str,
    ) -> dict | None:
        """Test if implicit flow is enabled (tokens in URL fragments)."""
        # Test response_type=token
        for resp_type in ("token", "id_token token", "token id_token"):
            if ctx.should_stop:
                break

            params = urlencode({
                "response_type": resp_type,
                "client_id": "test",
                "redirect_uri": legit_callback,
                "scope": "openid",
                "state": "test",
                "nonce": "basilisk_nonce",
            })
            url = f"{auth_endpoint}?{params}"

            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        url, timeout=8.0, allow_redirects=False,
                    )
                    location = resp.headers.get("location", "")

                    # Token directly in redirect fragment
                    if "access_token=" in location or "id_token=" in location:
                        return {
                            "type": "implicit_flow_token_leak",
                            "response_type": resp_type,
                            "token_in_redirect": True,
                            "evidence": (
                                f"response_type={resp_type} -> "
                                f"token in redirect: {location[:120]}"
                            ),
                        }

                    # Server accepts the request (200 = consent page, 302 = redirect)
                    if resp.status in (200, 302, 303, 307):
                        body = ""
                        if resp.status == 200:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )

                        # Check it's not an error response
                        is_error = any(
                            err in (body + location).lower()
                            for err in (
                                "unsupported_response_type", "invalid_request",
                                "unauthorized_client",
                            )
                        )
                        if not is_error:
                            return {
                                "type": "implicit_flow_supported",
                                "response_type": resp_type,
                                "token_in_redirect": False,
                                "evidence": (
                                    f"response_type={resp_type} accepted "
                                    f"(HTTP {resp.status})"
                                ),
                            }
            except Exception:
                continue

        return None

    async def _test_response_type_confusion(
        self, ctx, auth_endpoint: str, legit_callback: str,
    ) -> dict | None:
        """Test for response_type confusion/downgrade attacks."""
        non_standard_types = [
            "code token",  # Hybrid flow
            "code id_token",
            "code id_token token",
            "none",  # Silent auth
        ]
        accepted: list[str] = []

        for resp_type in non_standard_types:
            if ctx.should_stop:
                break
            params = urlencode({
                "response_type": resp_type,
                "client_id": "test",
                "redirect_uri": legit_callback,
                "scope": "openid",
                "state": "test",
            })
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{auth_endpoint}?{params}",
                        timeout=8.0, allow_redirects=False,
                    )
                    if resp.status in (200, 302, 303, 307):
                        body = ""
                        if resp.status == 200:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                        loc = resp.headers.get("location", "")
                        is_error = "unsupported" in (body + loc).lower()
                        if not is_error:
                            accepted.append(resp_type)
            except Exception:
                continue

        if accepted:
            return {
                "type": "response_type_confusion",
                "accepted_types": accepted,
                "evidence": (
                    f"Non-standard response_type values accepted: "
                    f"{', '.join(accepted)}"
                ),
            }
        return None

    async def _test_pkce_bypass(
        self, ctx, token_endpoint: str,
    ) -> dict | None:
        """Test if token endpoint accepts codes without code_verifier (PKCE bypass)."""
        # Send a token request without code_verifier
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    token_endpoint,
                    data=urlencode({
                        "grant_type": "authorization_code",
                        "code": "test_code_basilisk",
                        "redirect_uri": "https://example.com/callback",
                        "client_id": "test",
                    }),
                    headers={
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    timeout=8.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")

                # Parse the error response
                try:
                    error_data = json.loads(body)
                    error = error_data.get("error", "")
                    error_desc = error_data.get("error_description", "")
                except (json.JSONDecodeError, ValueError):
                    error = ""
                    error_desc = body[:200]

                # If the error is about the code being invalid (not about
                # missing code_verifier), PKCE is not enforced
                pkce_keywords = (
                    "code_verifier", "code_challenge", "pkce",
                    "proof key", "code verifier",
                )
                requires_pkce = any(
                    kw in (error + error_desc).lower() for kw in pkce_keywords
                )

                if not requires_pkce and resp.status in (400, 401, 403):
                    # Error is about something else (invalid code, client, etc.)
                    return {
                        "type": "pkce_not_enforced",
                        "evidence": (
                            f"Token endpoint error (HTTP {resp.status}): "
                            f"{error}: {error_desc[:150]}. "
                            "No mention of code_verifier requirement."
                        ),
                    }

                # If endpoint is reachable but not standard error format
                if resp.status == 200:
                    return {
                        "type": "pkce_not_enforced",
                        "evidence": (
                            "Token endpoint returned 200 without code_verifier. "
                            f"Response: {body[:150]}"
                        ),
                    }

        except Exception:
            pass
        return None

    async def _test_scope_escalation(
        self, ctx, auth_endpoint: str, legit_callback: str,
    ) -> list[dict]:
        """Test if elevated scopes are accepted without error."""
        vulns: list[dict] = []

        # First: get baseline with minimal scope
        baseline_status = 0
        try:
            async with ctx.rate:
                params = urlencode({
                    "response_type": "code",
                    "client_id": "test",
                    "redirect_uri": legit_callback,
                    "scope": "openid",
                    "state": "test",
                })
                base_resp = await ctx.http.get(
                    f"{auth_endpoint}?{params}",
                    timeout=8.0, allow_redirects=False,
                )
                baseline_status = base_resp.status
        except Exception:
            return vulns

        for scope in SCOPE_ESCALATION:
            if ctx.should_stop or len(vulns) >= 2:
                break
            params = urlencode({
                "response_type": "code",
                "client_id": "test",
                "redirect_uri": legit_callback,
                "scope": scope,
                "state": "test",
            })
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{auth_endpoint}?{params}",
                        timeout=8.0, allow_redirects=False,
                    )
                    # If server accepts elevated scope similarly to baseline
                    if resp.status == baseline_status and resp.status in (
                        200, 302, 303, 307,
                    ):
                        body = ""
                        if resp.status == 200:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                        loc = resp.headers.get("location", "")
                        combined = (body + loc).lower()
                        is_error = any(
                            err in combined
                            for err in ("invalid_scope", "scope", "error")
                        )
                        if not is_error:
                            vulns.append({
                                "type": "scope_escalation",
                                "scope": scope,
                                "evidence": (
                                    f"scope={scope} accepted "
                                    f"(HTTP {resp.status})"
                                ),
                            })
            except Exception:
                continue

        return vulns

    async def _test_client_enumeration(
        self, ctx, auth_endpoint: str, legit_callback: str,
    ) -> dict | None:
        """Test for client_id enumeration via error message differences."""
        responses: dict[str, tuple[int, str]] = {}

        # Use a clearly invalid client ID as baseline
        invalid_id = "basilisk_nonexistent_client_xyz_999"
        params = urlencode({
            "response_type": "code",
            "client_id": invalid_id,
            "redirect_uri": legit_callback,
            "scope": "openid",
            "state": "test",
        })
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    f"{auth_endpoint}?{params}",
                    timeout=8.0, allow_redirects=False,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                responses[invalid_id] = (resp.status, body[:300])
        except Exception:
            return None

        # Test common client IDs
        for client_id in COMMON_CLIENT_IDS:
            if ctx.should_stop:
                break
            params = urlencode({
                "response_type": "code",
                "client_id": client_id,
                "redirect_uri": legit_callback,
                "scope": "openid",
                "state": "test",
            })
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{auth_endpoint}?{params}",
                        timeout=8.0, allow_redirects=False,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    responses[client_id] = (resp.status, body[:300])
            except Exception:
                continue

        if len(responses) < 3:
            return None

        # Compare responses to find differences
        baseline = responses.get(invalid_id)
        if not baseline:
            return None

        valid_candidates = []
        for cid, (status, body) in responses.items():
            if cid == invalid_id:
                continue
            # Different status or significantly different body length
            if (
                status != baseline[0]
                or abs(len(body) - len(baseline[1])) > 50
            ):
                valid_candidates.append(cid)

        if valid_candidates:
            return {
                "type": "client_enumeration",
                "valid_candidates": valid_candidates,
                "differentiator": (
                    f"Status or body length differs from invalid client baseline "
                    f"(HTTP {baseline[0]}, {len(baseline[1])} chars)"
                ),
            }

        return None

    @staticmethod
    def _analyze_oidc_config(config: dict, issuer: str) -> list[Finding]:
        """Deep analysis of OIDC configuration for security issues."""
        findings: list[Finding] = []

        # Grant types analysis
        grant_types = config.get("grant_types_supported", [])
        if "implicit" in grant_types:
            findings.append(Finding.medium(
                "OIDC config: implicit grant type enabled",
                description=(
                    "Implicit flow (grant_types_supported: implicit) is deprecated "
                    "by OAuth 2.1. Tokens returned in URL fragments can leak via "
                    "Referer headers and browser history."
                ),
                evidence=f"grant_types_supported: {grant_types}",
                remediation="Disable implicit grant. Use authorization code + PKCE.",
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        if "password" in grant_types:
            findings.append(Finding.medium(
                "OIDC config: resource owner password grant enabled",
                description=(
                    "Password grant (ROPC) requires the client to handle user "
                    "credentials directly, violating OAuth's security model."
                ),
                evidence="grant_types_supported includes 'password'",
                remediation="Disable password grant type.",
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        if "client_credentials" in grant_types and "implicit" in grant_types:
            findings.append(Finding.medium(
                "OIDC config: both client_credentials and implicit enabled",
                description=(
                    "Server supports both machine-to-machine and browser-based "
                    "flows, increasing attack surface."
                ),
                evidence=f"grant_types_supported: {grant_types}",
                remediation="Limit grant types to what clients actually need.",
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        # Response types analysis
        response_types = config.get("response_types_supported", [])
        dangerous_types = {"token", "id_token token", "code token"}
        if dangerous_types & set(response_types):
            findings.append(Finding.medium(
                "OIDC config: token-bearing response types enabled",
                description=(
                    "Response types that return tokens directly are enabled. "
                    "These are vulnerable to token leakage."
                ),
                evidence=f"response_types_supported: {response_types}",
                remediation="Only allow response_type=code.",
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        # HTTP endpoint check (should all be HTTPS)
        for key in (
            "authorization_endpoint", "token_endpoint",
            "userinfo_endpoint", "jwks_uri",
            "registration_endpoint", "revocation_endpoint",
            "introspection_endpoint", "end_session_endpoint",
        ):
            ep = config.get(key, "")
            if ep.startswith("http://"):
                findings.append(Finding.high(
                    f"OIDC config: {key} uses HTTP",
                    description=(
                        f"Endpoint {ep} uses unencrypted HTTP. "
                        "Tokens and credentials can be intercepted."
                    ),
                    evidence=f"{key}: {ep}",
                    remediation="Use HTTPS for all OAuth/OIDC endpoints.",
                    tags=["pentesting", "oauth", "oidc-config", "http"],
                ))

        # PKCE support check
        code_challenge_methods = config.get(
            "code_challenge_methods_supported", [],
        )
        if not code_challenge_methods:
            findings.append(Finding.low(
                "OIDC config: PKCE not advertised",
                description=(
                    "The OIDC configuration does not list "
                    "code_challenge_methods_supported. PKCE may not be supported."
                ),
                evidence="code_challenge_methods_supported: not present",
                remediation="Enable and enforce PKCE (S256 method).",
                tags=["pentesting", "oauth", "oidc-config", "pkce"],
            ))
        elif "plain" in code_challenge_methods and "S256" in code_challenge_methods:
            findings.append(Finding.low(
                "OIDC config: PKCE 'plain' method allowed",
                description=(
                    "'plain' code_challenge_method provides no security benefit. "
                    "Only S256 should be used."
                ),
                evidence=(
                    f"code_challenge_methods_supported: {code_challenge_methods}"
                ),
                remediation="Only allow S256 code challenge method.",
                tags=["pentesting", "oauth", "oidc-config", "pkce"],
            ))

        # Token endpoint auth methods
        token_auth = config.get(
            "token_endpoint_auth_methods_supported", [],
        )
        if "none" in token_auth:
            findings.append(Finding.medium(
                "OIDC config: unauthenticated token endpoint access",
                description=(
                    "Token endpoint allows 'none' authentication method. "
                    "Public clients may exchange codes without client authentication."
                ),
                evidence=(
                    f"token_endpoint_auth_methods_supported: {token_auth}"
                ),
                remediation=(
                    "Require client authentication (client_secret_post or "
                    "private_key_jwt) unless public client with PKCE."
                ),
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        # Issuer mismatch check
        config_issuer = config.get("issuer", "")
        if config_issuer and issuer and config_issuer != issuer:
            findings.append(Finding.medium(
                "OIDC config: issuer mismatch",
                description=(
                    f"Issuer in config ({config_issuer}) does not match "
                    f"expected issuer ({issuer}). This may indicate a "
                    "misconfiguration or issuer confusion attack."
                ),
                evidence=f"Expected: {issuer}, Got: {config_issuer}",
                remediation="Ensure issuer is consistent across all endpoints.",
                tags=["pentesting", "oauth", "oidc-config"],
            ))

        return findings
