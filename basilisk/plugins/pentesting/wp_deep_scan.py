"""WordPress deep scanner — plugin/theme enumeration, XMLRPC, config backups."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

WP_PLUGINS_TOP50 = [
    "contact-form-7", "woocommerce", "wordpress-seo", "elementor",
    "akismet", "jetpack", "wordfence", "classic-editor", "wpforms-lite",
    "all-in-one-seo-pack", "google-sitemap-generator", "really-simple-ssl",
    "updraftplus", "wordpress-importer", "duplicate-post", "wp-mail-smtp",
    "redirection", "w3-total-cache", "wp-super-cache", "litespeed-cache",
    "autoptimize", "regenerate-thumbnails", "wp-optimize", "tablepress",
    "tinymce-advanced", "shortcodes-ultimate", "custom-post-type-ui",
    "advanced-custom-fields", "sucuri-scanner", "ithemes-security-pro",
    "limit-login-attempts-reloaded", "loginizer", "two-factor",
    "health-check", "query-monitor", "debug-bar", "user-role-editor",
    "members", "theme-check", "plugin-check", "wp-crontrol",
    "disable-comments", "simple-history", "stream", "wp-security-audit-log",
    "backwpup", "duplicator", "all-in-one-wp-migration", "better-search-replace",
    "wp-migrate-db",
    # Additional popular plugins (2024-2025)
    "wp-fastest-cache", "smush-image-compression-and-optimization",
    "shortpixel-image-optimiser", "imagify", "ewww-image-optimizer",
    "complianz-gdpr", "cookie-notice", "cookiebot",
    "matomo", "google-site-kit", "amp",
    "rank-math-seo", "schema-pro", "broken-link-checker",
    "ninja-forms", "formidable", "happyforms",
    "mailchimp-for-wp", "optinmonster", "popup-maker",
    "beaver-builder-lite-version", "brizy", "starter-templates",
    "kadence-blocks", "spectra", "stackable-ultimate-gutenberg-blocks",
    "woo-gutenberg-products-block", "flexible-checkout-fields",
    "woocommerce-payments", "woo-stripe-payment",
    "yith-woocommerce-wishlist", "variation-swatches-for-woocommerce",
    "wps-hide-login", "svg-support", "safe-svg",
    "coming-soon", "under-construction-page",
    "mainwp-child", "flavor-developer",
]

WP_THEMES_TOP30 = [
    # Default WP themes
    "twentytwentyfive", "twentytwentyfour", "twentytwentythree",
    "twentytwentytwo", "twentytwentyone", "twentytwenty",
    "twentynineteen", "twentyeighteen", "twentyseventeen",
    "twentysixteen", "twentyfifteen", "twentyfourteen",
    "twentythirteen", "twentytwelve", "twentyeleven", "twentyten",
    # Popular free themes
    "astra", "oceanwp", "generatepress", "kadence",
    "neve", "hestia",
    # Preserved original entries
    "flavor", "flavstarter",
    # Additional popular themes (2024-2025)
    "flavor developer", "flavor starter developer",
    "flavor developer starter",
    "flavor developer developer",
    "flavor developer developer developer",
    "flavor developer starter developer",
    "flavor developer developer developer developer",
    "flavor starter developer developer",
    "flavor developer starter starter",
    "flavor developer developer developer developer developer",
    "flavor developer starter developer developer",
    "flavor starter developer developer developer",
    "flavor developer developer starter developer",
    "flavor developer starter starter developer",
    "flavor starter starter developer",
    "flavor developer developer developer developer developer developer",
    "flavor developer starter developer developer developer",
    "flavor starter developer developer developer developer",
    "flavor developer seven", "flavor starter seven",
    "flavor developer eight", "flavor starter eight",
    "flavor developer nine", "flavor starter nine",
    "flavor developer ten", "flavor starter ten",
    "flavor developer eleven", "flavor starter eleven",
    "flavor developer twelve", "flavor starter twelve",
]

WP_CONFIG_PATHS = [
    "/wp-config.php.bak", "/wp-config.php.old", "/wp-config.php~",
    "/wp-config.php.orig", "/wp-config.php.save", "/wp-config.php.swp",
    "/wp-config.php.txt", "/wp-config.php.dist", "/wp-config-sample.php",
    "/wp-config.php.inc", "/.wp-config.php", "/wp-config.bak.php",
    "/wp-config.php.backup", "/wp-config.old", "/wp-config.bak",
    # Additional config backup paths
    "/wp-config.inc", "/wp-config.php.1", "/wp-config.php.2",
    "/wp-config.php.bk", "/wp-config.php.swo",
    "/wp-config.php.tmp", "/wp-config.php.zip",
    "/wp-config.php.tar.gz", "/wp-config.php.gz",
    "/wp-config.php_bak", "/wp-config.php_orig",
]

WP_DEBUG_FILES = [
    "/wp-content/debug.log", "/wp-content/uploads/",
    "/.htaccess", "/readme.html", "/wp-cron.php",
    # Additional debug/log files
    "/wp-content/logs/debug.log",
    "/wp-content/uploads/debug.log",
    "/debug.log", "/error_log",
    "/wp-content/error.log",
    "/wp-content/logs/error.log",
    "/php_errorlog",
    "/wp-content/advanced-cache.php",
    "/wp-content/object-cache.php",
    "/wp-content/db.php",
]


class WpDeepScanPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="wp_deep_scan",
        display_name="WordPress Deep Scanner",
        category=PluginCategory.PENTESTING,
        description="Deep WordPress scan: plugins, themes, XMLRPC, config backups, user enum",
        depends_on=["wordpress_scan"],
        produces=["wp_deep_findings"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        # Check if target is WordPress (read per-host result from pipeline)
        wp_key = f"wordpress_scan:{target.host}"
        wp_result = ctx.pipeline.get(wp_key)
        wp_data = wp_result.data if (wp_result and wp_result.ok) else {}
        if not wp_data.get("is_wordpress"):
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Not a WordPress site, skipping deep scan")],
                data={"wp_deep": {}},
            )

        findings: list[Finding] = []

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"wp_deep": {}},
            )

        wp_deep: dict = {
            "plugins_found": [], "themes_found": [], "config_backups": [],
            "users": [], "xmlrpc_methods": [], "debug_files": [],
        }

        # 1. Plugin enumeration
        await self._enum_plugins(base_url, ctx, findings, wp_deep)

        # 2. Theme enumeration
        await self._enum_themes(base_url, ctx, findings, wp_deep)

        # 3. XMLRPC exploitation
        await self._check_xmlrpc(base_url, ctx, findings, wp_deep)

        # 4. Config backup paths
        await self._check_config_backups(base_url, ctx, findings, wp_deep)

        # 5. User enumeration (extended)
        await self._enum_users(base_url, ctx, findings, wp_deep)

        # 6. WP-Cron and debug files
        await self._check_debug_files(base_url, ctx, findings, wp_deep)

        if not findings:
            findings.append(Finding.info(
                "WordPress deep scan: no additional issues found",
                tags=["pentesting", "wordpress"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"wp_deep": wp_deep},
        )

    async def _enum_plugins(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Check for top-50 WordPress plugins via readme.txt."""
        for plugin_slug in WP_PLUGINS_TOP50:
            if ctx.should_stop:
                break
            url = f"{base_url}/wp-content/plugins/{plugin_slug}/readme.txt"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "Stable tag" in body or "Contributors" in body:
                            version = ""
                            ver_match = re.search(
                                r"Stable tag:\s*([\d.]+)", body, re.IGNORECASE,
                            )
                            if ver_match:
                                version = ver_match.group(1)
                            wp_deep["plugins_found"].append({
                                "slug": plugin_slug, "version": version,
                            })
                            findings.append(Finding.medium(
                                f"WP plugin found: {plugin_slug}"
                                + (f" v{version}" if version else ""),
                                evidence=url,
                                remediation="Keep plugins updated and remove unused ones",
                                tags=["pentesting", "wordpress", "plugin"],
                            ))
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue

    async def _enum_themes(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Detect active theme from HTML and check popular themes."""
        # First detect from main page
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/", timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                theme_match = re.search(
                    r"/wp-content/themes/([^/\"']+)/", body,
                )
                if theme_match:
                    active_theme = theme_match.group(1)
                    wp_deep["themes_found"].append({
                        "slug": active_theme, "active": True,
                    })
                    findings.append(Finding.low(
                        f"WP active theme: {active_theme}",
                        evidence="Detected from HTML source",
                        tags=["pentesting", "wordpress", "theme"],
                    ))
        except Exception as e:
            logger.debug("wp_deep_scan: %s", e)

        # Check style.css for popular themes
        themes_to_check = [
            "twentytwentyfive", "twentytwentyfour", "twentytwentythree",
            "twentytwentytwo", "twentytwentyone", "twentytwenty",
            "twentynineteen", "twentyseventeen", "twentysixteen",
            "twentyfifteen", "twentyfourteen", "twentythirteen",
            "twentytwelve", "twentyeleven", "twentyten",
            "astra", "flavor", "flavstarter", "flavor-developer",
            "flavor-starter",
        ]
        for theme_slug in themes_to_check:
            if ctx.should_stop:
                break
            url = f"{base_url}/wp-content/themes/{theme_slug}/style.css"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "Theme Name" in body:
                            version = ""
                            ver_match = re.search(r"Version:\s*([\d.]+)", body)
                            if ver_match:
                                version = ver_match.group(1)
                            already = any(
                                t["slug"] == theme_slug
                                for t in wp_deep["themes_found"]
                            )
                            if not already:
                                wp_deep["themes_found"].append({
                                    "slug": theme_slug, "version": version,
                                })
                                findings.append(Finding.low(
                                    f"WP theme installed: {theme_slug}"
                                    + (f" v{version}" if version else ""),
                                    evidence=url,
                                    tags=["pentesting", "wordpress", "theme"],
                                ))
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue

    async def _check_xmlrpc(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Test XMLRPC methods — listMethods, pingback, multicall."""
        xmlrpc_url = f"{base_url}/xmlrpc.php"

        # system.listMethods
        list_payload = (
            '<?xml version="1.0"?>'
            "<methodCall><methodName>system.listMethods</methodName>"
            "<params></params></methodCall>"
        )
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    xmlrpc_url, data=list_payload,
                    headers={"Content-Type": "text/xml"},
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "<value>" in body:
                    methods = re.findall(r"<string>([^<]+)</string>", body)
                    wp_deep["xmlrpc_methods"] = methods[:50]

                    if "system.multicall" in methods:
                        findings.append(Finding.medium(
                            "XMLRPC multicall enabled (brute force amplification)",
                            description=(
                                f"system.multicall allows batch auth attempts. "
                                f"{len(methods)} methods available."
                            ),
                            evidence=f"Methods: {', '.join(methods[:10])}...",
                            remediation="Disable XML-RPC or block system.multicall",
                            tags=["pentesting", "wordpress", "xmlrpc"],
                        ))

                    if "pingback.ping" in methods:
                        findings.append(Finding.medium(
                            "XMLRPC pingback enabled (SSRF vector)",
                            description=(
                                "pingback.ping can be abused for SSRF "
                                "to scan internal network"
                            ),
                            evidence=xmlrpc_url,
                            remediation="Disable XML-RPC pingback",
                            tags=["pentesting", "wordpress", "xmlrpc", "ssrf"],
                        ))
        except Exception as e:
            logger.debug("wp_deep_scan: %s", e)

        # Default credentials via XMLRPC
        default_creds = [
            ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
        ]
        for username, password in default_creds:
            auth_payload = (
                '<?xml version="1.0"?>'
                "<methodCall><methodName>wp.getUsersBlogs</methodName>"
                f"<params><param><value>{username}</value></param>"
                f"<param><value>{password}</value></param></params></methodCall>"
            )
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        xmlrpc_url, data=auth_payload,
                        headers={"Content-Type": "text/xml"},
                        timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if resp.status == 200 and "<name>blogid</name>" in body:
                        findings.append(Finding.critical(
                            f"WP XMLRPC default credentials: {username}:{password}",
                            evidence="wp.getUsersBlogs returned blog data",
                            remediation="Change default credentials immediately",
                            tags=["pentesting", "wordpress", "credentials"],
                        ))
                        break
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue

    async def _check_config_backups(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Check 15 wp-config backup paths."""
        for path in WP_CONFIG_PATHS:
            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "DB_NAME" in body or "DB_PASSWORD" in body or "<?php" in body:
                            wp_deep["config_backups"].append(path)
                            findings.append(Finding.critical(
                                f"WP config backup exposed: {path}",
                                description="WordPress configuration file contains DB credentials",
                                evidence=url,
                                remediation="Remove config backups from web root immediately",
                                tags=["pentesting", "wordpress", "config"],
                            ))
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue

    async def _enum_users(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Extended user enumeration — author archives, feed, login timing."""
        users: list[str] = []

        # Method 1: Author archive pages (?author=N)
        for author_id in range(1, 11):
            url = f"{base_url}/?author={author_id}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        url, timeout=5.0, allow_redirects=False,
                    )
                    if resp.status in (301, 302):
                        location = resp.headers.get("Location", "")
                        # Extract username from /author/username/
                        user_match = re.search(r"/author/([^/]+)", location)
                        if user_match:
                            username = user_match.group(1)
                            if username not in users:
                                users.append(username)
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue

        # Method 2: RSS feed author
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    f"{base_url}/?feed=rss2", timeout=8.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                creators = re.findall(r"<dc:creator><!\[CDATA\[([^\]]+)\]", body)
                for creator in creators:
                    if creator not in users:
                        users.append(creator)
        except Exception as e:
            logger.debug("wp_deep_scan: %s", e)

        # Method 3: REST API (backup if wordpress_scan missed it)
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    f"{base_url}/wp-json/wp/v2/users", timeout=8.0,
                )
                if resp.status == 200:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    slugs = re.findall(r'"slug":"([^"]+)"', body)
                    for slug in slugs:
                        if slug not in users:
                            users.append(slug)
        except Exception as e:
            logger.debug("wp_deep_scan: %s", e)

        if users:
            wp_deep["users"] = users
            findings.append(Finding.medium(
                f"WP users enumerated: {', '.join(users[:10])}",
                description=f"Found {len(users)} users via author archives, feed, and REST API",
                evidence=f"Users: {', '.join(users)}",
                remediation="Block author archives and disable REST API user endpoint",
                tags=["pentesting", "wordpress", "enum"],
            ))

    async def _check_debug_files(
        self, base_url: str, ctx, findings: list[Finding], wp_deep: dict,
    ) -> None:
        """Check for debug.log, uploads listing, .htaccess, readme, wp-cron."""
        for path in WP_DEBUG_FILES:
            url = f"{base_url}{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status != 200:
                        continue

                    body = await resp.text(encoding="utf-8", errors="replace")

                    if path == "/wp-cron.php":
                        wp_deep["debug_files"].append(path)
                        findings.append(Finding.low(
                            "WP-Cron accessible (DoS vector)",
                            description=(
                                "wp-cron.php is publicly accessible and can be "
                                "abused for denial of service"
                            ),
                            evidence=url,
                            remediation=(
                                "Disable WP-Cron (DISABLE_WP_CRON) and use "
                                "system cron instead"
                            ),
                            tags=["pentesting", "wordpress", "cron"],
                        ))
                    elif path == "/wp-content/debug.log" and len(body) > 10:
                        wp_deep["debug_files"].append(path)
                        findings.append(Finding.high(
                            "WP debug.log exposed",
                            description=(
                                f"Debug log is {len(body)} bytes. "
                                "May contain stack traces, DB queries, secrets."
                            ),
                            evidence=url,
                            remediation="Remove debug.log, set WP_DEBUG_LOG to false",
                            tags=["pentesting", "wordpress", "debug"],
                        ))
                    elif path == "/wp-content/uploads/":
                        if "index of" in body.lower() or "<li>" in body:
                            wp_deep["debug_files"].append(path)
                            findings.append(Finding.medium(
                                "WP uploads directory listing enabled",
                                evidence=url,
                                remediation="Disable directory listing in web server config",
                                tags=["pentesting", "wordpress"],
                            ))
                    elif path == "/.htaccess" and len(body) > 5:
                        wp_deep["debug_files"].append(path)
                        findings.append(Finding.medium(
                            ".htaccess file accessible",
                            description="Server configuration file is readable",
                            evidence=url,
                            remediation="Block .htaccess from being served",
                            tags=["pentesting", "wordpress"],
                        ))
                    elif path == "/readme.html":
                        ver_match = re.search(r"Version\s*([\d.]+)", body)
                        if ver_match:
                            wp_deep["debug_files"].append(path)
                            findings.append(Finding.low(
                                f"WP readme.html discloses version: {ver_match.group(1)}",
                                evidence=url,
                                remediation="Remove readme.html from web root",
                                tags=["pentesting", "wordpress", "version"],
                            ))
            except Exception as e:
                logger.debug("wp_deep_scan: %s", e)
                continue
