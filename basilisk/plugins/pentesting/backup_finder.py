"""Backup file finder â€” discovers leftover archives and database dumps."""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target


class BackupFinderPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="backup_finder",
        display_name="Backup File Finder",
        category=PluginCategory.PENTESTING,
        description="Discovers backup files, archives, and database dumps",
        produces=["backup_files"],
        timeout=30.0,
    )

    def _generate_paths(self, host: str) -> list[str]:
        """Generate backup file paths based on the hostname."""
        name = host.split(".")[0]
        domain = host.replace(".", "_")

        extensions = [
            ".bak", ".backup", ".old", ".orig", ".save", ".swp", ".tmp",
            ".copy",
            ".zip", ".tar.gz", ".tar.bz2", ".tgz", ".7z", ".rar",
            ".gz", ".bz2", ".xz", ".cab",
            ".sql", ".sql.gz", ".sql.bz2", ".sql.zip", ".sql.xz",
            ".db", ".sqlite", ".sqlite3", ".mdb", ".accdb",
            ".dump", ".log",
        ]

        prefixes = [
            name, domain, host, "backup", "db", "database",
            "site", "www", "web", "dump", "data", "export",
            "archive", "old", "prod", "production", "staging",
            "dev", "test", "files", "content",
        ]

        paths: list[str] = []
        for prefix in prefixes:
            for ext in extensions:
                paths.append(f"{prefix}{ext}")

        paths.extend([
            "backup.zip", "backup.tar.gz", "site.zip",
            "db.sql", "database.sql", "dump.sql",
            "www.zip", "public_html.zip",
            "htdocs.zip", "wwwroot.zip",
            "mysql.sql", "postgres.sql",
            "full_backup.zip", "daily_backup.zip",
            "wp-content/backup.zip", "wp-content/debug.log",
            "storage/logs/laravel.log",
            "var/log/application.log",
        ])

        return list(dict.fromkeys(paths))  # Dedupe preserving order

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        base_url = ""
        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(
                        f"{scheme}://{target.host}/", timeout=5.0,
                    )
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="Host not reachable via HTTP(S)",
            )

        paths = self._generate_paths(target.host)
        findings: list[Finding] = []
        found: list[dict] = []

        for path in paths:
            url = f"{base_url}/{path}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.head(url, timeout=5.0)
                    if resp.status == 200:
                        cl = resp.headers.get("content-length", "0")
                        size = int(cl) if cl.isdigit() else 0

                        if size > 100:
                            found.append({
                                "path": path,
                                "url": url,
                                "size": size,
                            })
                            findings.append(Finding.high(
                                f"Backup file found: {path}",
                                description=(
                                    f"Potential backup file "
                                    f"({self._format_size(size)})"
                                ),
                                evidence=url,
                                remediation=(
                                    "Remove backup files from "
                                    "web-accessible directories"
                                ),
                                tags=["pentesting", "backup"],
                            ))
            except Exception:
                continue

        if not findings:
            findings.append(Finding.info(
                f"No backup files found ({len(paths)} paths checked)",
                tags=["pentesting", "backup"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"backup_files": found, "paths_checked": len(paths)},
        )

    @staticmethod
    def _format_size(size: int) -> str:
        for unit in ("B", "KB", "MB", "GB"):
            if size < 1024:
                return f"{size:.0f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"
