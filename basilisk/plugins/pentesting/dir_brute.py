"""Async directory bruteforcer â€” dirb/gobuster style."""

from __future__ import annotations

import asyncio
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target


class DirBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="dir_brute",
        display_name="Directory / API Bruteforce",
        category=PluginCategory.PENTESTING,
        description="Async directory/file/API bruteforce using configurable wordlists",
        default_enabled=False,
        timeout=300.0,
    )

    # Status codes indicating found resource
    FOUND_CODES = {200, 201, 204, 301, 302, 307, 308, 401, 403}

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        wordlist_names = ctx.state.get("wordlists", ["dirs_common"])
        words: list[str] = []
        try:
            if len(wordlist_names) == 1:
                words = await ctx.wordlists.get_all(wordlist_names[0])
            else:
                words = [w async for w in ctx.wordlists.merge(*wordlist_names)]
        except FileNotFoundError:
            return PluginResult.fail(
                self.meta.name, target.host,
                error=f"Wordlist '{wordlist_names}' not found",
            )

        base_url = f"https://{target.host}"
        # Verify base is reachable, fallback to HTTP
        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        found: list[dict] = []
        findings: list[Finding] = []
        sem = asyncio.Semaphore(ctx.config.scan.max_concurrency)

        # Detect SPA catch-all: if a random path returns 200, the server
        # serves the same page for every path, making brute results useless
        spa_status: int | None = None
        spa_length: int = 0
        try:
            async with ctx.rate:
                r = await ctx.http.get(
                    f"{base_url}/_nonexistent_8x7z_brute/", timeout=5.0,
                )
                spa_status = r.status
                if r.status == 200:
                    spa_body = await r.text(encoding="utf-8", errors="replace")
                    spa_length = len(spa_body)
        except Exception:
            pass

        async def check_path(path: str) -> dict | None:
            url = f"{base_url}/{path.lstrip('/')}"
            async with sem, ctx.rate:
                try:
                    resp = await ctx.http.get(url, timeout=5.0)
                    status = resp.status
                    if status in self.FOUND_CODES:
                        # Filter SPA catch-all: same status & similar body length
                        if (
                            spa_status == 200
                            and status == 200
                            and spa_length > 0
                        ):
                            cl = resp.headers.get("content-length", "")
                            rl = int(cl) if cl.isdigit() else 0
                            if rl and abs(rl - spa_length) < 100:
                                return None
                            # If no CL header, read body to compare
                            if not rl:
                                body = await resp.text(
                                    encoding="utf-8", errors="replace",
                                )
                                if abs(len(body) - spa_length) < 100:
                                    return None
                        return {
                            "url": url,
                            "path": path,
                            "status": status,
                        }
                except Exception:
                    pass
                return None

        tasks = [check_path(w) for w in words]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for r in results:
            if isinstance(r, dict):
                found.append(r)

        # Generate findings for interesting discoveries
        for item in found:
            status = item["status"]
            path = item["path"]

            if status in (200, 204):
                findings.append(Finding.medium(
                    f"Directory/file found: /{path} ({status})",
                    evidence=item["url"],
                    tags=["pentesting", "dir-brute"],
                ))
            elif status in (401, 403):
                findings.append(Finding.low(
                    f"Protected path: /{path} ({status})",
                    evidence=item["url"],
                    tags=["pentesting", "dir-brute"],
                ))
            elif status in (301, 302, 307, 308):
                findings.append(Finding.info(
                    f"Redirect: /{path} ({status})",
                    evidence=item["url"],
                    tags=["pentesting", "dir-brute"],
                ))

        findings.append(Finding.info(
            f"Dir brute: {len(found)}/{len(words)} paths found",
            tags=["pentesting", "dir-brute"],
        ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"found_paths": found, "total_checked": len(words)},
        )
