"""Port vulnerability check — fingerprints services and detects known vulnerabilities."""

from __future__ import annotations

import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Known vulnerability signatures.
# Each entry matches a service banner/version to a known CVE or weakness.
KNOWN_VULNS: list[dict] = [
    # --- SSH ---
    {
        "port": 22,
        "service_re": r"ssh",
        "banner_re": r"OpenSSH[_ ]([0-7]\.|8\.\d)",
        "name": "OpenSSH < 9.0 — agent forwarding RCE",
        "severity": "high",
        "cve": "CVE-2023-38408",
        "description": (
            "OpenSSH before 9.3p2 allows remote code execution via "
            "a crafted PKCS#11 provider in ssh-agent forwarding."
        ),
        "remediation": "Upgrade OpenSSH to 9.3p2 or later.",
    },
    # --- Apache ---
    {
        "port": 80,
        "service_re": r"apache",
        "banner_re": r"Apache/2\.4\.([0-4]\d|5[01])(\s|$)",
        "name": "Apache < 2.4.52 — mod_lua buffer overflow",
        "severity": "high",
        "cve": "CVE-2021-44790",
        "description": (
            "Apache HTTP Server 2.4.51 and earlier has a buffer "
            "overflow in mod_lua multipart parser."
        ),
        "remediation": "Upgrade Apache to 2.4.52 or later.",
    },
    # --- nginx ---
    {
        "port": None,
        "service_re": r"nginx",
        "banner_re": r"nginx/(0\.\d|1\.([0-9]|1\d|20)\.\d)",
        "name": "nginx vulnerable version detected",
        "severity": "medium",
        "cve": None,
        "description": (
            "Older nginx versions may be vulnerable to HTTP request "
            "smuggling, memory disclosure, or DoS attacks."
        ),
        "remediation": "Upgrade nginx to the latest stable release.",
    },
    # --- FTP anonymous ---
    {
        "port": 21,
        "service_re": r"ftp",
        "banner_re": r".",
        "name": "FTP service detected — anonymous access risk",
        "severity": "medium",
        "cve": None,
        "description": (
            "FTP transmits credentials in cleartext. "
            "Anonymous access may be enabled."
        ),
        "remediation": (
            "Disable FTP or switch to SFTP/FTPS. "
            "Disable anonymous login."
        ),
    },
    # --- Telnet ---
    {
        "port": 23,
        "service_re": r"telnet|^$",
        "banner_re": r".",
        "name": "Telnet service — unencrypted remote access",
        "severity": "high",
        "cve": None,
        "description": (
            "Telnet transmits all data including passwords in "
            "cleartext. This is a critical security weakness."
        ),
        "remediation": "Replace Telnet with SSH.",
    },
    # --- MySQL no-auth ---
    {
        "port": 3306,
        "service_re": r"mysql",
        "banner_re": r".",
        "name": "MySQL exposed — potential unauthenticated access",
        "severity": "medium",
        "cve": None,
        "description": (
            "MySQL port is open and exposed. If authentication "
            "is weak or absent, data may be compromised."
        ),
        "remediation": (
            "Restrict MySQL to localhost or VPN. "
            "Enforce strong authentication."
        ),
    },
    # --- SMB / EternalBlue ---
    {
        "port": 445,
        "service_re": r"smb|microsoft-ds|samba",
        "banner_re": r".",
        "name": "SMB exposed — EternalBlue risk",
        "severity": "high",
        "cve": "CVE-2017-0144",
        "description": (
            "SMB port 445 exposed. Unpatched Windows systems are "
            "vulnerable to EternalBlue (MS17-010) RCE."
        ),
        "remediation": (
            "Apply MS17-010 patches. Block SMB at the firewall. "
            "Disable SMBv1."
        ),
    },
    # --- RDP / BlueKeep ---
    {
        "port": 3389,
        "service_re": r"rdp|ms-wbt-server",
        "banner_re": r".",
        "name": "RDP exposed — BlueKeep risk",
        "severity": "high",
        "cve": "CVE-2019-0708",
        "description": (
            "Remote Desktop exposed to the internet. "
            "Unpatched systems may be vulnerable to BlueKeep RCE."
        ),
        "remediation": (
            "Apply BlueKeep patches. Use NLA. "
            "Restrict RDP via VPN or firewall."
        ),
    },
    # --- PostgreSQL weak auth ---
    {
        "port": 5432,
        "service_re": r"postgres",
        "banner_re": r".",
        "name": "PostgreSQL exposed — weak auth risk",
        "severity": "medium",
        "cve": None,
        "description": (
            "PostgreSQL port is open and exposed. May accept "
            "connections with weak or trust authentication."
        ),
        "remediation": (
            "Restrict PostgreSQL to localhost/VPN. "
            "Use scram-sha-256 authentication."
        ),
    },
    # --- phpMyAdmin on web ports ---
    {
        "port": 80,
        "service_re": r"http|apache|nginx",
        "banner_re": r"phpmyadmin|phpMyAdmin",
        "name": "phpMyAdmin detected on web port",
        "severity": "medium",
        "cve": None,
        "description": (
            "phpMyAdmin web interface exposed. May allow "
            "brute-force attacks against the database."
        ),
        "remediation": (
            "Restrict phpMyAdmin access via IP whitelist "
            "or move behind VPN."
        ),
    },
    {
        "port": 443,
        "service_re": r"https?|apache|nginx",
        "banner_re": r"phpmyadmin|phpMyAdmin",
        "name": "phpMyAdmin detected on HTTPS port",
        "severity": "medium",
        "cve": None,
        "description": (
            "phpMyAdmin web interface exposed on HTTPS. May allow "
            "brute-force attacks against the database."
        ),
        "remediation": (
            "Restrict phpMyAdmin access via IP whitelist "
            "or move behind VPN."
        ),
    },
    # --- ProFTPD RCE ---
    {
        "port": 21,
        "service_re": r"proftpd",
        "banner_re": r"ProFTPD 1\.[23]\.",
        "name": "ProFTPD < 1.3.6 — mod_copy RCE",
        "severity": "critical",
        "cve": "CVE-2015-3306",
        "description": (
            "ProFTPD before 1.3.6 has mod_copy which allows "
            "unauthenticated remote code execution."
        ),
        "remediation": "Upgrade ProFTPD to 1.3.6 or later. Disable mod_copy.",
    },
    # --- vsftpd backdoor ---
    {
        "port": 21,
        "service_re": r"vsftpd",
        "banner_re": r"vsftpd 2\.3\.4",
        "name": "vsftpd 2.3.4 — backdoor",
        "severity": "critical",
        "cve": "CVE-2011-2523",
        "description": (
            "vsftpd 2.3.4 contains a backdoor that opens a shell "
            "on port 6200 when triggered with a :) smiley in username."
        ),
        "remediation": "Upgrade vsftpd immediately.",
    },
    # --- Java / Log4Shell ---
    {
        "port": None,
        "service_re": r"apache|tomcat|java|jetty",
        "banner_re": r".",
        "name": "Java service — check Log4Shell",
        "severity": "high",
        "cve": "CVE-2021-44228",
        "description": (
            "Java-based service detected. Verify that Log4j "
            "is patched against Log4Shell RCE."
        ),
        "remediation": "Upgrade Log4j to 2.17.1+ or remove JndiLookup class.",
    },
    # --- nginx path traversal ---
    {
        "port": None,
        "service_re": r"nginx",
        "banner_re": r"nginx/(0\.\d|1\.([0-9]|1[0-7])\.\d)",
        "name": "nginx < 1.17 — alias path traversal risk",
        "severity": "medium",
        "cve": None,
        "description": (
            "nginx versions before 1.17 with misconfigured alias "
            "directives may allow path traversal."
        ),
        "remediation": "Upgrade nginx and audit alias configurations.",
    },
    # --- Exim RCE ---
    {
        "port": 25,
        "service_re": r"exim",
        "banner_re": r"Exim [1-3]|4\.[0-8]",
        "name": "Exim < 4.92 — RCE",
        "severity": "critical",
        "cve": "CVE-2019-10149",
        "description": (
            "Exim before 4.92 allows remote code execution "
            "via a crafted recipient address."
        ),
        "remediation": "Upgrade Exim to 4.92 or later.",
    },
]

# Active probes: services that can be confirmed by sending a command.
ACTIVE_PROBES: list[dict] = [
    {
        "port": 6379,
        "name": "Redis",
        "probe_type": "tcp",
        "send": b"PING\r\n",
        "expect": "+PONG",
        "finding_title": "Redis accessible without authentication",
        "severity": "critical",
        "cve": None,
        "description": (
            "Redis instance responds to PING without auth. "
            "An attacker can read/write all data and execute "
            "arbitrary Lua scripts."
        ),
        "remediation": (
            "Enable requirepass in redis.conf. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
    {
        "port": 27017,
        "name": "MongoDB",
        "probe_type": "tcp_connect",
        "send": None,
        "expect": None,
        "finding_title": "MongoDB accessible without authentication",
        "severity": "critical",
        "cve": None,
        "description": (
            "MongoDB accepts TCP connections without auth. "
            "Databases may be fully exposed to the internet."
        ),
        "remediation": (
            "Enable authentication in mongod.conf. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
    {
        "port": 9200,
        "name": "Elasticsearch",
        "probe_type": "http",
        "url_path": "/",
        "expect": "cluster_name",
        "finding_title": (
            "Elasticsearch accessible without authentication"
        ),
        "severity": "critical",
        "cve": None,
        "description": (
            "Elasticsearch API is exposed without auth. "
            "All indices and data are publicly readable."
        ),
        "remediation": (
            "Enable X-Pack security or SearchGuard. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
    {
        "port": 2375,
        "name": "Docker API",
        "probe_type": "http",
        "url_path": "/v1.24/containers/json",
        "expect": "[",
        "finding_title": "Docker API exposed without TLS",
        "severity": "critical",
        "cve": None,
        "description": (
            "Docker Remote API is exposed without authentication. "
            "An attacker can create privileged containers and "
            "escape to the host."
        ),
        "remediation": (
            "Disable remote Docker API or enable TLS mutual auth. "
            "Use a firewall to restrict access."
        ),
    },
    {
        "port": 11211,
        "name": "Memcached",
        "probe_type": "tcp",
        "send": b"stats\r\n",
        "expect": "STAT",
        "finding_title": "Memcached exposed — amplification risk",
        "severity": "high",
        "cve": "CVE-2018-1000115",
        "description": (
            "Memcached responds to commands without auth. "
            "Can be abused for DDoS amplification attacks "
            "(UDP reflection)."
        ),
        "remediation": (
            "Bind Memcached to 127.0.0.1. Disable UDP. "
            "Use SASL authentication."
        ),
    },
    {
        "port": 5984,
        "name": "CouchDB",
        "probe_type": "http",
        "url_path": "/",
        "expect": "couchdb",
        "finding_title": "CouchDB accessible without auth",
        "severity": "critical",
        "cve": None,
        "description": (
            "CouchDB is accessible without authentication. "
            "All databases may be publicly readable and writable."
        ),
        "remediation": (
            "Enable authentication in CouchDB. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
    {
        "port": 8500,
        "name": "Consul",
        "probe_type": "http",
        "url_path": "/v1/agent/self",
        "expect": "Config",
        "finding_title": "Consul API exposed without ACL",
        "severity": "critical",
        "cve": None,
        "description": (
            "HashiCorp Consul API is exposed without ACL. "
            "Service mesh configuration may be leaked or modified."
        ),
        "remediation": (
            "Enable Consul ACL system. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
    {
        "port": 15672,
        "name": "RabbitMQ",
        "probe_type": "http",
        "url_path": "/api/overview",
        "expect": "rabbitmq",
        "finding_title": "RabbitMQ Management exposed",
        "severity": "high",
        "cve": None,
        "description": (
            "RabbitMQ Management interface is exposed. "
            "Default credentials guest/guest may be active."
        ),
        "remediation": (
            "Change default credentials. "
            "Restrict management interface access."
        ),
    },
    {
        "port": 6443,
        "name": "Kubernetes API",
        "probe_type": "http",
        "url_path": "/version",
        "expect": "gitVersion",
        "finding_title": "Kubernetes API server exposed",
        "severity": "critical",
        "cve": None,
        "description": (
            "Kubernetes API server is exposed to the internet. "
            "May allow cluster takeover if misconfigured."
        ),
        "remediation": (
            "Restrict API server access via firewall. "
            "Enable RBAC and audit logging."
        ),
    },
    {
        "port": 2379,
        "name": "etcd",
        "probe_type": "http",
        "url_path": "/version",
        "expect": "etcdserver",
        "finding_title": "etcd API exposed without auth",
        "severity": "critical",
        "cve": None,
        "description": (
            "etcd API is exposed without authentication. "
            "Kubernetes secrets and cluster state may be leaked."
        ),
        "remediation": (
            "Enable etcd client certificate auth. "
            "Bind to 127.0.0.1. Use firewall rules."
        ),
    },
]


class PortVulnCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="port_vuln_check",
        display_name="Port Vulnerability Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Fingerprints service banners on open ports and "
            "matches against known CVEs and vulnerability signatures"
        ),
        depends_on=["port_scan", "service_detect"],
        produces=["port_vulns"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        vulns: list[dict] = []

        # Get open ports from pipeline
        port_key = f"port_scan:{target.host}"
        port_result = ctx.pipeline.get(port_key)
        open_ports: list[dict] = []
        if port_result and port_result.ok:
            open_ports = port_result.data.get("open_ports", [])

        # Get service/banner data from pipeline
        svc_key = f"service_detect:{target.host}"
        svc_result = ctx.pipeline.get(svc_key)
        services: dict[int, dict] = {}
        if svc_result and svc_result.ok:
            services = {
                s["port"]: s
                for s in svc_result.data.get("services", [])
            }

        if not open_ports:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No open ports — skipping vulnerability check",
                    tags=["pentesting", "port-vuln"],
                )],
                data={"vulns": []},
            )

        # --- Phase 1: banner-based matching ---
        open_port_numbers = {p["port"] for p in open_ports}

        for port_info in open_ports:
            port = port_info["port"]
            svc = services.get(port, {})
            service_name = svc.get("service", port_info.get("service", ""))
            banner = svc.get("banner", "")

            for vuln in KNOWN_VULNS:
                if not self._matches_port(vuln["port"], port):
                    continue
                if not re.search(
                    vuln["service_re"], service_name, re.IGNORECASE
                ):
                    continue
                if not re.search(
                    vuln["banner_re"], banner, re.IGNORECASE
                ):
                    continue

                vuln_record = {
                    "port": port,
                    "name": vuln["name"],
                    "severity": vuln["severity"],
                    "cve": vuln.get("cve"),
                    "confirmed": False,
                    "evidence": f"Banner: {banner[:200]}",
                }
                vulns.append(vuln_record)

                cve_str = (
                    f" ({vuln['cve']})" if vuln.get("cve") else ""
                )
                evidence = (
                    f"Port {port}, service={service_name}, "
                    f"banner={banner[:150]}"
                )
                findings.append(Finding.medium(
                    f"{vuln['name']}{cve_str}",
                    description=vuln["description"],
                    evidence=evidence,
                    remediation=vuln["remediation"],
                    tags=self._build_tags(vuln),
                ))

        # --- Phase 2: active probes ---
        for probe in ACTIVE_PROBES:
            if probe["port"] not in open_port_numbers:
                continue

            confirmed = False
            evidence = ""

            try:
                if probe["probe_type"] == "tcp":
                    confirmed, evidence = await self._probe_tcp(
                        target.host,
                        probe["port"],
                        probe["send"],
                        probe["expect"],
                        ctx,
                    )
                elif probe["probe_type"] == "tcp_connect":
                    confirmed, evidence = await self._probe_tcp_connect(
                        target.host, probe["port"], ctx,
                    )
                elif probe["probe_type"] == "http":
                    confirmed, evidence = await self._probe_http(
                        target.host,
                        probe["port"],
                        probe["url_path"],
                        probe["expect"],
                        ctx,
                    )
            except Exception:
                continue

            if confirmed:
                vuln_record = {
                    "port": probe["port"],
                    "name": probe["finding_title"],
                    "severity": probe["severity"],
                    "cve": probe.get("cve"),
                    "confirmed": True,
                    "evidence": evidence[:300],
                }
                vulns.append(vuln_record)

                sev_fn = (
                    Finding.critical
                    if probe["severity"] == "critical"
                    else Finding.high
                )
                cve_str = (
                    f" ({probe['cve']})" if probe.get("cve") else ""
                )
                findings.append(sev_fn(
                    f"{probe['finding_title']}{cve_str}",
                    description=probe["description"],
                    evidence=evidence[:300],
                    remediation=probe["remediation"],
                    tags=self._build_tags(probe),
                ))

        # Summary finding
        confirmed_count = sum(1 for v in vulns if v["confirmed"])
        potential_count = sum(1 for v in vulns if not v["confirmed"])
        if vulns:
            findings.append(Finding.info(
                f"Port vuln check: {confirmed_count} confirmed, "
                f"{potential_count} potential vulnerabilities",
                evidence=", ".join(
                    f"{v['port']}/{v['name']}" for v in vulns
                )[:500],
                tags=["pentesting", "port-vuln", "summary"],
            ))
        else:
            findings.append(Finding.info(
                f"No known vulnerabilities on "
                f"{len(open_ports)} open ports",
                tags=["pentesting", "port-vuln"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"vulns": vulns, "ports_checked": len(open_ports)},
        )

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _matches_port(
        vuln_port: int | None, actual_port: int,
    ) -> bool:
        """Check if vuln port matches (None = any port)."""
        return vuln_port is None or vuln_port == actual_port

    @staticmethod
    def _build_tags(entry: dict) -> list[str]:
        """Build finding tags from a vuln/probe dict."""
        tags = ["pentesting", "port-vuln"]
        if entry.get("cve"):
            tags.append(entry["cve"].lower())
        name_lower = entry.get("name", "").lower()
        for kw in ("ssh", "ftp", "smb", "rdp", "redis", "mongo",
                    "elastic", "docker", "memcached", "mysql",
                    "postgres", "telnet", "apache", "nginx",
                    "phpmyadmin"):
            if kw in name_lower:
                tags.append(kw)
                break
        return tags

    async def _probe_tcp(
        self,
        host: str,
        port: int,
        send_data: bytes,
        expect: str,
        ctx,
    ) -> tuple[bool, str]:
        """Send a TCP probe and check response for expected string."""
        import asyncio

        reader, writer = await asyncio.wait_for(
            asyncio.open_connection(host, port), timeout=3,
        )
        try:
            writer.write(send_data)
            await writer.drain()
            data = await asyncio.wait_for(
                reader.read(1024), timeout=3,
            )
            response = data.decode("utf-8", errors="replace").strip()
            if expect in response:
                return True, f"Response: {response[:200]}"
            return False, ""
        finally:
            writer.close()
            await writer.wait_closed()

    async def _probe_tcp_connect(
        self, host: str, port: int, ctx,
    ) -> tuple[bool, str]:
        """Confirm service by TCP connect + optional banner read."""
        import asyncio

        reader, writer = await asyncio.wait_for(
            asyncio.open_connection(host, port), timeout=3,
        )
        try:
            # Try to read a banner if the service sends one
            try:
                data = await asyncio.wait_for(
                    reader.read(512), timeout=2,
                )
                banner = data.decode(
                    "utf-8", errors="replace",
                ).strip()
                return True, f"Connected, banner: {banner[:200]}"
            except TimeoutError:
                return True, "TCP connection successful (no banner)"
        finally:
            writer.close()
            await writer.wait_closed()

    async def _probe_http(
        self,
        host: str,
        port: int,
        path: str,
        expect: str,
        ctx,
    ) -> tuple[bool, str]:
        """Send an HTTP GET probe and check for expected content."""
        if ctx.http is None:
            return False, ""

        scheme = "https" if port == 443 else "http"
        url = f"{scheme}://{host}:{port}{path}"

        text = await ctx.http.fetch_text(url, timeout=3.0)
        if text and expect in text:
            snippet = text[:300].replace("\n", " ")
            return True, f"HTTP {url} — {snippet}"
        return False, ""
