"""Open Redirect detection — parameter-based, meta refresh, JavaScript-based.

Checks for:
1. Common redirect parameters (url, redirect, next, return, etc.)
2. Various bypass techniques (//evil.com, \\evil.com, @evil.com)
3. Redirect via 3xx response Location header
4. JavaScript/meta refresh redirect detection
"""

from __future__ import annotations

import logging
from typing import ClassVar
from urllib.parse import quote, urlparse

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

EVIL_HOST = "evil.com"

# Redirect payloads — if the server redirects to evil.com, it's vulnerable
REDIRECT_PAYLOADS: list[tuple[str, str]] = [
    # Absolute URL
    (f"https://{EVIL_HOST}/", "absolute_url"),
    (f"http://{EVIL_HOST}/", "absolute_http"),
    # Protocol-relative
    (f"//{EVIL_HOST}/", "protocol_relative"),
    (f"///{EVIL_HOST}/", "triple_slash"),
    (f"////{EVIL_HOST}/", "quad_slash"),
    # Backslash variants
    (f"\\\\{EVIL_HOST}/", "backslash"),
    (f"/\\{EVIL_HOST}", "mixed_slashes"),
    (f"\\/{EVIL_HOST}", "reverse_mixed"),
    # Single slash + host
    (f"/{EVIL_HOST}/", "slash_host"),
    # Encoded slashes
    (f"https://{EVIL_HOST}%2f/", "encoded_slash"),
    (f"%2f%2f{EVIL_HOST}", "double_encoded_slash"),
    (f"%5c%5c{EVIL_HOST}", "encoded_backslash"),
    # Tab / newline in URL
    (f"/%09/{EVIL_HOST}", "tab_bypass"),
    (f"//{EVIL_HOST}%09/", "tab_in_host"),
    (f"//{EVIL_HOST}%0a/", "newline_in_host"),
    (f"//{EVIL_HOST}%0d/", "cr_in_host"),
    # Auth-based confusion (user@host)
    (f"https://legitimate.com@{EVIL_HOST}", "at_sign_reverse"),
    (f"//{EVIL_HOST}@legitimate.com", "at_sign_forward"),
    (f"https://legitimate.com%40{EVIL_HOST}", "encoded_at"),
    # Fragment / hash bypass
    (f"/{EVIL_HOST}%23", "hash_bypass"),
    (f"//{EVIL_HOST}%23.legitimate.com", "hash_domain_bypass"),
    # Missing / extra slashes
    (f"https:{EVIL_HOST}", "missing_slashes"),
    (f"https:////{EVIL_HOST}", "extra_slashes"),
    # Unicode homograph / confusable
    (f"http://{EVIL_HOST}%E3%80%82com", "unicode_dot"),
    # Null byte bypass
    (f"https://{EVIL_HOST}%00.legitimate.com", "null_byte"),
    (f"//{EVIL_HOST}%00.legitimate.com", "null_byte_relative"),
    # JavaScript protocol
    ("javascript:alert(1)//", "javascript_proto"),
    ("JaVaScRiPt:alert(1)", "javascript_case_bypass"),
    ("javascript%3Aalert(1)", "javascript_encoded_colon"),
    # Data URI
    ("data:text/html,<h1>redirect</h1>", "data_uri"),
    ("data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==", "data_uri_b64"),
    # Path confusion
    (f"/.{EVIL_HOST}", "dot_host"),
    (f"/./{EVIL_HOST}", "dot_slash_host"),
    (f"/..;/{EVIL_HOST}", "dotdot_semicolon"),
    # Double URL
    (f"https://{EVIL_HOST}?url=https://legitimate.com", "double_url"),
    # SSRF-style local redirects
    ("http://127.0.0.1", "ssrf_localhost"),
    ("http://[::1]", "ssrf_ipv6_localhost"),
    ("http://0x7f000001", "ssrf_hex_ip"),
    ("http://0177.0.0.1", "ssrf_octal_ip"),
    # CRLF within redirect
    (f"//{EVIL_HOST}/%0d%0aX-Injected:true", "crlf_redirect"),
    # Whitespace prefix
    (f" //{EVIL_HOST}/", "space_prefix"),
    (f"\t//{EVIL_HOST}/", "tab_prefix"),
]

# Parameters commonly used for redirects
REDIRECT_PARAMS = [
    "to", "url", "redirect", "redirect_url", "redirect_uri", "redir",
    "return", "return_url", "returnTo", "returnUrl",
    "next", "next_url", "nextUrl", "goto", "go",
    "target", "dest", "destination", "rurl", "target_url",
    "continue", "callback", "forward", "forward_url",
    "out", "view", "login_url", "logout", "checkout_url",
    "ref", "site", "link",
]

# Paths where redirects are common
REDIRECT_PATHS = [
    "/login", "/logout", "/redirect", "/auth", "/sso",
    "/oauth/callback", "/signin", "/signout", "/", "/api/redirect",
]


class OpenRedirectPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="open_redirect",
        display_name="Open Redirect Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects open redirect vulnerabilities via common redirect parameters "
            "with various bypass techniques"
        ),
        produces=["redirect_findings"],
        timeout=60.0,
    )

    @staticmethod
    def _redirects_to_evil(location: str) -> bool:
        """Check if Location header actually redirects to evil.com domain.

        Parses the URL properly instead of substring matching to avoid FP
        when evil.com appears in query params or path but not as the host.
        """
        if not location:
            return False
        loc_lower = location.lower().strip()
        # Handle protocol-relative URLs
        if loc_lower.startswith("//"):
            loc_lower = "https:" + loc_lower
        # Parse the URL to extract the host
        try:
            parsed = urlparse(loc_lower)
            host = parsed.hostname or ""
            # Strip any userinfo (user@host)
            return host == EVIL_HOST or host.endswith(f".{EVIL_HOST}")
        except Exception:
            # Fallback: if URL cannot be parsed, use substring check
            return EVIL_HOST in loc_lower

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"redirect_tests": []},
            )

        # Collect injection points from crawled data + hardcoded fallbacks
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=REDIRECT_PATHS,
            hardcoded_params=REDIRECT_PARAMS,
            param_filter=REDIRECT_PARAMS,
            max_points=20,
        )

        # Build path → prioritized params mapping from injection points
        path_params: dict[str, list[str]] = {}
        for p in inj_points:
            if p.path not in path_params:
                path_params[p.path] = []
            for param_name in p.params:
                if param_name not in path_params[p.path]:
                    path_params[p.path].append(param_name)

        scan_paths = list(path_params.keys()) if path_params else list(REDIRECT_PATHS)

        # --- Phase 1: Direct redirect detection (budget: ~50% of time) ---
        # Only test priority params per path + max 3 fallback params to
        # preserve time budget for Phase 2 allowlist bypass detection
        allowlist_paths: list[tuple[str, str, int]] = []

        for path in scan_paths:
            if ctx.should_stop or len(findings) >= 3:
                break

            priority_params = path_params.get(path, [])
            remaining = [p for p in REDIRECT_PARAMS if p not in priority_params]
            ordered_params = priority_params + remaining[:3]

            for param in ordered_params:
                if ctx.should_stop or len(findings) >= 3:
                    break

                baseline_location = ""
                baseline_status = 0
                try:
                    async with ctx.rate:
                        bl_resp = await ctx.http.get(
                            f"{base_url}{path}?{param}=https://example.com/",
                            timeout=8.0, allow_redirects=False,
                        )
                        baseline_location = bl_resp.headers.get("Location", "")
                        baseline_status = bl_resp.status
                except Exception as e:
                    logger.debug("open_redirect: %s (%s)", e, type(e).__name__)

                # Track paths that block evil URLs (allowlist candidates)
                found_redirect = False

                for payload, label in REDIRECT_PAYLOADS[:10]:
                    if ctx.should_stop:
                        break

                    url = f"{base_url}{path}?{param}={quote(payload, safe=':/@')}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(
                                url, timeout=8.0, allow_redirects=False,
                            )
                    except Exception as e:
                        logger.debug("open_redirect: %s (%s)", e, type(e).__name__)
                        continue

                    if resp.status in (301, 302, 303, 307, 308):
                        location = resp.headers.get("Location", "")
                        # Verify Location actually redirects to evil.com
                        # by parsing the host — not just substring match
                        if not self._redirects_to_evil(location):
                            continue
                        if baseline_location and location == baseline_location:
                            continue

                        destination = (
                            location.split("//")[-1].split("/")[0]
                            if "//" in location else location
                        )
                        tested.append({
                            "path": path, "param": param,
                            "payload": payload, "label": label,
                            "redirect_to": location,
                        })
                        findings.append(Finding.medium(
                            f"Open redirect: {path}?{param}= ({label})",
                            description=(
                                f"Server redirects to attacker-controlled domain "
                                f"via {label} technique."
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Location: {location}\n"
                                f"Destination host: {destination}"
                            ),
                            confidence=0.9,
                            remediation=(
                                "Validate redirect URLs against a whitelist. "
                                "Only allow relative redirects or same-domain."
                            ),
                            tags=["pentesting", "open-redirect", label],
                        ))
                        found_redirect = True
                        break

                    # Detect allowlist: evil blocked with 403/406 while
                    # baseline was either 3xx or also 406 (both indicate
                    # the param is used for redirects with filtering)
                    if resp.status in (403, 406):
                        is_allowlist = (
                            baseline_location  # baseline was 3xx with Location
                            or baseline_status in (403, 406)  # baseline also blocked
                        )
                        if is_allowlist:
                            allowlist_paths.append((path, param, resp.status))
                            break

                    if resp.status == 200:
                        try:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                        except Exception as e:
                            logger.debug("open_redirect: %s (%s)", e, type(e).__name__)
                            continue

                        if EVIL_HOST in body.lower():
                            body_lower = body.lower()
                            is_redirect = (
                                "location.href" in body_lower
                                or "window.location" in body_lower
                                or 'http-equiv="refresh"' in body_lower
                                or "location.replace" in body_lower
                            )
                            if is_redirect:
                                conf = 0.6 if 'http-equiv="refresh"' in body_lower else 0.5
                                tested.append({
                                    "path": path, "param": param,
                                    "payload": payload, "label": f"js_{label}",
                                })
                                findings.append(Finding.medium(
                                    f"JS/meta redirect: {path}?{param}= ({label})",
                                    description=(
                                        "Response contains JS or meta refresh "
                                        "redirect to attacker domain."
                                    ),
                                    evidence=f"URL: {url}",
                                    confidence=conf,
                                    remediation="Validate redirect targets server-side.",
                                    tags=["pentesting", "open-redirect", "js"],
                                ))
                                found_redirect = True
                                break

                if found_redirect:
                    break  # Move to next path

        # --- Phase 2: Allowlist bypass detection ---
        # Run on all paths where allowlist was detected, or all scan_paths
        # as fallback. This is the more sophisticated detection method.
        if not findings and not ctx.should_stop:
            bypass_paths = (
                [(p, param) for p, param, _ in allowlist_paths]
                if allowlist_paths
                else None
            )
            await self._check_allowlist_bypass(
                ctx, base_url, scan_paths, findings, tested,
                priority_pairs=bypass_paths,
            )

        # Report allowlist without bypass as LOW finding
        if not findings and allowlist_paths:
            path, param, status = allowlist_paths[0]
            findings.append(Finding.low(
                f"Redirect endpoint with allowlist: {path}?{param}=",
                description=(
                    f"Server uses '{param}' parameter for redirects "
                    f"with an allowlist filter (returned {status} "
                    f"for blocked domain). Allowlist bypass was not successful."
                ),
                evidence=f"Path: {path}, Param: {param}, Status: {status}",
                remediation=(
                    "Validate redirect URLs against a strict whitelist. "
                    "Consider using relative redirects only."
                ),
                tags=["pentesting", "open-redirect", "allowlist"],
            ))

        if not findings:
            findings.append(Finding.info(
                "No open redirect vulnerabilities detected",
                tags=["pentesting", "open-redirect"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"redirect_tests": tested},
        )

    # ------------------------------------------------------------------
    # Allowlist bypass detection
    # ------------------------------------------------------------------

    _PROBE_URLS = [
        "https://github.com/juice-shop/juice-shop",
        "https://www.google.com",
        "https://www.owasp.org",
        "https://example.com",
    ]

    _BYPASS_TEMPLATES: list[tuple[str, str]] = [
        ("{allowed}@{evil}", "at_sign_bypass"),
        ("https://{evil}?x={allowed}", "param_embed_bypass"),
        ("{allowed}.{evil}", "subdomain_bypass"),
        ("{allowed}%23@{evil}", "hash_at_bypass"),
        ("{allowed}%00@{evil}", "null_byte_bypass"),
    ]

    async def _check_allowlist_bypass(
        self, ctx, base_url: str, scan_paths: list[str],
        findings: list[Finding], tested: list[dict],
        priority_pairs: list[tuple[str, str]] | None = None,
    ) -> None:
        """Discover allowlisted redirect URLs and try bypass techniques."""
        # If Phase 1 found allowlist paths, test those first
        if priority_pairs:
            pairs = priority_pairs
        else:
            redirect_params = ["to", "url", "redirect", "next", "return", "goto"]
            pairs = [
                (path, param)
                for path in scan_paths
                for param in redirect_params
            ]

        for path, param in pairs:
            if ctx.should_stop or findings:
                break

            # Step 1: Find an allowed redirect URL
            allowed_url = None
            for probe in self._PROBE_URLS:
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}{path}?{param}={probe}",
                            timeout=8.0, allow_redirects=False,
                        )
                        if resp.status in (301, 302, 303, 307, 308):
                            allowed_url = probe
                            break
                except Exception:
                    continue

            if not allowed_url:
                continue

            # Step 2: Try bypass techniques with the allowed URL
            for tpl, label in self._BYPASS_TEMPLATES:
                if ctx.should_stop:
                    break
                bypass_url = tpl.format(
                    allowed=allowed_url, evil=EVIL_HOST,
                )
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}{path}?{param}="
                            f"{quote(bypass_url, safe=':/@?=&')}",
                            timeout=8.0, allow_redirects=False,
                        )
                except Exception:
                    continue

                if resp.status in (301, 302, 303, 307, 308):
                    location = resp.headers.get("Location", "")
                    if self._redirects_to_evil(location):
                        tested.append({
                            "path": path, "param": param,
                            "payload": bypass_url, "label": label,
                            "redirect_to": location,
                        })
                        findings.append(Finding.high(
                            f"Open redirect allowlist bypass: "
                            f"{path}?{param}= ({label})",
                            description=(
                                f"Redirect allowlist bypass via {label}. "
                                f"Allowed URL: {allowed_url}"
                            ),
                            evidence=(
                                f"Allowed URL: {allowed_url}\n"
                                f"Bypass payload: {bypass_url}\n"
                                f"Location: {location}"
                            ),
                            remediation=(
                                "Use strict URL validation with proper "
                                "parsing. Check scheme + host, not just "
                                "substring match."
                            ),
                            tags=["pentesting", "open-redirect", label],
                        ))
                        return
