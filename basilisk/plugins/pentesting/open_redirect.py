"""Open Redirect detection — parameter-based, meta refresh, JavaScript-based.

Checks for:
1. Common redirect parameters (url, redirect, next, return, etc.)
2. Various bypass techniques (//evil.com, \\evil.com, @evil.com)
3. Redirect via 3xx response Location header
4. JavaScript/meta refresh redirect detection
"""

from __future__ import annotations

from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

EVIL_HOST = "evil.com"

# Redirect payloads — if the server redirects to evil.com, it's vulnerable
REDIRECT_PAYLOADS: list[tuple[str, str]] = [
    # Absolute URL
    (f"https://{EVIL_HOST}/", "absolute_url"),
    (f"http://{EVIL_HOST}/", "absolute_http"),
    # Protocol-relative
    (f"//{EVIL_HOST}/", "protocol_relative"),
    (f"///{EVIL_HOST}/", "triple_slash"),
    (f"////{EVIL_HOST}/", "quad_slash"),
    # Backslash variants
    (f"\\\\{EVIL_HOST}/", "backslash"),
    (f"/\\{EVIL_HOST}", "mixed_slashes"),
    (f"\\/{EVIL_HOST}", "reverse_mixed"),
    # Single slash + host
    (f"/{EVIL_HOST}/", "slash_host"),
    # Encoded slashes
    (f"https://{EVIL_HOST}%2f/", "encoded_slash"),
    (f"%2f%2f{EVIL_HOST}", "double_encoded_slash"),
    (f"%5c%5c{EVIL_HOST}", "encoded_backslash"),
    # Tab / newline in URL
    (f"/%09/{EVIL_HOST}", "tab_bypass"),
    (f"//{EVIL_HOST}%09/", "tab_in_host"),
    (f"//{EVIL_HOST}%0a/", "newline_in_host"),
    (f"//{EVIL_HOST}%0d/", "cr_in_host"),
    # Auth-based confusion (user@host)
    (f"https://legitimate.com@{EVIL_HOST}", "at_sign_reverse"),
    (f"//{EVIL_HOST}@legitimate.com", "at_sign_forward"),
    (f"https://legitimate.com%40{EVIL_HOST}", "encoded_at"),
    # Fragment / hash bypass
    (f"/{EVIL_HOST}%23", "hash_bypass"),
    (f"//{EVIL_HOST}%23.legitimate.com", "hash_domain_bypass"),
    # Missing / extra slashes
    (f"https:{EVIL_HOST}", "missing_slashes"),
    (f"https:////{EVIL_HOST}", "extra_slashes"),
    # Unicode homograph / confusable
    (f"http://{EVIL_HOST}%E3%80%82com", "unicode_dot"),
    # Null byte bypass
    (f"https://{EVIL_HOST}%00.legitimate.com", "null_byte"),
    (f"//{EVIL_HOST}%00.legitimate.com", "null_byte_relative"),
    # JavaScript protocol
    ("javascript:alert(1)//", "javascript_proto"),
    ("JaVaScRiPt:alert(1)", "javascript_case_bypass"),
    ("javascript%3Aalert(1)", "javascript_encoded_colon"),
    # Data URI
    ("data:text/html,<h1>redirect</h1>", "data_uri"),
    ("data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==", "data_uri_b64"),
    # Path confusion
    (f"/.{EVIL_HOST}", "dot_host"),
    (f"/./{EVIL_HOST}", "dot_slash_host"),
    (f"/..;/{EVIL_HOST}", "dotdot_semicolon"),
    # Double URL
    (f"https://{EVIL_HOST}?url=https://legitimate.com", "double_url"),
    # SSRF-style local redirects
    ("http://127.0.0.1", "ssrf_localhost"),
    ("http://[::1]", "ssrf_ipv6_localhost"),
    ("http://0x7f000001", "ssrf_hex_ip"),
    ("http://0177.0.0.1", "ssrf_octal_ip"),
    # CRLF within redirect
    (f"//{EVIL_HOST}/%0d%0aX-Injected:true", "crlf_redirect"),
    # Whitespace prefix
    (f" //{EVIL_HOST}/", "space_prefix"),
    (f"\t//{EVIL_HOST}/", "tab_prefix"),
]

# Parameters commonly used for redirects
REDIRECT_PARAMS = [
    "url", "redirect", "redirect_url", "redirect_uri", "redir",
    "return", "return_url", "returnTo", "returnUrl",
    "next", "next_url", "nextUrl", "goto", "go",
    "target", "dest", "destination", "rurl", "target_url",
    "continue", "callback", "forward", "forward_url",
    "out", "view", "login_url", "logout", "checkout_url",
    "ref", "site", "link", "to",
]

# Paths where redirects are common
REDIRECT_PATHS = [
    "/login", "/logout", "/redirect", "/auth", "/sso",
    "/oauth/callback", "/signin", "/signout", "/", "/api/redirect",
]


class OpenRedirectPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="open_redirect",
        display_name="Open Redirect Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects open redirect vulnerabilities via common redirect parameters "
            "with various bypass techniques"
        ),
        produces=["redirect_findings"],
        timeout=35.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"redirect_tests": []},
            )

        # Extend paths from pipeline
        scan_paths = list(REDIRECT_PATHS)
        admin_paths = ctx.state.get("admin_paths", [])
        if isinstance(admin_paths, list):
            for item in admin_paths[:5]:
                p = item.get("path", item) if isinstance(item, dict) else str(item)
                if p and p not in scan_paths:
                    scan_paths.append(p)

        for path in scan_paths:
            if ctx.should_stop or len(findings) >= 3:
                break

            for param in REDIRECT_PARAMS:
                if ctx.should_stop or len(findings) >= 3:
                    break

                for payload, label in REDIRECT_PAYLOADS[:10]:
                    if ctx.should_stop:
                        break

                    url = f"{base_url}{path}?{param}={quote(payload, safe=':/@')}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(
                                url, timeout=8.0, allow_redirects=False,
                            )
                    except Exception:
                        continue

                    # Check 3xx redirect to evil domain
                    if resp.status in (301, 302, 303, 307, 308):
                        location = resp.headers.get("Location", "")
                        if EVIL_HOST in location.lower():
                            # Verify destination domain is truly external
                            destination = (
                                location.split("//")[-1].split("/")[0]
                                if "//" in location else location
                            )
                            tested.append({
                                "path": path, "param": param,
                                "payload": payload, "label": label,
                                "redirect_to": location,
                            })
                            findings.append(Finding.medium(
                                f"Open redirect: {path}?{param}= ({label})",
                                description=(
                                    f"Server redirects to attacker-controlled domain "
                                    f"via {label} technique."
                                ),
                                evidence=(
                                    f"URL: {url}\n"
                                    f"Location: {location}\n"
                                    f"Destination host: {destination}"
                                ),
                                remediation=(
                                    "Validate redirect URLs against a whitelist. "
                                    "Only allow relative redirects or same-domain."
                                ),
                                tags=["pentesting", "open-redirect", label],
                            ))
                            break  # One per param

                    # Check meta/JS redirect in body
                    if resp.status == 200:
                        try:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                        except Exception:
                            continue

                        if EVIL_HOST in body.lower():
                            body_lower = body.lower()
                            is_redirect = (
                                "location.href" in body_lower
                                or "window.location" in body_lower
                                or 'http-equiv="refresh"' in body_lower
                                or "location.replace" in body_lower
                            )
                            if is_redirect:
                                tested.append({
                                    "path": path, "param": param,
                                    "payload": payload, "label": f"js_{label}",
                                })
                                findings.append(Finding.medium(
                                    f"JS/meta redirect: {path}?{param}= ({label})",
                                    description=(
                                        "Response contains JS or meta refresh "
                                        "redirect to attacker domain."
                                    ),
                                    evidence=f"URL: {url}",
                                    remediation="Validate redirect targets server-side.",
                                    tags=["pentesting", "open-redirect", "js"],
                                ))
                                break

        if not findings:
            findings.append(Finding.info(
                "No open redirect vulnerabilities detected",
                tags=["pentesting", "open-redirect"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"redirect_tests": tested},
        )
