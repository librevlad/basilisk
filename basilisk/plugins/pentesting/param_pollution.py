"""HTTP Parameter Pollution detection."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)


class ParamPollutionPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="param_pollution",
        display_name="HTTP Parameter Pollution",
        category=PluginCategory.PENTESTING,
        description="Detects HTTP Parameter Pollution vulnerabilities",
        produces=["hpp_findings"],
        timeout=20.0,
    )

    TEST_PAGES = ["/", "/search", "/login", "/api", "/filter", "/products"]

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        hpp_results: list[dict] = []
        base_url = ""

        # Use pre-probed scheme from autonomous mode when available
        _pre = ctx.state.get("http_scheme", {}).get(target.host)
        if _pre:
            base_url = f"{_pre}://{target.host}"

        if not base_url:
            for scheme in ("https", "http"):
                try:
                    async with ctx.rate:
                        await ctx.http.head(
                            f"{scheme}://{target.host}/", timeout=5.0,
                        )
                        base_url = f"{scheme}://{target.host}"
                        break
                except Exception as e:
                    logger.debug("param_pollution: %s", e)
                    continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"hpp_tests": []},
            )

        # Test 1: GET parameter duplication on known pages
        for page in self.TEST_PAGES:
            if ctx.should_stop:
                break
            single_url = f"{base_url}{page}?test=value1"
            dup_url = f"{base_url}{page}?test=value1&test=value2"
            try:
                async with ctx.rate:
                    resp_single = await ctx.http.get(
                        single_url, timeout=8.0,
                    )
                    body_single = await resp_single.text(
                        encoding="utf-8", errors="replace",
                    )

                async with ctx.rate:
                    resp_dup = await ctx.http.get(
                        dup_url, timeout=8.0,
                    )
                    body_dup = await resp_dup.text(
                        encoding="utf-8", errors="replace",
                    )

                behavior = self._detect_behavior(
                    body_single, body_dup,
                )

                if behavior != "unknown":
                    hpp_results.append({
                        "page": page,
                        "method": "GET",
                        "behavior": behavior,
                    })

                # Different status or significant body change = HPP potential
                if resp_single.status != resp_dup.status:
                    findings.append(Finding.medium(
                        f"HPP: status code differs on {page}",
                        description=(
                            f"Single param returned {resp_single.status}, "
                            f"duplicate params returned {resp_dup.status}"
                        ),
                        evidence=f"GET {dup_url}",
                        remediation=(
                            "Validate and canonicalize duplicate parameters"
                        ),
                        tags=["pentesting", "hpp"],
                    ))
                elif self._body_differs_significantly(
                    body_single, body_dup,
                ):
                    findings.append(Finding.medium(
                        f"HPP: response differs with duplicate params on {page}",
                        description=(
                            f"Server handles duplicate 'test' parameter "
                            f"differently — behavior: {behavior}"
                        ),
                        evidence=f"GET {dup_url}",
                        remediation=(
                            "Ensure consistent parameter handling; "
                            "reject or canonicalize duplicates"
                        ),
                        tags=["pentesting", "hpp"],
                    ))
                elif behavior != "unknown":
                    findings.append(Finding.low(
                        f"HPP: server param handling identified on {page}",
                        description=(
                            f"Server uses '{behavior}' strategy for "
                            f"duplicate parameters"
                        ),
                        evidence=f"GET {dup_url}",
                        tags=["pentesting", "hpp"],
                    ))
            except Exception as e:
                logger.debug("param_pollution: %s", e)
                continue

        # Test 2: Check forms found on pages for POST HPP
        for page in self.TEST_PAGES:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{page}", timeout=8.0,
                    )
                    if resp.status != 200:
                        continue
                    body = await resp.text(
                        encoding="utf-8", errors="replace",
                    )

                forms = re.findall(
                    r'<form\b([^>]*)>(.*?)</form>',
                    body, re.IGNORECASE | re.DOTALL,
                )

                for attrs, content in forms:
                    method_m = re.search(
                        r'method\s*=\s*["\']?(\w+)',
                        attrs, re.IGNORECASE,
                    )
                    if not method_m:
                        continue
                    if method_m.group(1).upper() != "POST":
                        continue

                    action_m = re.search(
                        r'action\s*=\s*["\']([^"\']*)["\']',
                        attrs, re.IGNORECASE,
                    )
                    action = action_m.group(1) if action_m else page
                    if action.startswith("/"):
                        action_url = f"{base_url}{action}"
                    elif action.startswith("http"):
                        action_url = action
                    else:
                        action_url = f"{base_url}/{action}"

                    # Find input fields
                    inputs = re.findall(
                        r'<input\b[^>]*name\s*=\s*["\']([^"\']+)["\']',
                        content, re.IGNORECASE,
                    )
                    if not inputs:
                        continue

                    param_name = inputs[0]
                    single_data = f"{param_name}=test1"
                    dup_data = (
                        f"{param_name}=test1&{param_name}=test2"
                    )

                    try:
                        async with ctx.rate:
                            resp_single = await ctx.http.post(
                                action_url,
                                data=single_data,
                                headers={
                                    "Content-Type":
                                    "application/x-www-form-urlencoded",
                                },
                                timeout=8.0,
                            )
                            body_single = await resp_single.text(
                                encoding="utf-8", errors="replace",
                            )

                        async with ctx.rate:
                            resp_dup = await ctx.http.post(
                                action_url,
                                data=dup_data,
                                headers={
                                    "Content-Type":
                                    "application/x-www-form-urlencoded",
                                },
                                timeout=8.0,
                            )
                            body_dup = await resp_dup.text(
                                encoding="utf-8", errors="replace",
                            )

                        behavior = self._detect_behavior(
                            body_single, body_dup,
                        )
                        hpp_results.append({
                            "page": page,
                            "method": "POST",
                            "form_action": action,
                            "param": param_name,
                            "behavior": behavior,
                        })

                        if resp_single.status != resp_dup.status:
                            findings.append(Finding.medium(
                                f"HPP: POST form status differs on {page}",
                                description=(
                                    f"Duplicate '{param_name}' in POST "
                                    f"changes response status"
                                ),
                                evidence=f"POST {action_url}",
                                remediation=(
                                    "Sanitize duplicate POST parameters"
                                ),
                                tags=["pentesting", "hpp"],
                            ))
                        elif self._body_differs_significantly(
                            body_single, body_dup,
                        ):
                            findings.append(Finding.medium(
                                f"HPP: POST response differs on {page}",
                                description=(
                                    f"Duplicate '{param_name}' in POST "
                                    f"produces different response — "
                                    f"behavior: {behavior}"
                                ),
                                evidence=f"POST {action_url}",
                                remediation=(
                                    "Reject or canonicalize duplicate "
                                    "POST parameters"
                                ),
                                tags=["pentesting", "hpp"],
                            ))
                    except Exception as e:
                        logger.debug("param_pollution: %s", e)
                        continue
            except Exception as e:
                logger.debug("param_pollution: %s", e)
                continue

        if not findings:
            findings.append(Finding.info(
                "No HTTP Parameter Pollution detected",
                tags=["pentesting", "hpp"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"hpp_tests": hpp_results},
        )

    @staticmethod
    def _detect_behavior(body_single: str, body_dup: str) -> str:
        """Identify how the server handles duplicate params.

        Returns one of: last_occurrence, concatenated,
        first_occurrence, or unknown.
        """
        # If the duplicate response contains "value1,value2" or
        # "value1 value2" — server concatenates
        if "value1,value2" in body_dup or "value1, value2" in body_dup:
            return "concatenated"
        if "value1value2" in body_dup:
            return "concatenated"

        has_v1_single = "value1" in body_single
        has_v1_dup = "value1" in body_dup
        has_v2_dup = "value2" in body_dup

        if has_v1_single:
            if has_v2_dup and not has_v1_dup:
                return "last_occurrence"
            if has_v1_dup and not has_v2_dup:
                return "first_occurrence"

        return "unknown"

    @staticmethod
    def _body_differs_significantly(
        body_a: str, body_b: str,
    ) -> bool:
        """Check if two response bodies differ beyond trivial changes."""
        if body_a == body_b:
            return False
        len_a, len_b = len(body_a), len(body_b)
        if len_a == 0 and len_b == 0:
            return False
        max_len = max(len_a, len_b)
        diff_ratio = abs(len_a - len_b) / max_len
        return diff_ratio > 0.1
