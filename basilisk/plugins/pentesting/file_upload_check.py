"""File upload vulnerability detection — finds upload forms and tests restrictions.

Discovers file upload endpoints via crawled forms, scan_paths, and common paths.
Tests:
1. Unrestricted file type upload (no extension filtering)
2. Server-side content-type validation bypass
3. Upload directory listing / file access verification
4. Dangerous file extension acceptance (.php, .jsp, .asp, etc.)

Does NOT deploy actual webshells (see file_upload_bypass for exploitation).
"""

from __future__ import annotations

import logging
from typing import ClassVar
from urllib.parse import urlparse

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Paths commonly associated with file upload functionality
UPLOAD_PATHS = [
    "/upload", "/upload.php", "/file-upload", "/file_upload",
    "/api/upload", "/api/files", "/api/v1/upload",
    "/rest/memories", "/rest/files", "/attachments",
    "/media/upload", "/images/upload", "/assets/upload",
    "/admin/upload", "/wp-admin/media-new.php",
]

# File upload keywords in URLs/form actions
UPLOAD_KEYWORDS = {"upload", "file", "attach", "import", "media", "image", "avatar", "photo"}

# Dangerous extensions to test (grouped by server technology)
DANGEROUS_EXTENSIONS = [
    (".php", "PHP script"),
    (".php5", "PHP5 script"),
    (".phtml", "PHP HTML template"),
    (".phar", "PHP archive"),
    (".jsp", "Java Server Pages"),
    (".jspx", "JSP XML"),
    (".asp", "Active Server Pages"),
    (".aspx", "ASP.NET"),
    (".py", "Python script"),
    (".rb", "Ruby script"),
    (".pl", "Perl script"),
    (".cgi", "CGI script"),
    (".sh", "Shell script"),
    (".shtml", "SSI HTML"),
    (".svg", "SVG (XSS vector)"),
    (".html", "HTML (XSS vector)"),
    (".htm", "HTML (XSS vector)"),
]

# Safe test payloads (no actual code execution)
TEST_CONTENT = b"BASILISK_UPLOAD_TEST_MARKER_12345"
PHP_MARKER = b"<?php /* BASILISK_TEST */ echo 'test'; ?>"


class FileUploadCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="file_upload_check",
        display_name="File Upload Vulnerability Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects unrestricted file upload vulnerabilities: "
            "discovers upload forms and tests extension filtering"
        ),
        produces=["upload_findings"],
        timeout=45.0,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        data: dict = {"upload_endpoints": [], "accepted_extensions": [], "forms_found": 0}

        base_urls = await resolve_base_urls(target, ctx)
        if not base_urls:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable via HTTP/HTTPS")],
                data=data,
            )
        base_url = base_urls[0]

        # Phase 1: Discover upload endpoints
        upload_urls = await self._discover_upload_endpoints(target, ctx, base_url, data)

        if not upload_urls:
            findings.append(Finding.info(
                "No file upload endpoints discovered",
                tags=["pentesting", "upload"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        # Phase 2: Test each upload endpoint
        for upload_url, field_name in upload_urls[:5]:
            if ctx.should_stop:
                break
            await self._test_upload_endpoint(
                ctx, base_url, upload_url, field_name, findings, data,
            )

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _discover_upload_endpoints(
        self, target: Target, ctx, base_url: str, data: dict,
    ) -> list[tuple[str, str]]:
        """Find upload endpoints from forms, crawled URLs, and common paths.

        Returns list of (upload_url, file_field_name) tuples.
        """
        endpoints: list[tuple[str, str]] = []
        seen: set[str] = set()

        # 1. Discovered forms with file inputs (highest priority)
        forms = ctx.state.get("discovered_forms", {}).get(target.host, [])
        for form in forms:
            inputs = form.get("inputs", [])
            file_inputs = []
            if isinstance(inputs, dict):
                for inp_name, _inp_val in inputs.items():
                    if "file" in inp_name.lower():
                        file_inputs.append(inp_name)
            elif isinstance(inputs, list):
                for inp in inputs:
                    if isinstance(inp, dict) and inp.get("type") == "file":
                        file_inputs.append(inp.get("name", "file"))
                    elif isinstance(inp, str) and "file" in inp.lower():
                        file_inputs.append(inp)

            if file_inputs:
                action = form.get("action", "")
                url = self._resolve_action(base_url, action)
                if url not in seen:
                    seen.add(url)
                    endpoints.append((url, file_inputs[0]))
                    data["forms_found"] = data.get("forms_found", 0) + 1

        # 2. Crawled URLs with upload keywords
        crawled = ctx.state.get("crawled_urls", {}).get(target.host, [])
        for url_str in crawled:
            parsed = urlparse(url_str)
            path = parsed.path.lower()
            if any(kw in path for kw in UPLOAD_KEYWORDS):
                full_url = f"{base_url}{parsed.path}"
                if full_url not in seen:
                    seen.add(full_url)
                    endpoints.append((full_url, "file"))

        # 3. Common upload paths (probe for existence)
        for path in UPLOAD_PATHS:
            if ctx.should_stop:
                break
            url = f"{base_url}{path}"
            if url in seen:
                continue
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status in (200, 301, 302, 405):
                        seen.add(url)
                        endpoints.append((url, "file"))
                        data["upload_endpoints"].append(path)
            except Exception:
                continue

        return endpoints

    async def _test_upload_endpoint(
        self, ctx, base_url: str, upload_url: str, field_name: str,
        findings: list[Finding], data: dict,
    ) -> None:
        """Test a single upload endpoint for unrestricted file types."""
        accepted: list[str] = []
        rejected: list[str] = []

        # Test safe extension first (baseline)
        baseline_ok = await self._try_upload(
            ctx, upload_url, field_name, "test.txt", TEST_CONTENT, "text/plain",
        )
        if baseline_ok is None:
            # Upload endpoint doesn't accept our requests
            return

        # Test dangerous extensions
        for ext, desc in DANGEROUS_EXTENSIONS[:10]:
            if ctx.should_stop:
                break
            filename = f"test{ext}"
            content = PHP_MARKER if ext in (".php", ".php5", ".phtml", ".phar") else TEST_CONTENT
            ctype = "application/octet-stream"

            result = await self._try_upload(ctx, upload_url, field_name, filename, content, ctype)
            if result is True:
                accepted.append(f"{ext} ({desc})")
            elif result is False:
                rejected.append(ext)

        if accepted:
            data["accepted_extensions"].extend(accepted)
            # Check for server-side execution
            exec_exts = [e for e in accepted if any(
                x in e for x in (".php", ".jsp", ".asp", ".py", ".rb", ".cgi", ".sh")
            )]

            if exec_exts:
                findings.append(Finding.critical(
                    "Unrestricted file upload: server-executable extensions accepted",
                    description=(
                        "The upload endpoint accepts files with dangerous extensions "
                        "that may execute server-side code. This can lead to RCE."
                    ),
                    evidence=(
                        f"URL: {upload_url}\n"
                        f"Accepted: {', '.join(exec_exts)}\n"
                        f"Rejected: {', '.join(rejected[:5]) or 'none tested'}"
                    ),
                    remediation=(
                        "Whitelist allowed extensions. Validate file content (magic bytes). "
                        "Store uploads outside webroot. Use random filenames."
                    ),
                    tags=["pentesting", "upload", "rce", "owasp:a03"],
                ))
            else:
                # Only client-side dangerous (SVG/HTML for XSS)
                findings.append(Finding.high(
                    "File upload accepts potentially dangerous types",
                    description=(
                        "Upload endpoint accepts file types that could be used "
                        "for stored XSS or other client-side attacks."
                    ),
                    evidence=(
                        f"URL: {upload_url}\n"
                        f"Accepted: {', '.join(accepted)}"
                    ),
                    remediation=(
                        "Restrict file types to only what's needed. "
                        "Sanitize SVG/HTML uploads. Set Content-Disposition: attachment."
                    ),
                    tags=["pentesting", "upload", "xss"],
                ))
        elif baseline_ok is True and rejected:
            findings.append(Finding.info(
                f"Upload endpoint filters dangerous extensions ({len(rejected)} blocked)",
                evidence=f"URL: {upload_url}\nBlocked: {', '.join(rejected[:5])}",
                tags=["pentesting", "upload"],
            ))

    async def _try_upload(
        self, ctx, url: str, field_name: str,
        filename: str, content: bytes, content_type: str,
    ) -> bool | None:
        """Attempt to upload a file. Returns True/False/None (error)."""
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data={field_name: (filename, content, content_type)},
                    timeout=10.0,
                )
                text = await resp.text(encoding="utf-8", errors="replace")
                text_lower = text.lower()

                # Success indicators
                if resp.status in (200, 201) and any(
                    kw in text_lower
                    for kw in ("success", "uploaded", "saved", "created", "complete")
                ):
                    return True

                # Rejection indicators
                if resp.status in (400, 403, 415, 422) or any(
                    kw in text_lower
                    for kw in (
                        "not allowed", "invalid", "rejected", "forbidden",
                        "unsupported", "extension", "file type",
                    )
                ):
                    return False

                # Ambiguous — treat redirect as possible success
                if resp.status in (301, 302, 303):
                    return True

                return None
        except Exception:
            return None

    @staticmethod
    def _resolve_action(base_url: str, action: str) -> str:
        """Resolve form action to absolute URL."""
        if not action or action == "#":
            return base_url + "/"
        if action.startswith("http"):
            return action
        if action.startswith("/"):
            return base_url + action
        return base_url + "/" + action
