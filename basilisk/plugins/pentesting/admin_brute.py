"""Admin panel brute â€” tests common default credentials on login forms."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

TOP_CREDENTIALS = [
    ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
    ("admin", "admin123"), ("admin", "12345678"), ("root", "root"),
    ("root", "toor"), ("administrator", "administrator"),
    ("test", "test"), ("user", "user"),
    ("admin", "1234"), ("admin", "pass"), ("admin", "qwerty"),
    ("demo", "demo"), ("guest", "guest"),
    # Common default / service credentials
    ("admin", "changeme"), ("admin", "letmein"), ("admin", "welcome"),
    ("admin", "passw0rd"), ("admin", "default"),
    ("root", "password"), ("root", "123456"), ("root", "changeme"),
    ("test", "test123"), ("test", "password"),
    ("user", "user123"), ("user", "password"),
    ("operator", "operator"), ("cisco", "cisco"),
    ("oracle", "oracle"), ("postgres", "postgres"),
    ("mysql", "mysql"), ("ftp", "ftp"),
    ("guest", "password"), ("manager", "manager"),
    ("supervisor", "supervisor"), ("support", "support"),
    ("monitor", "monitor"), ("service", "service"),
    ("tomcat", "tomcat"), ("tomcat", "s3cret"),
    ("webmaster", "webmaster"), ("info", "info"),
    ("ubuntu", "ubuntu"), ("pi", "raspberry"),
    ("nagios", "nagios"), ("backup", "backup"),
    ("deploy", "deploy"), ("developer", "developer"),
]

LOGIN_PAGES = [
    "/admin/", "/wp-login.php", "/administrator/",
    "/login/", "/login", "/auth/login", "/user/login",
    "/panel/", "/manage/", "/bitrix/admin/",
    # Additional common login pages
    "/admin.php", "/account/login", "/cpanel/",
    "/dashboard/login", "/signin", "/sso/login",
    "/api/auth/login", "/console/login", "/_auth/login",
    "/webadmin/", "/manager/html", "/admin/login.php",
    "/admin/signin", "/portal/login", "/backend/login",
    "/controlpanel/", "/modcp/", "/siteadmin/",
]

SUCCESS_MARKERS = [
    "dashboard", "welcome", "logout", "sign out", "panel",
    "my account", "control panel", "admin panel",
    # Additional success indicators
    "settings", "profile", "user management",
    "configuration", "log out", "sign off",
    "successfully logged", "home page", "main menu",
    "navigation", "account settings", "preferences",
    "notifications", "inbox", "overview",
]

FAIL_MARKERS = [
    "invalid", "incorrect", "wrong", "error", "failed",
    "bad credentials", "try again", "denied",
    # Additional failure indicators
    "invalid credentials", "login failed",
    "authentication failed", "bad password",
    "account locked", "too many attempts",
    "access denied", "wrong password",
    "unauthorized", "forbidden",
    "please try again", "not recognized",
    "login unsuccessful", "account disabled",
]


class AdminBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="admin_brute",
        display_name="Admin Panel Brute",
        category=PluginCategory.PENTESTING,
        description="Tests common default credentials on admin login forms",
        depends_on=["admin_finder"],
        produces=["admin_brute_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        findings: list[Finding] = []
        tested: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(
                        f"{scheme}://{target.host}/", timeout=5.0,
                    )
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception as e:
                logger.debug("admin_brute: %s", e)
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"tested": []},
            )

        # Collect login pages from admin_finder or defaults
        pages = list(LOGIN_PAGES)
        af_key = f"admin_finder:{target.host}"
        af_result = ctx.pipeline.get(af_key)
        if af_result and af_result.ok:
            for panel in af_result.data.get("panels", []):
                path = panel.get("path", "")
                if path and path not in pages:
                    pages.append(path)

        for page in pages:
            if ctx.should_stop:
                break
            url = f"{base_url}{page}"
            form = await self._detect_form(ctx, url)
            if not form:
                continue

            action, user_field, pass_field = form
            action_url = action if action.startswith("http") else (
                f"{base_url}{action}" if action.startswith("/")
                else f"{base_url}{page}{action}"
            )

            for username, password in TOP_CREDENTIALS:
                if ctx.should_stop:
                    break
                ok = await self._try_login(
                    ctx, action_url, user_field, pass_field,
                    username, password,
                )
                if ok:
                    tested.append({
                        "page": page, "user": username,
                        "pass": "***",
                    })
                    findings.append(Finding.critical(
                        f"Default credentials work: {page}",
                        description=(
                            f"Login form at {page} accepts "
                            f"default credentials ({username}:***)"
                        ),
                        evidence=f"User: {username}, Page: {page}",
                        remediation="Change default credentials",
                        tags=["pentesting", "brute", "credentials"],
                    ))
                    break  # One success per page is enough

        if not findings:
            findings.append(Finding.info(
                "No default credentials found on login forms",
                tags=["pentesting", "brute"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"tested": tested},
        )

    async def _detect_form(
        self, ctx, url: str,
    ) -> tuple[str, str, str] | None:
        """Detect login form and return (action, user_field, pass_field)."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=8.0)
                if resp.status != 200:
                    return None
                body = await resp.text(
                    encoding="utf-8", errors="replace",
                )
        except Exception as e:
            logger.debug("admin_brute: %s", e)
            return None

        forms = re.findall(
            r'<form\b([^>]*)>(.*?)</form>',
            body, re.IGNORECASE | re.DOTALL,
        )

        for attrs, content in forms:
            has_pass = re.search(
                r'type\s*=\s*["\']?password', content, re.IGNORECASE,
            )
            if not has_pass:
                continue

            action = ""
            m = re.search(
                r'action\s*=\s*["\']?([^\s"\']+)', attrs, re.IGNORECASE,
            )
            if m:
                action = m.group(1)

            user_field = "username"
            for pattern in (
                r'name\s*=\s*["\']?(user\w*|login|email|name)',
            ):
                um = re.search(pattern, content, re.IGNORECASE)
                if um:
                    user_field = um.group(1)
                    break

            pass_field = "password"
            pm = re.search(
                r'name\s*=\s*["\']?(pass\w*|pwd|passwd)',
                content, re.IGNORECASE,
            )
            if pm:
                pass_field = pm.group(1)

            return (action or url, user_field, pass_field)

        return None

    async def _try_login(
        self, ctx, url: str,
        user_field: str, pass_field: str,
        username: str, password: str,
    ) -> bool:
        """Try a single credential pair. Return True if login succeeds."""
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data={user_field: username, pass_field: password},
                    timeout=8.0,
                    allow_redirects=True,
                )
                body = await resp.text(
                    encoding="utf-8", errors="replace",
                )
                body_lower = body.lower()

                # Check for success markers (no fail markers)
                has_success = any(
                    m in body_lower for m in SUCCESS_MARKERS
                )
                has_fail = any(
                    m in body_lower for m in FAIL_MARKERS
                )
                if has_success and not has_fail:
                    return True

                # Redirect to dashboard-like URL
                final_url = str(resp.url).lower()
                if (
                    any(m in final_url for m in (
                        "dashboard", "panel", "admin", "home",
                    ))
                    and not has_fail
                ):
                    return True

        except Exception as e:
            logger.debug("admin_brute: %s", e)
        return False
