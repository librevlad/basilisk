"""Active subdomain takeover detection â€” CNAME + HTTP fingerprint checks."""

from __future__ import annotations

import logging
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Service fingerprints: service name -> pattern in HTTP response body
TAKEOVER_SIGNATURES: dict[str, str] = {
    "GitHub Pages": "There isn't a GitHub Pages site here",
    "Heroku": "No such app",
    "AWS S3": "NoSuchBucket",
    "AWS Elastic Beanstalk": "NXDOMAIN",
    "Shopify": "Sorry, this shop is currently unavailable",
    "Tumblr": "There's nothing here",
    "WordPress.com": "Do you want to register",
    "Pantheon": "404 error unknown site",
    "Fastly": "Fastly error: unknown domain",
    "Surge.sh": "project not found",
    "Zendesk": "Help Center Closed",
    "Bitbucket": "Repository not found",
    "Azure": "404 Web Site not found",
    "Smugmug": "SmugMug",
    "Strikingly": "page not found",
    "Unbounce": "The requested URL was not found",
    "Agile CRM": "Sorry, this page is no longer available",
    "Campaignmonitor": "Trying to access your account?",
    "Cargo": "If you're moving your domain away",
    "Feedpress": "The feed has not been found",
    "Ghost": "The thing you were looking for is no longer here",
    "Helpjuice": "We could not find what you're looking for",
    "Helpscout": "No settings were found for this company",
    "Intercom": "This page is reserved for artistic dogs",
    "JetBrains": "is not a registered InCloud YouTrack",
    "Kinsta": "No site with that domain",
    "LaunchRock": "It looks like you may have taken a wrong turn",
    "Readme.io": "Project doesnt exist",
    "Tilda": "Please renew your subscription",
    "Fly.io": "404 Not Found",
    "Discourse": "you've found a page that doesn't exist",
    "Webflow": "The page you are looking for doesn't exist",
    "Statuspage": "You are being redirected",
    "Freshdesk": "There is no helpdesk here",
    "ReadTheDocs": "unknown to Read the Docs",
    "Canny": "Company Not Found",
    "UserVoice": "This UserVoice subdomain is currently available",
    "Gemfury": "404: This page could not be found",
    "Pingdom": "pingdom",
    "Teamwork": "Oops - We didn't find your site",
    "HatenaBlog": "404 Blog is not found",
    "Netlify": "Not Found - Request ID:",
    "Vercel": "The deployment could not be found",
    "Render": "not found",
    "Aha!": "There is no portal here",
    "Aftership": "Oops, page not found",
    "Bigcartel": "Oops! We couldn't find that page",
    "Acquia": "The site you are looking for could not be found",
    "Desk.com": "Please try again or try Desk.com free",
    "Thinkific": "You may have mistyped the address",
    "Mashery": "Unrecognized domain",
    "Brightcove": "Error - Account Not Found",
    "Airee.ru": "\u041e\u0448\u0438\u0431\u043a\u0430 402. \u0421\u0435\u0440\u0432\u0438\u0441",
    "Anima": "If this is your website and you've just created it",
    "Wufoo": "Hmmm....looks like you've gotten lost",
}

# CNAME patterns that map to known services
_CNAME_SERVICE_MAP: dict[str, str] = {
    "github.io": "GitHub Pages",
    "herokuapp.com": "Heroku",
    "herokudns.com": "Heroku",
    "s3.amazonaws.com": "AWS S3",
    "s3-website": "AWS S3",
    "amazonaws.com": "AWS S3",
    "myshopify.com": "Shopify",
    "domains.tumblr.com": "Tumblr",
    "wordpress.com": "WordPress.com",
    "pantheonsite.io": "Pantheon",
    "fastly.net": "Fastly",
    "surge.sh": "Surge.sh",
    "zendesk.com": "Zendesk",
    "bitbucket.io": "Bitbucket",
    "azurewebsites.net": "Azure",
    "cloudapp.net": "Azure",
    "azure-api.net": "Azure",
    "trafficmanager.net": "Azure",
    "smugmug.com": "Smugmug",
    "strikingly.com": "Strikingly",
    "unbouncepages.com": "Unbounce",
    "agilecrm.com": "Agile CRM",
    "createsend.com": "Campaignmonitor",
    "cargocollective.com": "Cargo",
    "redirect.feedpress.me": "Feedpress",
    "ghost.io": "Ghost",
    "helpjuice.com": "Helpjuice",
    "helpscoutdocs.com": "Helpscout",
    "custom.intercom.help": "Intercom",
    "myjetbrains.com": "JetBrains",
    "kinsta.cloud": "Kinsta",
    "launchrock.com": "LaunchRock",
    "readme.io": "Readme.io",
    "tilda.ws": "Tilda",
    "fly.dev": "Fly.io",
    "discourse-cdn.com": "Discourse",
    "proxy-ssl.webflow.com": "Webflow",
    "statuspage.io": "Statuspage",
    "freshdesk.com": "Freshdesk",
    "readthedocs.io": "ReadTheDocs",
    "cname.canny.io": "Canny",
    "uservoice.com": "UserVoice",
    "furyns.com": "Gemfury",
    "pingdom.com": "Pingdom",
    "teamwork.com": "Teamwork",
    "vercel.app": "Vercel",
    "onrender.com": "Render",
    "bigcartel.com": "Bigcartel",
    "acquia-sites.com": "Acquia",
    "mashery.com": "Mashery",
}


class SubdomainTakeoverActivePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="subdomain_takeover_active",
        display_name="Active Subdomain Takeover",
        category=PluginCategory.PENTESTING,
        description=(
            "Actively checks for subdomain takeover via CNAME resolution, "
            "NXDOMAIN detection, and HTTP fingerprint matching"
        ),
        depends_on=["dns_enum"],
        produces=["takeover_active_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.dns is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="DNS client not available",
            )
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        findings: list[Finding] = []
        checked: list[dict[str, Any]] = []

        # Collect hosts to check: main target + discovered subdomains
        hosts = [target.host]
        hosts.extend(self._collect_subdomains(target, ctx))
        # Deduplicate while preserving order
        seen: set[str] = set()
        unique_hosts: list[str] = []
        for h in hosts:
            if h not in seen:
                seen.add(h)
                unique_hosts.append(h)

        for host in unique_hosts:
            result = await self._check_host(host, ctx)
            checked.append(result)

            if result.get("takeover_confirmed"):
                service = result["service"]
                findings.append(Finding.critical(
                    f"Subdomain takeover possible on {host}"
                    f" via {service}",
                    description=(
                        f"CNAME points to {service} and the HTTP"
                        f" response matches the takeover fingerprint."
                        f" An attacker can claim this subdomain."
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        f"Remove the DNS CNAME record for {host},"
                        f" or reclaim the resource on {service}."
                    ),
                    tags=[
                        "pentesting", "takeover",
                        service.lower().replace(" ", "_"),
                    ],
                ))
            elif result.get("dangling_cname"):
                cname_target = result["cname_target"]
                findings.append(Finding.high(
                    f"Dangling CNAME: {host} -> {cname_target}",
                    description=(
                        f"CNAME record exists for {host} pointing"
                        f" to {cname_target}, but the target does"
                        " not resolve (NXDOMAIN). This is a strong"
                        " indicator of a potential takeover."
                    ),
                    evidence=f"CNAME: {host} -> {cname_target}",
                    remediation=(
                        f"Remove the dangling CNAME record for"
                        f" {host}, or reclaim the resource at"
                        f" {cname_target}."
                    ),
                    tags=["pentesting", "takeover", "dangling_cname"],
                ))

        if not findings:
            findings.append(Finding.info(
                "No subdomain takeover vulnerabilities detected",
                tags=["pentesting", "takeover"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "hosts_checked": len(unique_hosts),
                "takeover_results": checked,
            },
        )

    def _collect_subdomains(
        self, target: Target, ctx,
    ) -> list[str]:
        """Gather discovered subdomains from pipeline results."""
        subdomains: list[str] = []
        for _key, result in ctx.pipeline.items():
            if not result.ok:
                continue
            # Match subdomain provider results for this target
            subs = result.data.get("subdomains", [])
            if subs and result.target == target.host:
                subdomains.extend(subs)
        return subdomains

    async def _check_host(
        self, host: str, ctx,
    ) -> dict[str, Any]:
        """Check a single host for takeover indicators."""
        info: dict[str, Any] = {
            "host": host,
            "cname_target": None,
            "service": None,
            "dangling_cname": False,
            "takeover_confirmed": False,
            "evidence": "",
        }

        # Step 1: Resolve CNAME
        cname_target = await self._resolve_cname(host, ctx)
        if not cname_target:
            return info
        info["cname_target"] = cname_target

        # Identify service from CNAME
        service = self._identify_service(cname_target)
        if service:
            info["service"] = service

        # Step 2: Check if CNAME target resolves (NXDOMAIN check)
        is_dangling = await self._is_nxdomain(cname_target, ctx)
        if is_dangling:
            info["dangling_cname"] = True
            info["evidence"] = (
                f"CNAME {host} -> {cname_target} (NXDOMAIN)"
            )
            # If we know the service AND it's dangling, that's
            # a strong signal even without HTTP check
            if service:
                info["takeover_confirmed"] = True
                return info

        # Step 3: HTTP fingerprint check
        body = await self._fetch_body(host, ctx)
        if not body:
            return info

        matched_service = self._match_signature(body)
        if matched_service:
            info["service"] = matched_service
            info["takeover_confirmed"] = True
            info["evidence"] = body[:300]
        elif is_dangling and not service:
            # Dangling CNAME but unknown service and no body match
            # Still report as dangling
            pass

        return info

    async def _resolve_cname(
        self, host: str, ctx,
    ) -> str | None:
        """Resolve CNAME record for a host. Returns target or None."""
        try:
            async with ctx.rate:
                records = await ctx.dns.resolve(host, "CNAME")
            if records:
                return records[0].value
        except Exception:
            logger.debug("CNAME lookup failed for %s", host)
        return None

    async def _is_nxdomain(
        self, host: str, ctx,
    ) -> bool:
        """Check if a hostname does not resolve (NXDOMAIN)."""
        try:
            async with ctx.rate:
                a_records = await ctx.dns.resolve(host, "A")
            if a_records:
                return False
            async with ctx.rate:
                aaaa_records = await ctx.dns.resolve(host, "AAAA")
            return not aaaa_records
        except Exception:
            return True

    async def _fetch_body(
        self, host: str, ctx,
    ) -> str:
        """Fetch HTTP response body from a host."""
        for scheme in ("https", "http"):
            url = f"{scheme}://{host}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    return await resp.text(
                        encoding="utf-8", errors="replace",
                    )
            except Exception:
                continue
        return ""

    @staticmethod
    def _identify_service(cname_target: str) -> str | None:
        """Identify a service from the CNAME target hostname."""
        cname_lower = cname_target.lower()
        for pattern, service in _CNAME_SERVICE_MAP.items():
            if pattern in cname_lower:
                return service
        return None

    @staticmethod
    def _match_signature(body: str) -> str | None:
        """Check response body against known takeover signatures."""
        for service, fingerprint in TAKEOVER_SIGNATURES.items():
            if fingerprint.lower() in body.lower():
                return service
        return None
