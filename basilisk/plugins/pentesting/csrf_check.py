"""CSRF protection analysis â€” form tokens, SameSite cookies, Referer policy.

Checks for:
1. POST forms without anti-CSRF tokens
2. SameSite cookie attribute analysis
3. Token reuse detection (same token across requests)
4. Content-Type enforcement on API endpoints
5. Referer/Origin header policy
"""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

CSRF_TOKEN_NAMES = {
    "csrf", "csrftoken", "csrf_token", "_token", "authenticity_token",
    "__requestverificationtoken", "csrfmiddlewaretoken", "xsrf-token",
    "_csrf", "anti-csrf-token", "nonce", "csrfkey", "csrf-token",
    "x-csrf-token", "__csrf_magic", "_csrf_token",
}

PAGES_TO_CHECK = [
    "/", "/login", "/contact", "/register", "/account",
    "/settings", "/profile", "/admin", "/checkout",
    "/signup", "/feedback", "/comment",
]


class CsrfCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="csrf_check",
        display_name="CSRF Protection Check",
        category=PluginCategory.PENTESTING,
        description=(
            "Analyzes forms for anti-CSRF token protection, "
            "SameSite cookie policy, and token reuse"
        ),
        produces=["csrf_findings"],
        timeout=25.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        forms_checked = 0
        unprotected = 0
        csrf_data: dict = {
            "forms_checked": 0,
            "unprotected_forms": [],
            "samesite_analysis": {},
            "token_reuse": False,
        }

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=csrf_data,
            )

        # Phase 1: Form analysis
        csrf_tokens: list[str] = []

        # Combine hardcoded + crawled pages (from web_crawler)
        pages_to_check = list(PAGES_TO_CHECK)
        crawl_key = f"web_crawler:{target.host}"
        crawl_result = ctx.pipeline.get(crawl_key) if ctx.pipeline else None
        if crawl_result and crawl_result.ok and isinstance(crawl_result.data, dict):
            from urllib.parse import urlparse
            # Add crawled URLs
            for url_str in crawl_result.data.get("crawled_urls", []):
                if isinstance(url_str, str):
                    path = urlparse(url_str).path
                    if path and path not in pages_to_check:
                        pages_to_check.append(path)
            # Add form action URLs (pages that definitely have forms)
            for form_info in crawl_result.data.get("forms", []):
                if isinstance(form_info, dict):
                    action = form_info.get("action", "")
                    if action:
                        path = urlparse(action).path
                        if path and path not in pages_to_check:
                            pages_to_check.append(path)

        for page in pages_to_check:
            if ctx.should_stop:
                break

            try:
                async with ctx.rate:
                    resp = await ctx.http.get(f"{base_url}{page}", timeout=8.0)
                    if resp.status != 200:
                        continue
                    body = await resp.text(encoding="utf-8", errors="replace")
            except Exception as e:
                logger.debug("csrf_check: %s", e)
                continue

            forms = re.findall(
                r'<form\b([^>]*)>(.*?)</form>',
                body, re.IGNORECASE | re.DOTALL,
            )
            for attrs, content in forms:
                m = re.search(r'method\s*=\s*["\']?(\w+)', attrs, re.IGNORECASE)
                method = m.group(1).upper() if m else ""

                if method != "POST":
                    continue

                forms_checked += 1
                content_lower = content.lower()

                has_csrf = any(
                    name in content_lower for name in CSRF_TOKEN_NAMES
                )

                # Also check for hidden inputs with long random values
                if not has_csrf:
                    hidden_inputs = re.findall(
                        r'<input[^>]+type=["\']?hidden["\']?[^>]+value=["\']?'
                        r'([a-zA-Z0-9_-]{20,})',
                        content, re.IGNORECASE,
                    )
                    if hidden_inputs:
                        has_csrf = True
                        csrf_tokens.extend(hidden_inputs[:2])

                # Extract CSRF token values
                for name in CSRF_TOKEN_NAMES:
                    token_match = re.search(
                        rf'name=["\']?{re.escape(name)}["\']?\s+'
                        rf'value=["\']?([^"\'>\s]+)',
                        content, re.IGNORECASE,
                    )
                    if token_match:
                        csrf_tokens.append(token_match.group(1))

                if not has_csrf:
                    # Get action URL for context
                    action = ""
                    action_match = re.search(
                        r'action\s*=\s*["\']?([^"\'>\s]+)', attrs, re.IGNORECASE,
                    )
                    if action_match:
                        action = action_match.group(1)

                    unprotected += 1
                    csrf_data.setdefault("unprotected_forms", []).append({
                        "page": page,
                        "action": action or page,
                    })

        csrf_data["forms_checked"] = forms_checked

        if unprotected > 0:
            findings.append(Finding.medium(
                f"CSRF: {unprotected}/{forms_checked} POST form(s) without CSRF token",
                description=(
                    "Forms submit POST requests without visible anti-CSRF tokens."
                ),
                evidence=(
                    "Unprotected forms on: "
                    + ", ".join(
                        f.get("page", "?")
                        for f in csrf_data.get("unprotected_forms", [])[:5]
                    )
                ),
                remediation=(
                    "Add anti-CSRF tokens to all state-changing forms. "
                    "Use framework-provided CSRF middleware."
                ),
                tags=["pentesting", "csrf"],
            ))

        # Phase 2: Token reuse check (same token on multiple requests)
        if len(csrf_tokens) >= 2 and not ctx.should_stop:
            unique_tokens = set(csrf_tokens)
            if len(unique_tokens) == 1:
                csrf_data["token_reuse"] = True
                findings.append(Finding.medium(
                    "CSRF tokens are static (reused across requests)",
                    description=(
                        "The same CSRF token value is used across multiple forms/pages. "
                        "This weakens CSRF protection."
                    ),
                    evidence=f"Token: {csrf_tokens[0][:20]}... (seen {len(csrf_tokens)} times)",
                    remediation=(
                        "Generate unique CSRF tokens per session or per request."
                    ),
                    tags=["pentesting", "csrf", "token-reuse"],
                ))

        # Phase 3: SameSite cookie analysis
        if not ctx.should_stop:
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(f"{base_url}/", timeout=5.0)
                    set_cookies = resp.headers.getall("Set-Cookie", [])

                    session_cookies = [
                        c for c in set_cookies
                        if any(
                            kw in c.lower()
                            for kw in ("session", "token", "auth", "sid", "login")
                        )
                    ]

                    for cookie in session_cookies:
                        cookie_lower = cookie.lower()
                        has_samesite = "samesite" in cookie_lower

                        if not has_samesite:
                            cookie_name = cookie.split("=")[0].strip()
                            csrf_data["samesite_analysis"][cookie_name] = "missing"
                            findings.append(Finding.low(
                                f"Session cookie '{cookie_name}' lacks SameSite",
                                description=(
                                    "Session cookie does not set SameSite attribute. "
                                    "Browser defaults may not protect against CSRF."
                                ),
                                evidence=f"Set-Cookie: {cookie[:80]}...",
                                remediation="Set SameSite=Lax or SameSite=Strict.",
                                tags=["pentesting", "csrf", "samesite"],
                            ))
                        elif "samesite=none" in cookie_lower:
                            cookie_name = cookie.split("=")[0].strip()
                            csrf_data["samesite_analysis"][cookie_name] = "none"
                            findings.append(Finding.low(
                                f"Session cookie '{cookie_name}': SameSite=None",
                                description=(
                                    "SameSite=None means cookie is sent on cross-site "
                                    "requests, providing no CSRF protection."
                                ),
                                evidence=f"Set-Cookie: {cookie[:80]}...",
                                remediation="Use SameSite=Lax or SameSite=Strict.",
                                tags=["pentesting", "csrf", "samesite"],
                            ))
            except Exception as e:
                logger.debug("csrf_check: %s", e)

        if not findings:
            if forms_checked > 0:
                findings.append(Finding.info(
                    f"All {forms_checked} POST forms have CSRF tokens",
                    tags=["pentesting", "csrf"],
                ))
            else:
                findings.append(Finding.info(
                    "No POST forms found to check",
                    tags=["pentesting", "csrf"],
                ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=csrf_data,
        )
