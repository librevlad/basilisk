"""Default credentials checker for common services."""

from __future__ import annotations

from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Common default credential pages and their indicators
DEFAULT_CRED_CHECKS = [
    {
        "path": "/phpmyadmin/",
        "name": "phpMyAdmin",
        "indicator": "phpmyadmin",
    },
    {
        "path": "/adminer.php",
        "name": "Adminer",
        "indicator": "adminer",
    },
    {
        "path": "/solr/",
        "name": "Apache Solr",
        "indicator": "solr",
    },
    {
        "path": "/jenkins/",
        "name": "Jenkins",
        "indicator": "jenkins",
    },
    {
        "path": "/manager/html",
        "name": "Tomcat Manager",
        "indicator": "tomcat",
    },
    {
        "path": "/_plugin/head/",
        "name": "Elasticsearch Head",
        "indicator": "elasticsearch",
    },
    {
        "path": "/kibana/",
        "name": "Kibana",
        "indicator": "kibana",
    },
    {
        "path": "/grafana/",
        "name": "Grafana",
        "indicator": "grafana",
    },
    {
        "path": "/portainer/",
        "name": "Portainer",
        "indicator": "portainer",
    },
    {
        "path": "/zabbix/",
        "name": "Zabbix",
        "indicator": "zabbix",
    },
    {
        "path": "/nagios/",
        "name": "Nagios",
        "indicator": "nagios",
    },
    {
        "path": "/cacti/",
        "name": "Cacti",
        "indicator": "cacti",
    },
    {
        "path": "/rabbitmq/",
        "name": "RabbitMQ Management",
        "indicator": "rabbitmq",
    },
    {
        "path": "/flower/",
        "name": "Celery Flower",
        "indicator": "flower",
    },
    {
        "path": "/mongo-express/",
        "name": "Mongo Express",
        "indicator": "mongo express",
    },
    {
        "path": "/redis-commander/",
        "name": "Redis Commander",
        "indicator": "redis commander",
    },
    {
        "path": "/_utils/",
        "name": "CouchDB Fauxton",
        "indicator": "fauxton",
    },
    {
        "path": "/minio/",
        "name": "MinIO Console",
        "indicator": "minio",
    },
    {
        "path": "/ui/",
        "name": "Consul UI",
        "indicator": "consul",
    },
    {
        "path": "/ui/vault/",
        "name": "HashiCorp Vault",
        "indicator": "vault",
    },
    {
        "path": "/traefik/",
        "name": "Traefik Dashboard",
        "indicator": "traefik",
    },
    {
        "path": "/pgadmin4/",
        "name": "pgAdmin",
        "indicator": "pgadmin",
    },
    {
        "path": "/webmin/",
        "name": "Webmin",
        "indicator": "webmin",
    },
    {
        "path": "/cockpit/",
        "name": "Cockpit",
        "indicator": "cockpit",
    },
    {
        "path": "/netdata/",
        "name": "Netdata",
        "indicator": "netdata",
    },
]


class DefaultCredsPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="default_creds",
        display_name="Default Credentials Check",
        category=PluginCategory.PENTESTING,
        description="Detects services with potential default credentials",
        produces=["default_creds_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        found_services: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception:
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"services": []},
            )

        # Fetch SPA baseline to detect catch-all routing
        spa_baseline = ""
        try:
            async with ctx.rate:
                r = await ctx.http.get(
                    f"{base_url}/_nonexistent_8x7z_test/", timeout=5.0,
                )
                if r.status == 200:
                    spa_baseline = await r.text(
                        encoding="utf-8", errors="replace",
                    )
        except Exception:
            pass

        for check in DEFAULT_CRED_CHECKS:
            url = f"{base_url}{check['path']}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=5.0)
                    if resp.status in (200, 301, 302, 401):
                        body = ""
                        if resp.status == 200:
                            body = await resp.text(encoding="utf-8", errors="replace")

                        # Skip SPA catch-all responses
                        if (
                            resp.status == 200
                            and spa_baseline
                            and abs(len(body) - len(spa_baseline)) < 100
                            and body[:200] == spa_baseline[:200]
                        ):
                            continue

                        if resp.status == 200 and check["indicator"] in body.lower():
                            found_services.append({
                                "name": check["name"],
                                "path": check["path"],
                                "status": resp.status,
                            })
                            findings.append(Finding.high(
                                f"{check['name']} detected (may have default credentials)",
                                description=(
                                    f"{check['name']} is accessible and may "
                                    "be using default credentials"
                                ),
                                evidence=url,
                                remediation=(
                                    f"Change default credentials for {check['name']} "
                                    "and restrict access"
                                ),
                                tags=["pentesting", "default-creds"],
                            ))
                        elif resp.status == 401:
                            found_services.append({
                                "name": check["name"],
                                "path": check["path"],
                                "status": 401,
                            })
                            findings.append(Finding.info(
                                f"{check['name']} found but requires auth",
                                evidence=url,
                                tags=["pentesting", "default-creds"],
                            ))
            except Exception:
                continue

        if not findings:
            findings.append(Finding.info(
                f"No default-credential services found ({len(DEFAULT_CRED_CHECKS)} checked)",
                tags=["pentesting", "default-creds"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"services": found_services},
        )
