"""Service default credentials check — tests common/default passwords on discovered services."""

from __future__ import annotations

import asyncio
import contextlib
import logging
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Service definitions with default credentials to test
SERVICE_CREDS: dict[str, dict[str, Any]] = {
    "ftp": {
        "port": 21,
        "creds": [
            ("anonymous", ""), ("anonymous", "anonymous@"),
            ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
            ("ftp", "ftp"), ("user", "user"), ("test", "test"),
        ],
    },
    "redis": {
        "port": 6379,
        "creds": [
            ("", ""), ("", "redis"), ("", "password"),
            ("", "123456"), ("", "admin"),
        ],
    },
    "mysql": {
        "port": 3306,
        "creds": [
            ("root", ""), ("root", "root"), ("root", "password"),
            ("root", "mysql"), ("root", "123456"), ("admin", "admin"),
            ("mysql", "mysql"), ("dbadmin", "dbadmin"),
        ],
    },
    "postgresql": {
        "port": 5432,
        "creds": [
            ("postgres", "postgres"), ("postgres", "password"),
            ("postgres", "123456"), ("admin", "admin"),
            ("postgres", ""), ("dbuser", "dbuser"),
        ],
    },
    "mongodb": {
        "port": 27017,
        "creds": [("", "")],  # Just check no-auth
    },
    "vnc": {
        "port": 5900,
        "creds": [
            ("", ""), ("", "password"), ("", "vnc"), ("", "123456"),
        ],
    },
}


class ServiceBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="service_brute",
        display_name="Service Default Credentials",
        category=PluginCategory.PENTESTING,
        description="Tests default/weak credentials on discovered services",
        depends_on=["port_scan", "service_detect"],
        default_enabled=False,
        produces=["service_brute_findings"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        results: list[dict] = []

        # Get open ports from pipeline
        port_key = f"port_scan:{target.host}"
        port_result = ctx.pipeline.get(port_key)
        open_ports: set[int] = set()
        if port_result and port_result.ok:
            open_ports = {p["port"] for p in port_result.data.get("open_ports", [])}

        if not open_ports:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No open ports — skipping credential check",
                    tags=["pentesting", "brute"],
                )],
                data={"brute_results": []},
            )

        for service_name, service_info in SERVICE_CREDS.items():
            port = service_info["port"]
            if port not in open_ports:
                continue

            creds = service_info["creds"]
            result = await self._check_service(
                target.host, port, service_name, creds,
            )
            results.append(result)

            if result.get("success"):
                user = result.get("username", "")
                passwd = result.get("password", "")
                cred_str = f"{user}:{passwd}" if user else "(no auth)"

                findings.append(Finding.critical(
                    f"Default credentials on {service_name} "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} accepts "
                        f"credentials: {cred_str}"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        f"Change default credentials for {service_name}. "
                        "Use strong, unique passwords."
                    ),
                    tags=["pentesting", "brute", service_name],
                ))
            elif result.get("no_auth"):
                findings.append(Finding.critical(
                    f"{service_name} requires no authentication "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} is accessible "
                        "without any authentication"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        f"Enable authentication for {service_name}."
                    ),
                    tags=["pentesting", "brute", service_name],
                ))

        if not findings:
            findings.append(Finding.info(
                "No default credentials found on open services",
                tags=["pentesting", "brute"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"brute_results": results},
        )

    async def _check_service(
        self,
        host: str,
        port: int,
        service: str,
        creds: list[tuple[str, str]],
    ) -> dict[str, Any]:
        """Dispatch to appropriate protocol handler."""
        info: dict[str, Any] = {
            "service": service,
            "port": port,
            "success": False,
            "no_auth": False,
        }

        try:
            if service == "ftp":
                return await self._check_ftp(host, port, creds, info)
            elif service == "redis":
                return await self._check_redis(host, port, creds, info)
            elif service == "mysql":
                return await self._check_mysql(host, port, info)
            elif service == "postgresql":
                return await self._check_postgresql(host, port, info)
            elif service == "mongodb":
                return await self._check_mongodb(host, port, info)
            elif service == "vnc":
                return await self._check_vnc(host, port, info)
        except Exception:
            logger.debug("Error checking %s on %s:%d", service, host, port)

        return info

    async def _check_ftp(
        self,
        host: str,
        port: int,
        creds: list[tuple[str, str]],
        info: dict,
    ) -> dict:
        """Test FTP credentials via raw socket."""
        for username, password in creds:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port), timeout=3,
                )
                try:
                    # Read banner
                    await asyncio.wait_for(reader.readline(), timeout=3)

                    # Send USER
                    writer.write(f"USER {username}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.readline(), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()

                    # 230 = logged in without password
                    if resp_str.startswith("230"):
                        info["success"] = True
                        info["username"] = username
                        info["password"] = ""
                        info["evidence"] = f"FTP: {resp_str}"
                        return info

                    # 331 = need password
                    if resp_str.startswith("331"):
                        writer.write(f"PASS {password}\r\n".encode())
                        await writer.drain()
                        resp = await asyncio.wait_for(
                            reader.readline(), timeout=3,
                        )
                        resp_str = resp.decode("utf-8", errors="replace").strip()
                        if resp_str.startswith("230"):
                            info["success"] = True
                            info["username"] = username
                            info["password"] = password
                            info["evidence"] = f"FTP login: {resp_str}"
                            return info
                finally:
                    writer.close()
                    with contextlib.suppress(Exception):
                        await writer.wait_closed()
            except Exception:
                continue

        return info

    async def _check_redis(
        self,
        host: str,
        port: int,
        creds: list[tuple[str, str]],
        info: dict,
    ) -> dict:
        """Test Redis with AUTH command or no-auth PING."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                # Try PING without auth first
                writer.write(b"PING\r\n")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(256), timeout=3)
                resp_str = resp.decode("utf-8", errors="replace").strip()

                if "+PONG" in resp_str:
                    info["no_auth"] = True
                    info["evidence"] = f"Redis PING: {resp_str}"
                    return info

                # Try AUTH with passwords
                for _, password in creds:
                    if not password:
                        continue
                    writer.write(f"AUTH {password}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.read(256), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()
                    if "+OK" in resp_str:
                        info["success"] = True
                        info["username"] = ""
                        info["password"] = password
                        info["evidence"] = f"Redis AUTH: {resp_str}"
                        return info
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass

        return info

    async def _check_mysql(
        self, host: str, port: int, info: dict,
    ) -> dict:
        """Check MySQL by reading the greeting packet."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                data = await asyncio.wait_for(reader.read(1024), timeout=3)
                if data and len(data) > 4:
                    # MySQL greeting packet
                    greeting = data.decode("utf-8", errors="replace")
                    if "mysql" in greeting.lower() or data[4] == 10:
                        info["evidence"] = f"MySQL greeting: {greeting[:100]}"
                        # MySQL requires auth packet to test further
                        # Just report the service is reachable
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass

        return info

    async def _check_postgresql(
        self, host: str, port: int, info: dict,
    ) -> dict:
        """Check PostgreSQL by sending a startup message."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                # Send SSLRequest
                writer.write(b"\x00\x00\x00\x08\x04\xd2\x16\x2f")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(1), timeout=3)
                if resp in (b"N", b"S"):
                    info["evidence"] = (
                        f"PostgreSQL responds to SSLRequest: "
                        f"{'SSL supported' if resp == b'S' else 'SSL not supported'}"
                    )
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass

        return info

    async def _check_mongodb(
        self, host: str, port: int, info: dict,
    ) -> dict:
        """Check if MongoDB accepts connections without auth."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                # Try to read banner
                try:
                    data = await asyncio.wait_for(reader.read(512), timeout=2)
                    banner = data.decode("utf-8", errors="replace")
                    if data:
                        info["no_auth"] = True
                        info["evidence"] = (
                            f"MongoDB connection accepted: {banner[:100]}"
                        )
                except TimeoutError:
                    # MongoDB doesn't send a banner, but connection was accepted
                    info["no_auth"] = True
                    info["evidence"] = "MongoDB TCP connection accepted (no banner)"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass

        return info

    async def _check_vnc(
        self, host: str, port: int, info: dict,
    ) -> dict:
        """Check VNC by reading RFB handshake."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                data = await asyncio.wait_for(reader.read(12), timeout=3)
                if data and data.startswith(b"RFB"):
                    version = data.decode("utf-8", errors="replace").strip()
                    info["evidence"] = f"VNC version: {version}"

                    # Send our version back
                    writer.write(data)
                    await writer.drain()

                    # Read security types
                    sec_data = await asyncio.wait_for(
                        reader.read(256), timeout=3,
                    )
                    if sec_data and len(sec_data) > 1:
                        num_types = sec_data[0]
                        if num_types > 0:
                            sec_types = list(sec_data[1:1 + num_types])
                            # SecurityType 1 = None (no auth required)
                            if 1 in sec_types:
                                info["no_auth"] = True
                                info["evidence"] = (
                                    f"VNC {version} — no authentication required"
                                )
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass

        return info
