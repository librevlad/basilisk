"""Service default credentials check — tests common/default passwords on discovered services.

Supports FTP, Redis, MySQL, PostgreSQL, MongoDB, VNC, Memcached, Elasticsearch,
CouchDB, SNMP. Lockout-aware with configurable concurrency.
"""

from __future__ import annotations

import asyncio
import base64
import contextlib
import hashlib
import hmac
import logging
import os
import struct
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Service definitions with default credentials
SERVICE_CREDS: dict[str, dict[str, Any]] = {
    "ftp": {
        "port": 21,
        "creds": [
            ("anonymous", ""), ("anonymous", "anonymous@"),
            ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
            ("ftp", "ftp"), ("user", "user"), ("test", "test"),
            ("admin", "ftp"), ("root", "root"), ("www", "www"),
        ],
    },
    "redis": {
        "port": 6379,
        "creds": [
            ("", ""), ("", "redis"), ("", "password"),
            ("", "123456"), ("", "admin"), ("", "foobared"),
            ("default", ""), ("default", "redis"),
        ],
    },
    "mysql": {
        "port": 3306,
        "creds": [
            ("root", ""), ("root", "root"), ("root", "password"),
            ("root", "mysql"), ("root", "123456"), ("admin", "admin"),
            ("mysql", "mysql"), ("dbadmin", "dbadmin"),
            ("root", "toor"), ("root", "changeme"),
        ],
    },
    "postgresql": {
        "port": 5432,
        "creds": [
            ("postgres", "postgres"), ("postgres", "password"),
            ("postgres", "123456"), ("admin", "admin"),
            ("postgres", ""), ("dbuser", "dbuser"),
            ("postgres", "changeme"), ("postgres", "admin"),
        ],
    },
    "mongodb": {
        "port": 27017,
        "creds": [("", "")],
    },
    "vnc": {
        "port": 5900,
        "creds": [
            ("", ""), ("", "password"), ("", "vnc"), ("", "123456"),
            ("", "admin"), ("", "1234"),
        ],
    },
    "memcached": {
        "port": 11211,
        "creds": [("", "")],
    },
    "elasticsearch": {
        "port": 9200,
        "creds": [
            ("", ""), ("elastic", "changeme"), ("elastic", "elastic"),
            ("admin", "admin"),
        ],
    },
    "couchdb": {
        "port": 5984,
        "creds": [
            ("admin", "admin"), ("admin", "password"),
            ("root", "root"), ("couchdb", "couchdb"),
        ],
    },
    "smb": {
        "port": 445,
        "creds": [
            ("admin", "admin"), ("admin", "password"),
            ("admin", "123456"), ("administrator", "administrator"),
            ("administrator", "password"), ("guest", ""),
            ("root", "root"), ("user", "user"),
        ],
    },
}


class ServiceBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="service_brute",
        display_name="Service Default Credentials",
        category=PluginCategory.PENTESTING,
        description=(
            f"Tests default/weak credentials on {len(SERVICE_CREDS)} services: "
            "FTP, Redis, MySQL, PostgreSQL, MongoDB, VNC, Memcached, "
            "Elasticsearch, CouchDB, SMB"
        ),
        depends_on=["port_scan", "service_detect"],
        default_enabled=True,
        produces=["service_brute_findings"],
        timeout=120.0,
        requires_http=False,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        results: list[dict] = []

        # Get open ports from pipeline
        port_key = f"port_scan:{target.host}"
        port_result = ctx.pipeline.get(port_key)
        open_ports: set[int] = set()
        if port_result and port_result.ok:
            open_ports = {p["port"] for p in port_result.data.get("open_ports", [])}

        if not open_ports:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No open ports — skipping credential check",
                    tags=["pentesting", "brute"],
                )],
                data={"brute_results": []},
            )

        # Build service→port mapping: match by default port AND detected service name
        service_port_map = self._build_service_map(target.host, open_ports, ctx)

        for service_name, port in service_port_map.items():
            if ctx.should_stop:
                break

            creds = SERVICE_CREDS[service_name]["creds"]
            result = await self._check_service(
                target.host, port, service_name, creds, ctx,
            )
            results.append(result)

            if result.get("success"):
                user = result.get("username", "")
                passwd = result.get("password", "")
                cred_str = f"{user}:{passwd}" if user else "(no auth)"

                findings.append(Finding.critical(
                    f"Default credentials on {service_name} "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} accepts "
                        f"credentials: {cred_str}"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        f"Change default credentials for {service_name}. "
                        "Use strong, unique passwords."
                    ),
                    tags=["pentesting", "brute", service_name],
                ))
            elif result.get("no_auth"):
                findings.append(Finding.critical(
                    f"{service_name} requires no authentication "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} is accessible "
                        "without authentication"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=f"Enable authentication for {service_name}.",
                    tags=["pentesting", "brute", service_name],
                ))

        if not findings:
            findings.append(Finding.info(
                "No default credentials found on open services",
                tags=["pentesting", "brute"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"brute_results": results},
        )

    @staticmethod
    def _build_service_map(
        host: str, open_ports: set[int], ctx,
    ) -> dict[str, int]:
        """Map service names to actual ports.

        Matches by default port first, then by detected service name for
        non-standard ports (e.g. SMB on 44500 instead of 445).
        """
        # Service name aliases for matching service_detect output
        aliases: dict[str, set[str]] = {
            "ftp": {"ftp", "vsftpd", "proftpd", "pure-ftpd"},
            "redis": {"redis"},
            "mysql": {"mysql", "mariadb"},
            "postgresql": {"postgresql", "postgres"},
            "mongodb": {"mongodb", "mongo", "mongod"},
            "vnc": {"vnc", "rfb"},
            "memcached": {"memcached", "memcache"},
            "elasticsearch": {"elasticsearch", "elastic"},
            "couchdb": {"couchdb"},
            "smb": {"smb", "samba", "microsoft-ds", "netbios"},
        }

        result: dict[str, int] = {}

        # 1) Match by default port
        for svc_name, svc_info in SERVICE_CREDS.items():
            if svc_info["port"] in open_ports:
                result[svc_name] = svc_info["port"]

        # 2) Match by detected service name for unmapped services
        svc_key = f"service_detect:{host}"
        svc_result = ctx.pipeline.get(svc_key)
        if svc_result and svc_result.ok:
            for detected in svc_result.data.get("services", []):
                det_name = detected.get("service", "").lower()
                det_banner = detected.get("banner", "").lower()
                det_port = detected.get("port", 0)
                if det_port not in open_ports:
                    continue
                for svc_name, svc_aliases in aliases.items():
                    if svc_name in result:
                        continue  # already matched by port
                    if any(
                        a in det_name or a in det_banner for a in svc_aliases
                    ):
                        result[svc_name] = det_port

        # 3) Also check port_scan banners for service hints
        port_key = f"port_scan:{host}"
        port_result = ctx.pipeline.get(port_key)
        if port_result and port_result.ok:
            for p in port_result.data.get("open_ports", []):
                p_svc = p.get("service", "").lower()
                p_banner = p.get("banner", "").lower()
                p_port = p.get("port", 0)
                for svc_name, svc_aliases in aliases.items():
                    if svc_name in result:
                        continue
                    if any(a in p_svc or a in p_banner for a in svc_aliases):
                        result[svc_name] = p_port

        return result

    async def _check_service(
        self, host: str, port: int, service: str,
        creds: list[tuple[str, str]], ctx=None,
    ) -> dict[str, Any]:
        info: dict[str, Any] = {
            "service": service, "port": port,
            "success": False, "no_auth": False,
        }

        try:
            if service == "ftp":
                return await self._check_ftp(host, port, creds, info)
            elif service == "redis":
                return await self._check_redis(host, port, creds, info)
            elif service == "mysql":
                return await self._check_mysql(host, port, creds, info)
            elif service == "postgresql":
                return await self._check_postgresql(host, port, creds, info)
            elif service == "mongodb":
                return await self._check_mongodb(host, port, info)
            elif service == "vnc":
                return await self._check_vnc(host, port, info)
            elif service == "memcached":
                return await self._check_memcached(host, port, info)
            elif service == "elasticsearch":
                return await self._check_elasticsearch(host, port, creds, info, ctx)
            elif service == "couchdb":
                return await self._check_couchdb(host, port, creds, info, ctx)
            elif service == "smb":
                return await self._check_smb(host, port, creds, info)
        except Exception:
            logger.debug("Error checking %s on %s:%d", service, host, port)

        return info

    async def _check_ftp(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        for username, password in creds:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port), timeout=3,
                )
                try:
                    await asyncio.wait_for(reader.readline(), timeout=3)
                    writer.write(f"USER {username}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.readline(), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()

                    if resp_str.startswith("230"):
                        info.update(success=True, username=username,
                                    password="", evidence=f"FTP: {resp_str}")
                        return info

                    if resp_str.startswith("331"):
                        writer.write(f"PASS {password}\r\n".encode())
                        await writer.drain()
                        resp = await asyncio.wait_for(reader.readline(), timeout=3)
                        resp_str = resp.decode("utf-8", errors="replace").strip()
                        if resp_str.startswith("230"):
                            info.update(success=True, username=username,
                                        password=password, evidence=f"FTP: {resp_str}")
                            return info
                finally:
                    writer.close()
                    with contextlib.suppress(Exception):
                        await writer.wait_closed()
            except Exception as e:
                logger.debug("service_brute: %s", e)
                continue
        return info

    async def _check_redis(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                writer.write(b"PING\r\n")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(256), timeout=3)
                resp_str = resp.decode("utf-8", errors="replace").strip()

                if "+PONG" in resp_str:
                    # Also try INFO to confirm full access
                    writer.write(b"INFO server\r\n")
                    await writer.drain()
                    info_resp = await asyncio.wait_for(reader.read(1024), timeout=3)
                    info_str = info_resp.decode("utf-8", errors="replace")

                    info["no_auth"] = True
                    info["evidence"] = f"Redis PING: {resp_str}"
                    if "redis_version" in info_str:
                        info["evidence"] += f" | {info_str[:100]}"
                    return info

                for _, password in creds:
                    if not password:
                        continue
                    writer.write(f"AUTH {password}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.read(256), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()
                    if "+OK" in resp_str:
                        info.update(success=True, username="", password=password,
                                    evidence=f"Redis AUTH: {resp_str}")
                        return info
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception as e:
            logger.debug("service_brute: %s", e)
        return info

    # ------------------------------------------------------------------
    # MySQL — proper protocol handshake with mysql_native_password
    # and caching_sha2_password (MySQL 8.0 default) support.
    # ------------------------------------------------------------------

    async def _check_mysql(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        """Check MySQL with proper protocol handshake authentication."""
        for username, password in creds:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port), timeout=5,
                )
                try:
                    evidence = await self._mysql_auth(reader, writer, username, password)
                    if evidence:
                        info.update(
                            success=True, username=username, password=password,
                            evidence=evidence,
                        )
                        return info
                finally:
                    writer.close()
                    with contextlib.suppress(Exception):
                        await writer.wait_closed()
            except Exception as e:
                logger.debug("service_brute mysql %s:%s: %s", username, password, e)
                continue

        if not info.get("evidence"):
            info["evidence"] = "MySQL detected — all credential pairs rejected"
        return info

    async def _mysql_auth(
        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
        username: str, password: str,
    ) -> str | None:
        """Attempt MySQL authentication, returns evidence string on success."""
        # Read server greeting packet
        pkt_len, seq, greeting = await self._read_mysql_pkt(reader)
        if not greeting or greeting[0] != 10:
            return None

        # Parse greeting: protocol(1), version(NUL), conn_id(4), scramble1(8),
        # filler(1), caps_lo(2), charset(1), status(2), caps_hi(2),
        # auth_data_len(1), reserved(10), scramble2(variable), plugin(NUL)
        pos = 1
        null_idx = greeting.index(0, pos)
        version = greeting[pos:null_idx].decode("utf-8", errors="replace")
        pos = null_idx + 1 + 4  # skip version + conn_id

        scramble1 = greeting[pos:pos + 8]
        pos += 8 + 1  # skip scramble1 + filler

        scramble2 = b""
        auth_plugin = "mysql_native_password"

        if pos + 2 <= len(greeting):
            pos += 2  # caps_lower
            if pos + 5 <= len(greeting):
                pos += 1 + 2 + 2  # charset + status + caps_upper
                adl = greeting[pos]
                pos += 1 + 10  # auth_data_len + reserved

                s2_len = max(13, adl - 8) if adl > 0 else 13
                scramble2 = greeting[pos:pos + s2_len].rstrip(b"\x00")
                pos += s2_len

                if pos < len(greeting) and 0 in greeting[pos:]:
                    end = greeting.index(0, pos)
                    auth_plugin = greeting[pos:end].decode("utf-8", errors="replace")

        scramble = scramble1 + scramble2

        # Build auth response based on server's auth plugin
        if auth_plugin == "caching_sha2_password" and password:
            auth_data = self._mysql_sha256_scramble(password, scramble)
        elif password:
            auth_data = self._mysql_native_scramble(password, scramble)
        else:
            auth_data = b""

        # Build HandshakeResponse41
        caps = (
            0x00000001  # CLIENT_LONG_PASSWORD
            | 0x00000004  # CLIENT_LONG_FLAG
            | 0x00000200  # CLIENT_PROTOCOL_41
            | 0x00002000  # CLIENT_TRANSACTIONS
            | 0x00008000  # CLIENT_SECURE_CONNECTION
            | 0x00080000  # CLIENT_PLUGIN_AUTH
        )
        pkt = struct.pack("<IIB", caps, 16 * 1024 * 1024, 33)  # caps, max_pkt, charset
        pkt += b"\x00" * 23  # reserved
        pkt += username.encode() + b"\x00"
        pkt += bytes([len(auth_data)]) + auth_data
        pkt += auth_plugin.encode() + b"\x00"

        self._write_mysql_pkt(writer, pkt, seq + 1)
        await writer.drain()

        # Read response
        _, resp_seq, resp = await self._read_mysql_pkt(reader)
        if not resp:
            return None

        if resp[0] == 0x00:  # OK packet
            return f"MySQL {version}: login success as {username}:{password or '(empty)'}"

        # Handle caching_sha2_password fast/full auth
        if resp[0] == 0x01 and len(resp) > 1:
            result = await self._mysql_handle_sha2(
                reader, writer, resp, resp_seq, password, scramble, version, username,
            )
            if result:
                return result

        # Handle auth switch request
        if resp[0] == 0xFE:
            result = await self._mysql_handle_auth_switch(
                reader, writer, resp, resp_seq, password, scramble, version, username,
            )
            if result:
                return result

        return None

    async def _mysql_handle_sha2(
        self, reader, writer, resp: bytes, resp_seq: int,
        password: str, scramble: bytes, version: str, username: str,
    ) -> str | None:
        """Handle caching_sha2_password fast/full auth response."""
        if resp[1] == 3:  # fast auth success
            _, _, ok = await self._read_mysql_pkt(reader)
            if ok and ok[0] == 0x00:
                return f"MySQL {version}: login success as {username}:{password or '(empty)'}"
        elif resp[1] == 4:  # full auth needed — request RSA public key
            self._write_mysql_pkt(writer, b"\x02", resp_seq + 1)
            await writer.drain()

            _, pk_seq, pk_data = await self._read_mysql_pkt(reader)
            if pk_data and pk_data[0] == 0x01:
                pem = pk_data[1:]
                encrypted = self._mysql_rsa_encrypt(password, scramble, pem)
                if encrypted:
                    self._write_mysql_pkt(writer, encrypted, pk_seq + 1)
                    await writer.drain()

                    _, _, final = await self._read_mysql_pkt(reader)
                    if final and final[0] == 0x00:
                        return (
                            f"MySQL {version}: login success as "
                            f"{username}:{password or '(empty)'}"
                        )
        return None

    async def _mysql_handle_auth_switch(
        self, reader, writer, resp: bytes, resp_seq: int,
        password: str, scramble: bytes, version: str, username: str,
    ) -> str | None:
        """Handle MySQL auth method switch request (0xFE)."""
        plugin_end = resp.index(0, 1) if 0 in resp[1:] else len(resp)
        new_plugin = resp[1:plugin_end].decode("utf-8", errors="replace")
        new_scramble = resp[plugin_end + 1:].rstrip(b"\x00")
        if not new_scramble:
            new_scramble = scramble

        if new_plugin == "mysql_native_password" and password:
            auth_data = self._mysql_native_scramble(password, new_scramble)
        elif new_plugin == "caching_sha2_password" and password:
            auth_data = self._mysql_sha256_scramble(password, new_scramble)
        else:
            auth_data = b""

        self._write_mysql_pkt(writer, auth_data, resp_seq + 1)
        await writer.drain()

        _, sw_seq, sw_resp = await self._read_mysql_pkt(reader)
        if not sw_resp:
            return None

        if sw_resp[0] == 0x00:
            return f"MySQL {version}: login success as {username}:{password or '(empty)'}"

        # Handle sha2 fast/full auth after switch
        if sw_resp[0] == 0x01 and len(sw_resp) > 1:
            return await self._mysql_handle_sha2(
                reader, writer, sw_resp, sw_seq, password, new_scramble, version, username,
            )
        return None

    @staticmethod
    def _mysql_native_scramble(password: str, scramble: bytes) -> bytes:
        """mysql_native_password: SHA1(password) XOR SHA1(scramble + SHA1(SHA1(password)))."""
        h1 = hashlib.sha1(password.encode()).digest()
        h2 = hashlib.sha1(h1).digest()
        h3 = hashlib.sha1(scramble + h2).digest()
        return bytes(a ^ b for a, b in zip(h1, h3, strict=True))

    @staticmethod
    def _mysql_sha256_scramble(password: str, scramble: bytes) -> bytes:
        """caching_sha2_password fast auth scramble."""
        h1 = hashlib.sha256(password.encode()).digest()
        h2 = hashlib.sha256(h1).digest()
        h3 = hashlib.sha256(h2 + scramble).digest()
        return bytes(a ^ b for a, b in zip(h1, h3, strict=True))

    @staticmethod
    def _mysql_rsa_encrypt(password: str, scramble: bytes, pem: bytes) -> bytes | None:
        """Encrypt password with server's RSA public key for full auth."""
        try:
            from cryptography.hazmat.primitives import hashes, serialization
            from cryptography.hazmat.primitives.asymmetric import padding

            public_key = serialization.load_pem_public_key(pem)
            pwd_bytes = (password + "\x00").encode()
            xored = bytes(
                pwd_bytes[i] ^ scramble[i % len(scramble)]
                for i in range(len(pwd_bytes))
            )
            return public_key.encrypt(
                xored,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
                    algorithm=hashes.SHA1(),
                    label=None,
                ),
            )
        except Exception as e:
            logger.debug("MySQL RSA encrypt failed: %s", e)
            return None

    @staticmethod
    async def _read_mysql_pkt(
        reader: asyncio.StreamReader,
    ) -> tuple[int, int, bytes]:
        """Read a MySQL protocol packet. Returns (length, seq_id, payload)."""
        header = await asyncio.wait_for(reader.readexactly(4), timeout=5)
        pkt_len = int.from_bytes(header[:3], "little")
        seq_id = header[3]
        payload = await asyncio.wait_for(reader.readexactly(pkt_len), timeout=5)
        return pkt_len, seq_id, payload

    @staticmethod
    def _write_mysql_pkt(
        writer: asyncio.StreamWriter, data: bytes, seq: int,
    ) -> None:
        """Write a MySQL protocol packet."""
        header = struct.pack("<I", len(data))[:3] + bytes([seq & 0xFF])
        writer.write(header + data)

    # ------------------------------------------------------------------
    # PostgreSQL — StartupMessage + MD5 / SCRAM-SHA-256 / cleartext auth.
    # ------------------------------------------------------------------

    async def _check_postgresql(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        """Check PostgreSQL with proper protocol authentication."""
        for username, password in creds:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port), timeout=5,
                )
                try:
                    evidence = await self._pg_auth(reader, writer, username, password)
                    if evidence:
                        if "trust" in evidence:
                            info.update(no_auth=True, evidence=evidence)
                        else:
                            info.update(
                                success=True, username=username, password=password,
                                evidence=evidence,
                            )
                        return info
                finally:
                    writer.close()
                    with contextlib.suppress(Exception):
                        await writer.wait_closed()
            except Exception as e:
                logger.debug("service_brute pg %s:%s: %s", username, password, e)
                continue

        if not info.get("evidence"):
            info["evidence"] = "PostgreSQL detected — all credential pairs rejected"
        return info

    async def _pg_auth(
        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
        username: str, password: str,
    ) -> str | None:
        """Attempt PostgreSQL authentication, returns evidence string on success."""
        # Send StartupMessage: length(4) + version(4) + params + \0\0
        params = f"user\x00{username}\x00database\x00postgres\x00\x00".encode()
        startup = struct.pack(">II", 4 + 4 + len(params), 196608) + params
        writer.write(startup)
        await writer.drain()

        # Read authentication response
        msg_type_b = await asyncio.wait_for(reader.readexactly(1), timeout=5)
        msg_type = msg_type_b.decode("ascii", errors="replace")
        msg_len = struct.unpack(">I", await asyncio.wait_for(
            reader.readexactly(4), timeout=5,
        ))[0]
        msg_data = b""
        if msg_len > 4:
            msg_data = await asyncio.wait_for(
                reader.readexactly(msg_len - 4), timeout=5,
            )

        if msg_type != "R":
            return None

        auth_type = struct.unpack(">I", msg_data[:4])[0]

        # AuthenticationOk (trust auth — no password needed!)
        if auth_type == 0:
            return f"PostgreSQL: trust auth for {username} (no password needed)"

        # AuthenticationCleartextPassword
        if auth_type == 3:
            pwd_bytes = password.encode() + b"\x00"
            pwd_msg = b"p" + struct.pack(">I", 4 + len(pwd_bytes)) + pwd_bytes
            writer.write(pwd_msg)
            await writer.drain()
            return await self._pg_read_auth_result(reader, username, password)

        # AuthenticationMD5Password
        if auth_type == 5 and len(msg_data) >= 8:
            salt = msg_data[4:8]
            inner = hashlib.md5((password + username).encode()).hexdigest()
            outer = "md5" + hashlib.md5(inner.encode() + salt).hexdigest()
            pwd_bytes = outer.encode() + b"\x00"
            pwd_msg = b"p" + struct.pack(">I", 4 + len(pwd_bytes)) + pwd_bytes
            writer.write(pwd_msg)
            await writer.drain()
            return await self._pg_read_auth_result(reader, username, password)

        # AuthenticationSASL (SCRAM-SHA-256)
        if auth_type == 10:
            return await self._pg_scram_auth(reader, writer, msg_data[4:], username, password)

        return None

    async def _pg_read_auth_result(
        self, reader: asyncio.StreamReader, username: str, password: str,
    ) -> str | None:
        """Read PostgreSQL auth result after sending password."""
        resp_type = await asyncio.wait_for(reader.readexactly(1), timeout=5)
        resp_len = struct.unpack(">I", await asyncio.wait_for(
            reader.readexactly(4), timeout=5,
        ))[0]
        resp_data = b""
        if resp_len > 4:
            resp_data = await asyncio.wait_for(
                reader.readexactly(resp_len - 4), timeout=5,
            )

        if resp_type == b"R" and resp_data and struct.unpack(">I", resp_data[:4])[0] == 0:
            return f"PostgreSQL: auth success for {username}:{password or '(empty)'}"
        return None

    async def _pg_scram_auth(
        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
        mechanism_data: bytes, username: str, password: str,
    ) -> str | None:
        """SCRAM-SHA-256 authentication for PostgreSQL."""
        # Client first message
        nonce = base64.b64encode(os.urandom(18)).decode()
        client_first_bare = f"n={username},r={nonce}"
        client_first = f"n,,{client_first_bare}"

        # Send SASLInitialResponse
        mechanism = b"SCRAM-SHA-256\x00"
        cf_bytes = client_first.encode()
        payload = mechanism + struct.pack(">I", len(cf_bytes)) + cf_bytes
        msg = b"p" + struct.pack(">I", 4 + len(payload)) + payload
        writer.write(msg)
        await writer.drain()

        # Read SASLContinue (type 'R', auth_type=11)
        resp_type = await asyncio.wait_for(reader.readexactly(1), timeout=5)
        resp_len = struct.unpack(">I", await asyncio.wait_for(
            reader.readexactly(4), timeout=5,
        ))[0]
        resp_data = await asyncio.wait_for(
            reader.readexactly(resp_len - 4), timeout=5,
        )

        if resp_type != b"R" or struct.unpack(">I", resp_data[:4])[0] != 11:
            return None

        server_first = resp_data[4:].decode("utf-8", errors="replace")

        # Parse server-first-message: r=<nonce>,s=<salt>,i=<iterations>
        parts = {}
        for kv in server_first.split(","):
            if "=" in kv:
                k, v = kv.split("=", 1)
                parts[k] = v

        server_nonce = parts.get("r", "")
        if not server_nonce.startswith(nonce):
            return None

        salt = base64.b64decode(parts.get("s", ""))
        iterations = int(parts.get("i", "4096"))

        # Compute SCRAM proofs
        salted_password = hashlib.pbkdf2_hmac(
            "sha256", password.encode("utf-8"), salt, iterations,
        )
        client_key = hmac.new(salted_password, b"Client Key", "sha256").digest()
        stored_key = hashlib.sha256(client_key).digest()

        client_final_no_proof = f"c=biws,r={server_nonce}"
        auth_message = f"{client_first_bare},{server_first},{client_final_no_proof}"

        client_signature = hmac.new(
            stored_key, auth_message.encode(), "sha256",
        ).digest()
        client_proof = bytes(a ^ b for a, b in zip(client_key, client_signature, strict=True))

        client_final = (
            f"{client_final_no_proof},"
            f"p={base64.b64encode(client_proof).decode()}"
        )

        # Send SASLResponse
        cf_final = client_final.encode()
        msg = b"p" + struct.pack(">I", 4 + len(cf_final)) + cf_final
        writer.write(msg)
        await writer.drain()

        # Read SASLFinal (type 'R', auth_type=12)
        resp_type = await asyncio.wait_for(reader.readexactly(1), timeout=5)
        resp_len = struct.unpack(">I", await asyncio.wait_for(
            reader.readexactly(4), timeout=5,
        ))[0]
        resp_data = await asyncio.wait_for(
            reader.readexactly(resp_len - 4), timeout=5,
        )

        if resp_type != b"R" or struct.unpack(">I", resp_data[:4])[0] != 12:
            return None

        # Read AuthenticationOk
        ok_type = await asyncio.wait_for(reader.readexactly(1), timeout=5)
        ok_len = struct.unpack(">I", await asyncio.wait_for(
            reader.readexactly(4), timeout=5,
        ))[0]
        ok_data = await asyncio.wait_for(
            reader.readexactly(ok_len - 4), timeout=5,
        )

        if ok_type == b"R" and ok_data and struct.unpack(">I", ok_data[:4])[0] == 0:
            return f"PostgreSQL: SCRAM auth success for {username}:{password or '(empty)'}"
        return None

    # ------------------------------------------------------------------
    # MongoDB — OP_MSG wire protocol with listDatabases command.
    # ------------------------------------------------------------------

    async def _check_mongodb(self, host: str, port: int, info: dict) -> dict:
        """Check MongoDB no-auth via OP_MSG listDatabases command."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5,
            )
            try:
                # Build OP_MSG with listDatabases command
                # BSON: {listDatabases: 1, $db: "admin"}
                bson_cmd = (
                    b"\x27\x00\x00\x00"  # doc size = 39
                    b"\x10listDatabases\x00\x01\x00\x00\x00"  # int32 field
                    b"\x02$db\x00\x06\x00\x00\x00admin\x00"  # string field
                    b"\x00"  # end of doc
                )
                # OP_MSG header: length(4) + requestId(4) + responseTo(4) + opCode(4)
                # + flagBits(4) + section_kind(1) + bson
                msg_len = 16 + 4 + 1 + len(bson_cmd)
                msg = struct.pack("<iiii", msg_len, 1, 0, 2013)
                msg += struct.pack("<I", 0)  # flagBits
                msg += b"\x00" + bson_cmd  # section kind 0

                writer.write(msg)
                await writer.drain()

                # Read response header
                resp_header = await asyncio.wait_for(reader.readexactly(16), timeout=5)
                resp_len = struct.unpack("<i", resp_header[:4])[0]
                resp_body = await asyncio.wait_for(
                    reader.readexactly(resp_len - 16), timeout=5,
                )
                resp_text = resp_body.decode("utf-8", errors="replace")

                if "unauthorized" in resp_text.lower() or "auth" in resp_text.lower():
                    info["evidence"] = "MongoDB requires authentication"
                else:
                    info["no_auth"] = True
                    info["evidence"] = (
                        f"MongoDB no-auth: listDatabases success "
                        f"({resp_text[:200]})"
                    )
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception as e:
            logger.debug("service_brute mongodb: %s", e)
        return info

    # ------------------------------------------------------------------
    # Remaining service checks (unchanged)
    # ------------------------------------------------------------------

    async def _check_vnc(self, host: str, port: int, info: dict) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                data = await asyncio.wait_for(reader.read(12), timeout=3)
                if data and data.startswith(b"RFB"):
                    version = data.decode("utf-8", errors="replace").strip()
                    info["evidence"] = f"VNC version: {version}"
                    writer.write(data)
                    await writer.drain()
                    sec_data = await asyncio.wait_for(reader.read(256), timeout=3)
                    if sec_data and len(sec_data) > 1:
                        num_types = sec_data[0]
                        if num_types > 0:
                            sec_types = list(sec_data[1:1 + num_types])
                            if 1 in sec_types:
                                info["no_auth"] = True
                                info["evidence"] = f"VNC {version} — no auth required"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception as e:
            logger.debug("service_brute: %s", e)
        return info

    async def _check_memcached(self, host: str, port: int, info: dict) -> dict:
        """Check if Memcached is accessible without auth."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                writer.write(b"stats\r\n")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(1024), timeout=3)
                resp_str = resp.decode("utf-8", errors="replace")
                if "STAT" in resp_str:
                    info["no_auth"] = True
                    # Extract version
                    for line in resp_str.splitlines():
                        if "version" in line.lower():
                            info["evidence"] = f"Memcached: {line.strip()}"
                            break
                    else:
                        info["evidence"] = "Memcached stats accessible"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception as e:
            logger.debug("service_brute: %s", e)
        return info

    async def _check_elasticsearch(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict, ctx=None,
    ) -> dict:
        """Check Elasticsearch via HTTP API."""
        http = ctx.http if ctx and ctx.http else None
        if not http:
            return info

        # Try no-auth first
        try:
            async with ctx.rate:
                resp = await http.get(f"http://{host}:{port}/", timeout=5.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "cluster_name" in body:
                    info["no_auth"] = True
                    info["evidence"] = f"Elasticsearch open: {body[:150]}"
                    return info
        except Exception as e:
            logger.debug("service_brute: %s", e)

        # Try credentials
        for username, password in creds:
            if not username:
                continue
            try:
                auth = base64.b64encode(f"{username}:{password}".encode()).decode()
                async with ctx.rate:
                    resp = await http.get(
                        f"http://{host}:{port}/",
                        headers={"Authorization": f"Basic {auth}"},
                        timeout=5.0,
                    )
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "cluster_name" in body:
                            info.update(success=True, username=username,
                                        password=password,
                                        evidence=f"ES auth: {body[:100]}")
                            return info
            except Exception as e:
                logger.debug("service_brute: %s", e)
                continue
        return info

    async def _check_couchdb(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict, ctx=None,
    ) -> dict:
        """Check CouchDB via HTTP API."""
        http = ctx.http if ctx and ctx.http else None
        if not http:
            return info

        try:
            async with ctx.rate:
                resp = await http.get(f"http://{host}:{port}/", timeout=5.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "couchdb" in body.lower():
                    # Check if admin party mode
                    async with ctx.rate:
                        db_resp = await http.get(
                            f"http://{host}:{port}/_all_dbs", timeout=5.0,
                        )
                        if db_resp.status == 200:
                            info["no_auth"] = True
                            info["evidence"] = f"CouchDB admin party: {body[:100]}"
                            return info
        except Exception as e:
            logger.debug("service_brute: %s", e)

        for username, password in creds:
            try:
                auth = base64.b64encode(f"{username}:{password}".encode()).decode()
                async with ctx.rate:
                    resp = await http.get(
                        f"http://{host}:{port}/_all_dbs",
                        headers={"Authorization": f"Basic {auth}"},
                        timeout=5.0,
                    )
                    if resp.status == 200:
                        info.update(success=True, username=username,
                                    password=password,
                                    evidence=f"CouchDB: {username}:{password}")
                        return info
            except Exception as e:
                logger.debug("service_brute: %s", e)
                continue
        return info

    async def _check_smb(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        """Check SMB/Samba for default credentials using smbprotocol."""
        try:
            from smbprotocol.connection import Connection
            from smbprotocol.session import Session
        except ImportError:
            logger.debug("smbprotocol not installed, skipping SMB check")
            return info

        import uuid as _uuid
        loop = asyncio.get_event_loop()

        async def _try_smb_auth(user: str, passwd: str) -> bool:
            """Attempt SMB auth, return True on success."""
            conn = Connection(
                guid=_uuid.uuid4(), server_name=host, port=port,
                require_signing=False,
            )
            try:
                await loop.run_in_executor(None, conn.connect)
                session = Session(
                    conn, username=user, password=passwd,
                    require_encryption=False,
                    auth_protocol="ntlm",
                )
                await loop.run_in_executor(None, session.connect)
                with contextlib.suppress(Exception):
                    await loop.run_in_executor(None, session.disconnect)
                return True
            except Exception:
                return False
            finally:
                with contextlib.suppress(Exception):
                    await loop.run_in_executor(None, conn.disconnect)

        # Try guest/anonymous first
        try:
            if await asyncio.wait_for(_try_smb_auth("guest", ""), timeout=10.0):
                info.update(no_auth=True, evidence="SMB: guest session accepted")
                return info
        except Exception as e:
            logger.debug("service_brute smb guest: %s", e)

        # Try credential pairs
        for username, password in creds:
            if not username:
                continue
            try:
                if await asyncio.wait_for(
                    _try_smb_auth(username, password), timeout=10.0,
                ):
                    info.update(
                        success=True, username=username, password=password,
                        evidence=f"SMB: login success as {username}:{password}",
                    )
                    return info
            except Exception as e:
                logger.debug("service_brute smb %s: %s", username, e)
                continue
        return info
