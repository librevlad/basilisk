"""Service default credentials check — tests common/default passwords on discovered services.

Supports FTP, Redis, MySQL, PostgreSQL, MongoDB, VNC, Memcached, Elasticsearch,
CouchDB, SNMP. Lockout-aware with configurable concurrency.
"""

from __future__ import annotations

import asyncio
import contextlib
import logging
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Service definitions with default credentials
SERVICE_CREDS: dict[str, dict[str, Any]] = {
    "ftp": {
        "port": 21,
        "creds": [
            ("anonymous", ""), ("anonymous", "anonymous@"),
            ("admin", "admin"), ("admin", "password"), ("admin", "123456"),
            ("ftp", "ftp"), ("user", "user"), ("test", "test"),
            ("admin", "ftp"), ("root", "root"), ("www", "www"),
        ],
    },
    "redis": {
        "port": 6379,
        "creds": [
            ("", ""), ("", "redis"), ("", "password"),
            ("", "123456"), ("", "admin"), ("", "foobared"),
            ("default", ""), ("default", "redis"),
        ],
    },
    "mysql": {
        "port": 3306,
        "creds": [
            ("root", ""), ("root", "root"), ("root", "password"),
            ("root", "mysql"), ("root", "123456"), ("admin", "admin"),
            ("mysql", "mysql"), ("dbadmin", "dbadmin"),
            ("root", "toor"), ("root", "changeme"),
        ],
    },
    "postgresql": {
        "port": 5432,
        "creds": [
            ("postgres", "postgres"), ("postgres", "password"),
            ("postgres", "123456"), ("admin", "admin"),
            ("postgres", ""), ("dbuser", "dbuser"),
            ("postgres", "changeme"), ("postgres", "admin"),
        ],
    },
    "mongodb": {
        "port": 27017,
        "creds": [("", "")],
    },
    "vnc": {
        "port": 5900,
        "creds": [
            ("", ""), ("", "password"), ("", "vnc"), ("", "123456"),
            ("", "admin"), ("", "1234"),
        ],
    },
    "memcached": {
        "port": 11211,
        "creds": [("", "")],
    },
    "elasticsearch": {
        "port": 9200,
        "creds": [
            ("", ""), ("elastic", "changeme"), ("elastic", "elastic"),
            ("admin", "admin"),
        ],
    },
    "couchdb": {
        "port": 5984,
        "creds": [
            ("admin", "admin"), ("admin", "password"),
            ("root", "root"), ("couchdb", "couchdb"),
        ],
    },
}


class ServiceBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="service_brute",
        display_name="Service Default Credentials",
        category=PluginCategory.PENTESTING,
        description=(
            f"Tests default/weak credentials on {len(SERVICE_CREDS)} services: "
            "FTP, Redis, MySQL, PostgreSQL, MongoDB, VNC, Memcached, "
            "Elasticsearch, CouchDB"
        ),
        depends_on=["port_scan", "service_detect"],
        default_enabled=True,
        produces=["service_brute_findings"],
        timeout=120.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        results: list[dict] = []

        # Get open ports from pipeline
        port_key = f"port_scan:{target.host}"
        port_result = ctx.pipeline.get(port_key)
        open_ports: set[int] = set()
        if port_result and port_result.ok:
            open_ports = {p["port"] for p in port_result.data.get("open_ports", [])}

        if not open_ports:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info(
                    "No open ports — skipping credential check",
                    tags=["pentesting", "brute"],
                )],
                data={"brute_results": []},
            )

        for service_name, service_info in SERVICE_CREDS.items():
            if ctx.should_stop:
                break
            port = service_info["port"]
            if port not in open_ports:
                continue

            creds = service_info["creds"]
            result = await self._check_service(
                target.host, port, service_name, creds, ctx,
            )
            results.append(result)

            if result.get("success"):
                user = result.get("username", "")
                passwd = result.get("password", "")
                cred_str = f"{user}:{passwd}" if user else "(no auth)"

                findings.append(Finding.critical(
                    f"Default credentials on {service_name} "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} accepts "
                        f"credentials: {cred_str}"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=(
                        f"Change default credentials for {service_name}. "
                        "Use strong, unique passwords."
                    ),
                    tags=["pentesting", "brute", service_name],
                ))
            elif result.get("no_auth"):
                findings.append(Finding.critical(
                    f"{service_name} requires no authentication "
                    f"({target.host}:{port})",
                    description=(
                        f"Service {service_name} is accessible "
                        "without authentication"
                    ),
                    evidence=result.get("evidence", ""),
                    remediation=f"Enable authentication for {service_name}.",
                    tags=["pentesting", "brute", service_name],
                ))

        if not findings:
            findings.append(Finding.info(
                "No default credentials found on open services",
                tags=["pentesting", "brute"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"brute_results": results},
        )

    async def _check_service(
        self, host: str, port: int, service: str,
        creds: list[tuple[str, str]], ctx=None,
    ) -> dict[str, Any]:
        info: dict[str, Any] = {
            "service": service, "port": port,
            "success": False, "no_auth": False,
        }

        try:
            if service == "ftp":
                return await self._check_ftp(host, port, creds, info)
            elif service == "redis":
                return await self._check_redis(host, port, creds, info)
            elif service == "mysql":
                return await self._check_mysql(host, port, info)
            elif service == "postgresql":
                return await self._check_postgresql(host, port, info)
            elif service == "mongodb":
                return await self._check_mongodb(host, port, info)
            elif service == "vnc":
                return await self._check_vnc(host, port, info)
            elif service == "memcached":
                return await self._check_memcached(host, port, info)
            elif service == "elasticsearch":
                return await self._check_elasticsearch(host, port, creds, info, ctx)
            elif service == "couchdb":
                return await self._check_couchdb(host, port, creds, info, ctx)
        except Exception:
            logger.debug("Error checking %s on %s:%d", service, host, port)

        return info

    async def _check_ftp(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        for username, password in creds:
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port), timeout=3,
                )
                try:
                    await asyncio.wait_for(reader.readline(), timeout=3)
                    writer.write(f"USER {username}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.readline(), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()

                    if resp_str.startswith("230"):
                        info.update(success=True, username=username,
                                    password="", evidence=f"FTP: {resp_str}")
                        return info

                    if resp_str.startswith("331"):
                        writer.write(f"PASS {password}\r\n".encode())
                        await writer.drain()
                        resp = await asyncio.wait_for(reader.readline(), timeout=3)
                        resp_str = resp.decode("utf-8", errors="replace").strip()
                        if resp_str.startswith("230"):
                            info.update(success=True, username=username,
                                        password=password, evidence=f"FTP: {resp_str}")
                            return info
                finally:
                    writer.close()
                    with contextlib.suppress(Exception):
                        await writer.wait_closed()
            except Exception:
                continue
        return info

    async def _check_redis(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict,
    ) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                writer.write(b"PING\r\n")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(256), timeout=3)
                resp_str = resp.decode("utf-8", errors="replace").strip()

                if "+PONG" in resp_str:
                    # Also try INFO to confirm full access
                    writer.write(b"INFO server\r\n")
                    await writer.drain()
                    info_resp = await asyncio.wait_for(reader.read(1024), timeout=3)
                    info_str = info_resp.decode("utf-8", errors="replace")

                    info["no_auth"] = True
                    info["evidence"] = f"Redis PING: {resp_str}"
                    if "redis_version" in info_str:
                        info["evidence"] += f" | {info_str[:100]}"
                    return info

                for _, password in creds:
                    if not password:
                        continue
                    writer.write(f"AUTH {password}\r\n".encode())
                    await writer.drain()
                    resp = await asyncio.wait_for(reader.read(256), timeout=3)
                    resp_str = resp.decode("utf-8", errors="replace").strip()
                    if "+OK" in resp_str:
                        info.update(success=True, username="", password=password,
                                    evidence=f"Redis AUTH: {resp_str}")
                        return info
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_mysql(self, host: str, port: int, info: dict) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                data = await asyncio.wait_for(reader.read(1024), timeout=3)
                if data and len(data) > 4:
                    greeting = data.decode("utf-8", errors="replace")
                    if "mysql" in greeting.lower() or data[4] == 10:
                        info["evidence"] = f"MySQL greeting: {greeting[:100]}"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_postgresql(self, host: str, port: int, info: dict) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                writer.write(b"\x00\x00\x00\x08\x04\xd2\x16\x2f")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(1), timeout=3)
                if resp in (b"N", b"S"):
                    info["evidence"] = (
                        f"PostgreSQL SSLRequest: "
                        f"{'SSL supported' if resp == b'S' else 'no SSL'}"
                    )
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_mongodb(self, host: str, port: int, info: dict) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                try:
                    data = await asyncio.wait_for(reader.read(512), timeout=2)
                    banner = data.decode("utf-8", errors="replace")
                    if data:
                        info["no_auth"] = True
                        info["evidence"] = f"MongoDB accepted: {banner[:100]}"
                except TimeoutError:
                    info["no_auth"] = True
                    info["evidence"] = "MongoDB TCP accepted (no banner)"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_vnc(self, host: str, port: int, info: dict) -> dict:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                data = await asyncio.wait_for(reader.read(12), timeout=3)
                if data and data.startswith(b"RFB"):
                    version = data.decode("utf-8", errors="replace").strip()
                    info["evidence"] = f"VNC version: {version}"
                    writer.write(data)
                    await writer.drain()
                    sec_data = await asyncio.wait_for(reader.read(256), timeout=3)
                    if sec_data and len(sec_data) > 1:
                        num_types = sec_data[0]
                        if num_types > 0:
                            sec_types = list(sec_data[1:1 + num_types])
                            if 1 in sec_types:
                                info["no_auth"] = True
                                info["evidence"] = f"VNC {version} — no auth required"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_memcached(self, host: str, port: int, info: dict) -> dict:
        """Check if Memcached is accessible without auth."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=3,
            )
            try:
                writer.write(b"stats\r\n")
                await writer.drain()
                resp = await asyncio.wait_for(reader.read(1024), timeout=3)
                resp_str = resp.decode("utf-8", errors="replace")
                if "STAT" in resp_str:
                    info["no_auth"] = True
                    # Extract version
                    for line in resp_str.splitlines():
                        if "version" in line.lower():
                            info["evidence"] = f"Memcached: {line.strip()}"
                            break
                    else:
                        info["evidence"] = "Memcached stats accessible"
            finally:
                writer.close()
                with contextlib.suppress(Exception):
                    await writer.wait_closed()
        except Exception:
            pass
        return info

    async def _check_elasticsearch(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict, ctx=None,
    ) -> dict:
        """Check Elasticsearch via HTTP API."""
        http = ctx.http if ctx and ctx.http else None
        if not http:
            return info

        # Try no-auth first
        try:
            async with ctx.rate:
                resp = await http.get(f"http://{host}:{port}/", timeout=5.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "cluster_name" in body:
                    info["no_auth"] = True
                    info["evidence"] = f"Elasticsearch open: {body[:150]}"
                    return info
        except Exception:
            pass

        # Try credentials
        import base64
        for username, password in creds:
            if not username:
                continue
            try:
                auth = base64.b64encode(f"{username}:{password}".encode()).decode()
                async with ctx.rate:
                    resp = await http.get(
                        f"http://{host}:{port}/",
                        headers={"Authorization": f"Basic {auth}"},
                        timeout=5.0,
                    )
                    if resp.status == 200:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "cluster_name" in body:
                            info.update(success=True, username=username,
                                        password=password,
                                        evidence=f"ES auth: {body[:100]}")
                            return info
            except Exception:
                continue
        return info

    async def _check_couchdb(
        self, host: str, port: int,
        creds: list[tuple[str, str]], info: dict, ctx=None,
    ) -> dict:
        """Check CouchDB via HTTP API."""
        http = ctx.http if ctx and ctx.http else None
        if not http:
            return info

        try:
            async with ctx.rate:
                resp = await http.get(f"http://{host}:{port}/", timeout=5.0)
                body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and "couchdb" in body.lower():
                    # Check if admin party mode
                    async with ctx.rate:
                        db_resp = await http.get(
                            f"http://{host}:{port}/_all_dbs", timeout=5.0,
                        )
                        if db_resp.status == 200:
                            info["no_auth"] = True
                            info["evidence"] = f"CouchDB admin party: {body[:100]}"
                            return info
        except Exception:
            pass

        import base64
        for username, password in creds:
            try:
                auth = base64.b64encode(f"{username}:{password}".encode()).decode()
                async with ctx.rate:
                    resp = await http.get(
                        f"http://{host}:{port}/_all_dbs",
                        headers={"Authorization": f"Basic {auth}"},
                        timeout=5.0,
                    )
                    if resp.status == 200:
                        info.update(success=True, username=username,
                                    password=password,
                                    evidence=f"CouchDB: {username}:{password}")
                        return info
            except Exception:
                continue
        return info
