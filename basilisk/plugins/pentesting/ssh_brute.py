"""SSH brute force â€” tests default credentials on open SSH ports."""

from __future__ import annotations

import asyncio
import contextlib
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

try:
    import asyncssh
    _HAS_ASYNCSSH = True
except ImportError:
    _HAS_ASYNCSSH = False

SSH_CREDENTIALS = [
    ("admin", "admin"), ("root", "root"), ("root", "toor"),
    ("root", "password"), ("root", "123456"), ("root", "admin"),
    ("admin", "password"), ("admin", "123456"), ("user", "user"),
    ("test", "test"), ("ubuntu", "ubuntu"), ("pi", "raspberry"),
    ("oracle", "oracle"), ("postgres", "postgres"), ("git", "git"),
]


class SshBrutePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ssh_brute",
        display_name="SSH Brute Force",
        category=PluginCategory.PENTESTING,
        description="Tests default SSH credentials on hosts with open port 22",
        depends_on=["port_scan"],
        produces=["ssh_brute_findings"],
        timeout=90.0,
        requires_http=False,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        # Find SSH ports from port_scan or service_detect pipeline data
        ssh_port = self._find_ssh_port(target.host, ctx)

        if not ssh_port:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No SSH port detected, skipping SSH brute force")],
                data={"ssh_brute": {}},
            )

        findings: list[Finding] = []
        ssh_data: dict = {
            "port": ssh_port,
            "banner": "", "tested": 0, "found": [], "blocked": False,
        }

        # Step 1: Banner grab
        banner = await self._grab_banner(target.host, ssh_port)
        ssh_data["banner"] = banner
        if banner:
            findings.append(Finding.info(
                f"SSH banner on port {ssh_port}: {banner}",
                tags=["pentesting", "ssh"],
            ))

        # Step 2: Attempt credentials
        for username, password in SSH_CREDENTIALS:
            if ctx.should_stop:
                break
            ssh_data["tested"] += 1

            # Rate limit: 0.5s between attempts
            await asyncio.sleep(0.5)

            try:
                result = await asyncio.wait_for(
                    self._try_ssh_auth(target.host, ssh_port, username, password),
                    timeout=10.0,
                )
            except TimeoutError:
                continue
            except Exception as e:
                logger.debug("ssh_brute: %s", e)
                continue

            if result == "success":
                ssh_data["found"].append({
                    "username": username, "password": password,
                })
                findings.append(Finding.critical(
                    f"SSH credentials found: {username}:{password}",
                    description=f"SSH login successful on {target.host}:{ssh_port}",
                    evidence=(
                        f"Host: {target.host}:{ssh_port}\n"
                        f"Banner: {banner}\n"
                        f"Credentials: {username}:{password}"
                    ),
                    remediation=(
                        "Change default SSH credentials immediately. "
                        "Disable password auth, use key-based auth. "
                        "Implement fail2ban."
                    ),
                    tags=["pentesting", "ssh", "credentials"],
                ))
                break
            elif result == "blocked":
                ssh_data["blocked"] = True
                findings.append(Finding.info(
                    "SSH brute force blocked (too many auth failures)",
                    tags=["pentesting", "ssh"],
                ))
                break

        if not ssh_data["found"] and not ssh_data["blocked"]:
            findings.append(Finding.info(
                f"SSH brute force: no default credentials ({ssh_data['tested']} tested)",
                tags=["pentesting", "ssh"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"ssh_brute": ssh_data},
        )

    @staticmethod
    def _find_ssh_port(host: str, ctx) -> int | None:
        """Find SSH port from pipeline results."""
        # Check port_scan results for SSH service
        port_key = f"port_scan:{host}"
        port_result = ctx.pipeline.get(port_key)
        if port_result and port_result.ok:
            for p in port_result.data.get("open_ports", []):
                service = p.get("service", "").lower()
                banner = p.get("banner", "").lower()
                port = p.get("port", 0)
                if port == 22 or "ssh" in service or "ssh" in banner:
                    return port

        # Check service_detect results
        svc_key = f"service_detect:{host}"
        svc_result = ctx.pipeline.get(svc_key)
        if svc_result and svc_result.ok:
            for s in svc_result.data.get("services", []):
                service = s.get("service", "").lower()
                banner = s.get("banner", "").lower()
                if "ssh" in service or "ssh" in banner:
                    return s.get("port", 22)

        # Fallback: check state
        open_ports = ctx.state.get("open_ports", [])
        if isinstance(open_ports, list):
            for port_info in open_ports:
                port_num = port_info.get("port", 0) if isinstance(port_info, dict) else 0
                if port_num == 22:
                    return 22
        return None

    async def _grab_banner(self, host: str, port: int = 22) -> str:
        """Grab SSH version banner."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5.0,
            )
            banner_bytes = await asyncio.wait_for(
                reader.readline(), timeout=3.0,
            )
            writer.close()
            await writer.wait_closed()
            return banner_bytes.decode("utf-8", errors="replace").strip()
        except Exception as e:
            logger.debug("ssh_brute banner: %s", e)
            return ""

    async def _try_ssh_auth(
        self, host: str, port: int, username: str, password: str,
    ) -> str:
        """Attempt SSH password auth.

        Uses asyncssh if available, otherwise falls back to raw TCP banner check.
        Returns: 'success', 'failed', 'blocked', or 'error'
        """
        if _HAS_ASYNCSSH:
            return await self._try_asyncssh_auth(host, port, username, password)
        return await self._try_raw_auth(host, port, username, password)

    @staticmethod
    async def _try_asyncssh_auth(
        host: str, port: int, username: str, password: str,
    ) -> str:
        """Attempt SSH auth using asyncssh library."""
        try:
            async with asyncssh.connect(
                host, port=port,
                username=username, password=password,
                known_hosts=None,
                preferred_auth="password",
            ) as conn:
                # If we got here, auth succeeded
                result = await conn.run("id", check=False, timeout=3)
                logger.debug(
                    "ssh_brute: auth success %s@%s:%d (id=%s)",
                    username, host, port,
                    result.stdout.strip() if result.stdout else "n/a",
                )
                return "success"
        except asyncssh.PermissionDenied:
            return "failed"
        except asyncssh.ConnectionLost:
            return "blocked"
        except asyncssh.DisconnectError as e:
            if "Too many" in str(e):
                return "blocked"
            logger.debug("ssh_brute asyncssh: %s", e)
            return "error"
        except Exception as e:
            logger.debug("ssh_brute asyncssh: %s", e)
            return "error"

    @staticmethod
    async def _try_raw_auth(
        host: str, port: int, username: str, password: str,
    ) -> str:
        """Fallback: raw TCP banner check (cannot do real auth)."""
        try:
            reader, writer = await asyncio.open_connection(host, port)
        except Exception:
            return "error"

        try:
            server_banner = await asyncio.wait_for(reader.readline(), timeout=5.0)
            banner_str = server_banner.decode("utf-8", errors="replace").strip()

            if "Too many" in banner_str:
                return "blocked"

            writer.write(b"SSH-2.0-Basilisk_Security_Scanner\r\n")
            await writer.drain()
            return "failed"
        except Exception:
            return "error"
        finally:
            writer.close()
            with contextlib.suppress(Exception):
                await writer.wait_closed()
