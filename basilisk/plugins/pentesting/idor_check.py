"""Insecure Direct Object Reference (IDOR) detection."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

IDOR_PATHS = [
    # User / profile / account
    "/api/users/{id}",
    "/api/v1/users/{id}",
    "/api/v2/users/{id}",
    "/api/user/{id}",
    "/user/{id}",
    "/users/{id}",
    "/users/v1/{id}",
    "/profile/{id}",
    "/account/{id}",
    "/api/v1/accounts/{id}",
    # Orders / invoices / transactions / payments
    "/api/orders/{id}",
    "/api/v1/orders/{id}",
    "/api/v1/invoices/{id}",
    "/api/v1/transactions/{id}",
    "/api/v1/payments/{id}",
    # Documents / files / reports
    "/api/documents/{id}",
    "/api/v1/documents/{id}",
    "/api/files/{id}",
    "/api/v1/files/{id}",
    "/api/invoices/{id}",
    "/api/reports/{id}",
    "/api/v1/reports/{id}",
    # Books / items / products
    "/books/v1/{id}",
    "/api/v1/items/{id}",
    "/api/v1/products/{id}",
    # Messaging / social
    "/api/v1/messages/{id}",
    "/api/v1/comments/{id}",
    "/api/v1/posts/{id}",
    # Support / tickets
    "/api/v1/tickets/{id}",
    # Settings / notifications
    "/api/v1/settings/{id}",
    "/api/v1/notifications/{id}",
    # GraphQL with id variable (treated as path probe)
    "/graphql",
]

QS_IDOR_PATHS = [
    ("/api/user", "id"),
    ("/api/profile", "user_id"),
    ("/api/account", "uid"),
    ("/api/order", "order_id"),
    ("/user", "id"),
    ("/profile", "id"),
    # Extended query-string IDOR paths
    ("/profile", "user_id"),
    ("/order", "order_id"),
    ("/invoice", "id"),
    ("/document", "doc_id"),
    ("/message", "msg_id"),
    ("/download", "file_id"),
    ("/export", "report_id"),
    ("/settings", "account_id"),
    ("/transaction", "txn_id"),
    ("/receipt", "receipt_id"),
    ("/ticket", "ticket_id"),
    ("/comment", "comment_id"),
]

TEST_IDS = [
    "1",
    "2",
    "100",
    "999",
    "1000",
    "0",
    "-1",
    "99999",
    "admin",
    "root",
    "test",
    "00000000-0000-0000-0000-000000000000",
    "1' OR '1'='1",
    "{{1+1}}",
    "../../../etc/passwd",
]


class IdorCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="idor_check",
        display_name="IDOR Check",
        category=PluginCategory.PENTESTING,
        description="Detects Insecure Direct Object Reference vulnerabilities",
        produces=["idor_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        tested: list[dict] = []
        base_url = ""

        # Use pre-probed scheme from autonomous mode when available
        _pre = ctx.state.get("http_scheme", {}).get(target.host)
        if _pre:
            base_url = f"{_pre}://{target.host}"

        if not base_url:
            for scheme in ("https", "http"):
                try:
                    async with ctx.rate:
                        await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                        base_url = f"{scheme}://{target.host}"
                        break
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"idor_tests": []},
            )

        # Test path-based IDOR
        for path_template in IDOR_PATHS:
            if ctx.should_stop:
                break
            responses: dict[str, tuple[int, int, str]] = {}

            for test_id in TEST_IDS:
                path = path_template.replace("{id}", str(test_id))
                url = f"{base_url}{path}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        responses[test_id] = (resp.status, len(body), body[:500])
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

            # Analyze: if multiple IDs return 200 with different content
            success_ids = [
                tid for tid, (status, _, _) in responses.items()
                if status == 200
            ]

            if len(success_ids) >= 2:
                # Check that responses are actually different (not generic page)
                bodies = [responses[tid][2] for tid in success_ids[:2]]
                if bodies[0] != bodies[1]:
                    sizes = [responses[tid][1] for tid in success_ids]
                    tested.append({
                        "path": path_template, "method": "path_id",
                        "accessible_ids": success_ids,
                    })
                    findings.append(Finding.high(
                        f"Potential IDOR: {path_template}",
                        description=(
                            "Multiple object IDs return 200 with different "
                            "content, suggesting missing authorization checks."
                        ),
                        evidence=(
                            f"Path: {path_template}\n"
                            f"IDs returning 200: {success_ids}\n"
                            f"Response sizes: {sizes}"
                        ),
                        remediation=(
                            "Implement proper authorization checks for all "
                            "object access. Verify the requesting user has "
                            "permission to access the requested resource. "
                            "Use UUIDs instead of sequential IDs."
                        ),
                        tags=["pentesting", "idor", "authorization"],
                    ))

        # Test query string-based IDOR
        for path, param in QS_IDOR_PATHS:
            responses = {}

            for test_id in TEST_IDS:
                url = f"{base_url}{path}?{param}={test_id}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        responses[test_id] = (resp.status, len(body), body[:500])
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

            success_ids = [
                tid for tid, (status, _, _) in responses.items()
                if status == 200
            ]

            if len(success_ids) >= 2:
                bodies = [responses[tid][2] for tid in success_ids[:2]]
                if bodies[0] != bodies[1]:
                    tested.append({
                        "path": path, "param": param, "method": "query_string",
                        "accessible_ids": success_ids,
                    })
                    findings.append(Finding.high(
                        f"Potential IDOR: {path}?{param}=",
                        description=(
                            f"Multiple object IDs accessible via query parameter "
                            f"'{param}' without apparent authorization."
                        ),
                        evidence=(
                            f"Path: {path}?{param}=\n"
                            f"IDs returning 200: {success_ids}\n"
                            f"Sizes: {[responses[tid][1] for tid in success_ids]}"
                        ),
                        remediation=(
                            "Implement server-side authorization checks. "
                            "Do not rely on obscurity of object IDs."
                        ),
                        tags=["pentesting", "idor", "authorization"],
                    ))

        # Check for numeric ID patterns in crawled URLs and response bodies
        await self._check_crawled_urls(ctx, base_url, target, findings, tested)
        await self._check_injection_points(ctx, base_url, target, findings, tested)
        await self._check_page_urls(ctx, base_url, findings, tested)

        if not findings:
            findings.append(Finding.info(
                "No IDOR vulnerabilities detected",
                tags=["pentesting", "idor"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"idor_tests": tested},
        )

    async def _check_crawled_urls(
        self, ctx, base_url: str, target: Target,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Scan crawled URLs for numeric IDs and test adjacent values."""
        state = ctx.state if hasattr(ctx, "state") else {}
        crawled_urls = state.get("crawled_urls", {}).get(target.host, [])
        if not crawled_urls:
            return

        from urllib.parse import parse_qs, urlparse, urlencode

        candidates: list[tuple[str, str, str]] = []  # (url_path, method, source)
        seen: set[str] = set()

        for url in crawled_urls:
            if ctx.should_stop or len(candidates) >= 20:
                break
            parsed = urlparse(url)
            path = parsed.path or "/"

            # Path-based IDs: /users/1, /api/v1/orders/42, /profile/100
            path_id_match = re.search(r"(/\d+)(?:/|$|\?)", path)
            if path_id_match and path not in seen:
                seen.add(path)
                candidates.append((path, "path_id", url))
                continue

            # Query-param IDs: ?id=1, ?user_id=42, ?uid=100
            if parsed.query:
                qs = parse_qs(parsed.query, keep_blank_values=True)
                for param_name, values in qs.items():
                    val = values[0] if values else ""
                    if val.isdigit() and len(val) <= 6:
                        key = f"{path}?{param_name}"
                        if key not in seen:
                            seen.add(key)
                            candidates.append((url, "qs_id", param_name))
                            break

        for candidate_url, method, extra in candidates:
            if ctx.should_stop or len(findings) >= 5:
                break

            if method == "path_id":
                path = urlparse(candidate_url).path or "/"
                match = re.search(r"/(\d+)(?:/|$)", path)
                if not match:
                    continue
                original_id = int(match.group(1))
                alt_ids = [original_id + 1, original_id - 1] if original_id > 0 else [1, 2]
                original_url = f"{base_url}{path}"

                try:
                    async with ctx.rate:
                        resp1 = await ctx.http.get(original_url, timeout=8.0)
                        b1 = await resp1.text(encoding="utf-8", errors="replace")
                    if resp1.status != 200:
                        continue

                    for alt_id in alt_ids:
                        alt_path = path[:match.start(1)] + str(alt_id) + path[match.end(1):]
                        alt_url = f"{base_url}{alt_path}"
                        async with ctx.rate:
                            resp2 = await ctx.http.get(alt_url, timeout=8.0)
                            b2 = await resp2.text(encoding="utf-8", errors="replace")
                        if resp2.status == 200 and b1 != b2:
                            tested.append({
                                "path": path, "method": "crawled_path_id",
                                "original_id": original_id, "alt_id": alt_id,
                            })
                            findings.append(Finding.high(
                                f"IDOR: {path}",
                                description=(
                                    "Crawled URL contains sequential numeric ID. "
                                    "Different IDs return different content without "
                                    "authorization checks."
                                ),
                                evidence=(
                                    f"URL 1: {original_url} (200, {len(b1)} bytes)\n"
                                    f"URL 2: {alt_url} (200, {len(b2)} bytes)"
                                ),
                                remediation=(
                                    "Implement proper authorization checks. "
                                    "Use UUIDs instead of sequential IDs."
                                ),
                                tags=["pentesting", "idor", "authorization"],
                            ))
                            break
                except Exception as e:
                    logger.debug("idor_check crawled path: %s", e)

            elif method == "qs_id":
                parsed = urlparse(candidate_url)
                path = parsed.path or "/"
                param_name = extra
                qs = parse_qs(parsed.query, keep_blank_values=True)
                original_val = qs.get(param_name, ["1"])[0]
                if not original_val.isdigit():
                    continue
                original_id = int(original_val)
                alt_ids = [original_id + 1, original_id - 1] if original_id > 0 else [1, 2]

                try:
                    original_url = f"{base_url}{path}?{urlencode({param_name: original_val})}"
                    async with ctx.rate:
                        resp1 = await ctx.http.get(original_url, timeout=8.0)
                        b1 = await resp1.text(encoding="utf-8", errors="replace")
                    if resp1.status != 200:
                        continue

                    for alt_id in alt_ids:
                        alt_url = f"{base_url}{path}?{urlencode({param_name: str(alt_id)})}"
                        async with ctx.rate:
                            resp2 = await ctx.http.get(alt_url, timeout=8.0)
                            b2 = await resp2.text(encoding="utf-8", errors="replace")
                        if resp2.status == 200 and b1 != b2:
                            tested.append({
                                "path": path, "param": param_name,
                                "method": "crawled_qs_id",
                                "original_id": original_id, "alt_id": alt_id,
                            })
                            findings.append(Finding.high(
                                f"IDOR: {path}?{param_name}=",
                                description=(
                                    f"Crawled URL with numeric parameter "
                                    f"'{param_name}'. Different values return "
                                    f"different content without authorization."
                                ),
                                evidence=(
                                    f"URL 1: {original_url} (200, {len(b1)} bytes)\n"
                                    f"URL 2: {alt_url} (200, {len(b2)} bytes)"
                                ),
                                remediation=(
                                    "Implement authorization checks for "
                                    "object access."
                                ),
                                tags=["pentesting", "idor", "authorization"],
                            ))
                            break
                except Exception as e:
                    logger.debug("idor_check crawled qs: %s", e)

    async def _check_injection_points(
        self, ctx, base_url: str, target: Target,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Test injection points with numeric params for IDOR."""
        if len(findings) >= 5 or ctx.should_stop:
            return

        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(target, ctx)
        seen: set[str] = set()

        for point in inj_points:
            if ctx.should_stop or len(findings) >= 5:
                break
            for param, val in point.params.items():
                if ctx.should_stop or len(findings) >= 5:
                    break
                # Only test numeric-valued params
                if not val or not val.strip().isdigit():
                    continue
                key = f"{point.path}:{param}"
                if key in seen:
                    continue
                seen.add(key)

                original_id = int(val.strip())
                alt_id = original_id + 1 if original_id > 0 else 2

                try:
                    if point.method == "GET":
                        url1 = point.build_url(base_url, param, str(original_id))
                        url2 = point.build_url(base_url, param, str(alt_id))
                        async with ctx.rate:
                            r1 = await ctx.http.get(url1, timeout=8.0)
                            b1 = await r1.text(encoding="utf-8", errors="replace")
                        async with ctx.rate:
                            r2 = await ctx.http.get(url2, timeout=8.0)
                            b2 = await r2.text(encoding="utf-8", errors="replace")
                    else:
                        url = f"{base_url}{point.path}"
                        d1 = point.build_post_data(param, str(original_id))
                        d2 = point.build_post_data(param, str(alt_id))
                        async with ctx.rate:
                            r1 = await ctx.http.post(url, data=d1, timeout=8.0)
                            b1 = await r1.text(encoding="utf-8", errors="replace")
                        async with ctx.rate:
                            r2 = await ctx.http.post(url, data=d2, timeout=8.0)
                            b2 = await r2.text(encoding="utf-8", errors="replace")

                    if r1.status == 200 and r2.status == 200 and b1 != b2:
                        tested.append({
                            "path": point.path, "param": param,
                            "method": "injection_point",
                        })
                        findings.append(Finding.high(
                            f"IDOR: {point.path} ({param})",
                            description=(
                                f"Parameter '{param}' with numeric value accepts "
                                f"different IDs returning different content."
                            ),
                            evidence=(
                                f"ID {original_id}: {r1.status} ({len(b1)} bytes)\n"
                                f"ID {alt_id}: {r2.status} ({len(b2)} bytes)"
                            ),
                            remediation=(
                                "Implement proper authorization checks for "
                                "object access."
                            ),
                            tags=["pentesting", "idor", "authorization"],
                        ))
                        break  # One IDOR per path is enough
                except Exception as e:
                    logger.debug("idor_check injection_point: %s", e)

    async def _check_page_urls(
        self, ctx, base_url: str,
        findings: list[Finding], tested: list[dict],
    ) -> None:
        """Scan homepage HTML for links with numeric IDs."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/", timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")

            url_pattern = re.compile(
                r'(?:href|action|src)=["\']'
                r"(/[^\s\"']*?/\d+[^\s\"']*)"
                r'["\']'
            )
            found_urls = url_pattern.findall(body)
            for found_url in found_urls[:3]:
                if ctx.should_stop or len(findings) >= 5:
                    break
                id_match = re.search(r"/(\d+)", found_url)
                if not id_match:
                    continue
                original_id = int(id_match.group(1))
                new_url = found_url.replace(
                    f"/{original_id}", f"/{original_id + 1}", 1,
                )
                try:
                    async with ctx.rate:
                        resp1 = await ctx.http.get(
                            f"{base_url}{found_url}", timeout=8.0,
                        )
                        resp2 = await ctx.http.get(
                            f"{base_url}{new_url}", timeout=8.0,
                        )
                        if resp1.status == 200 and resp2.status == 200:
                            b1 = await resp1.text(
                                encoding="utf-8", errors="replace",
                            )
                            b2 = await resp2.text(
                                encoding="utf-8", errors="replace",
                            )
                            if b1 != b2:
                                tested.append({
                                    "path": found_url,
                                    "method": "discovered_url",
                                })
                                findings.append(Finding.high(
                                    f"IDOR: {found_url}",
                                    description=(
                                        "URL with sequential numeric ID "
                                        "discovered. Adjacent IDs return "
                                        "different content."
                                    ),
                                    evidence=(
                                        f"URL 1: {found_url} (200)\n"
                                        f"URL 2: {new_url} (200)\n"
                                        f"Sizes: {len(b1)} vs {len(b2)}"
                                    ),
                                    remediation=(
                                        "Use UUIDs instead of sequential "
                                        "IDs. Implement proper access "
                                        "controls."
                                    ),
                                    tags=["pentesting", "idor"],
                                ))
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue
        except Exception as e:
            logger.debug("idor_check: %s", e)
