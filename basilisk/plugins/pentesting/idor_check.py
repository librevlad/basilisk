"""Insecure Direct Object Reference (IDOR) detection."""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

IDOR_PATHS = [
    # User / profile / account
    "/api/users/{id}",
    "/api/v1/users/{id}",
    "/api/v2/users/{id}",
    "/api/user/{id}",
    "/user/{id}",
    "/profile/{id}",
    "/account/{id}",
    "/api/v1/accounts/{id}",
    # Orders / invoices / transactions / payments
    "/api/orders/{id}",
    "/api/v1/orders/{id}",
    "/api/v1/invoices/{id}",
    "/api/v1/transactions/{id}",
    "/api/v1/payments/{id}",
    # Documents / files / reports
    "/api/documents/{id}",
    "/api/v1/documents/{id}",
    "/api/files/{id}",
    "/api/v1/files/{id}",
    "/api/invoices/{id}",
    "/api/reports/{id}",
    "/api/v1/reports/{id}",
    # Messaging / social
    "/api/v1/messages/{id}",
    "/api/v1/comments/{id}",
    "/api/v1/posts/{id}",
    # Support / tickets
    "/api/v1/tickets/{id}",
    # Settings / notifications
    "/api/v1/settings/{id}",
    "/api/v1/notifications/{id}",
    # GraphQL with id variable (treated as path probe)
    "/graphql",
]

QS_IDOR_PATHS = [
    ("/api/user", "id"),
    ("/api/profile", "user_id"),
    ("/api/account", "uid"),
    ("/api/order", "order_id"),
    ("/user", "id"),
    ("/profile", "id"),
    # Extended query-string IDOR paths
    ("/profile", "user_id"),
    ("/order", "order_id"),
    ("/invoice", "id"),
    ("/document", "doc_id"),
    ("/message", "msg_id"),
    ("/download", "file_id"),
    ("/export", "report_id"),
    ("/settings", "account_id"),
    ("/transaction", "txn_id"),
    ("/receipt", "receipt_id"),
    ("/ticket", "ticket_id"),
    ("/comment", "comment_id"),
]

TEST_IDS = [
    "1",
    "2",
    "100",
    "999",
    "1000",
    "0",
    "-1",
    "99999",
    "admin",
    "root",
    "test",
    "00000000-0000-0000-0000-000000000000",
    "1' OR '1'='1",
    "{{1+1}}",
    "../../../etc/passwd",
]


class IdorCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="idor_check",
        display_name="IDOR Check",
        category=PluginCategory.PENTESTING,
        description="Detects Insecure Direct Object Reference vulnerabilities",
        produces=["idor_findings"],
        timeout=30.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available"
            )

        findings: list[Finding] = []
        tested: list[dict] = []
        base_url = ""

        # Use pre-probed scheme from autonomous mode when available
        _pre = ctx.state.get("http_scheme", {}).get(target.host)
        if _pre:
            base_url = f"{_pre}://{target.host}"

        if not base_url:
            for scheme in ("https", "http"):
                try:
                    async with ctx.rate:
                        await ctx.http.head(f"{scheme}://{target.host}/", timeout=5.0)
                        base_url = f"{scheme}://{target.host}"
                        break
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"idor_tests": []},
            )

        # Test path-based IDOR
        for path_template in IDOR_PATHS:
            if ctx.should_stop:
                break
            responses: dict[str, tuple[int, int, str]] = {}

            for test_id in TEST_IDS:
                path = path_template.replace("{id}", str(test_id))
                url = f"{base_url}{path}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        responses[test_id] = (resp.status, len(body), body[:500])
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

            # Analyze: if multiple IDs return 200 with different content
            success_ids = [
                tid for tid, (status, _, _) in responses.items()
                if status == 200
            ]

            if len(success_ids) >= 2:
                # Check that responses are actually different (not generic page)
                bodies = [responses[tid][2] for tid in success_ids[:2]]
                if bodies[0] != bodies[1]:
                    sizes = [responses[tid][1] for tid in success_ids]
                    tested.append({
                        "path": path_template, "method": "path_id",
                        "accessible_ids": success_ids,
                    })
                    findings.append(Finding.high(
                        f"Potential IDOR: {path_template}",
                        description=(
                            "Multiple object IDs return 200 with different "
                            "content, suggesting missing authorization checks."
                        ),
                        evidence=(
                            f"Path: {path_template}\n"
                            f"IDs returning 200: {success_ids}\n"
                            f"Response sizes: {sizes}"
                        ),
                        remediation=(
                            "Implement proper authorization checks for all "
                            "object access. Verify the requesting user has "
                            "permission to access the requested resource. "
                            "Use UUIDs instead of sequential IDs."
                        ),
                        tags=["pentesting", "idor", "authorization"],
                    ))

        # Test query string-based IDOR
        for path, param in QS_IDOR_PATHS:
            responses = {}

            for test_id in TEST_IDS:
                url = f"{base_url}{path}?{param}={test_id}"
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(url, timeout=8.0)
                        body = await resp.text(encoding="utf-8", errors="replace")
                        responses[test_id] = (resp.status, len(body), body[:500])
                except Exception as e:
                    logger.debug("idor_check: %s", e)
                    continue

            success_ids = [
                tid for tid, (status, _, _) in responses.items()
                if status == 200
            ]

            if len(success_ids) >= 2:
                bodies = [responses[tid][2] for tid in success_ids[:2]]
                if bodies[0] != bodies[1]:
                    tested.append({
                        "path": path, "param": param, "method": "query_string",
                        "accessible_ids": success_ids,
                    })
                    findings.append(Finding.high(
                        f"Potential IDOR: {path}?{param}=",
                        description=(
                            f"Multiple object IDs accessible via query parameter "
                            f"'{param}' without apparent authorization."
                        ),
                        evidence=(
                            f"Path: {path}?{param}=\n"
                            f"IDs returning 200: {success_ids}\n"
                            f"Sizes: {[responses[tid][1] for tid in success_ids]}"
                        ),
                        remediation=(
                            "Implement server-side authorization checks. "
                            "Do not rely on obscurity of object IDs."
                        ),
                        tags=["pentesting", "idor", "authorization"],
                    ))

        # Check for numeric ID patterns in response bodies
        try:
            async with ctx.rate:
                resp = await ctx.http.get(f"{base_url}/", timeout=8.0)
                body = await resp.text(encoding="utf-8", errors="replace")

            # Find URLs with numeric IDs in HTML
            url_pattern = re.compile(
                r'(?:href|action|src)=["\']'
                r"(/[^\s\"']*?/\d+[^\s\"']*)"
                r'["\']'
            )
            found_urls = url_pattern.findall(body)
            if found_urls:
                for found_url in found_urls[:3]:
                    # Try incrementing the ID
                    id_match = re.search(r"/(\d+)", found_url)
                    if id_match:
                        original_id = int(id_match.group(1))
                        new_url = found_url.replace(
                            f"/{original_id}",
                            f"/{original_id + 1}",
                            1,
                        )
                        try:
                            async with ctx.rate:
                                resp1 = await ctx.http.get(
                                    f"{base_url}{found_url}", timeout=8.0,
                                )
                                resp2 = await ctx.http.get(
                                    f"{base_url}{new_url}", timeout=8.0,
                                )
                                if resp1.status == 200 and resp2.status == 200:
                                    b1 = await resp1.text(
                                        encoding="utf-8", errors="replace"
                                    )
                                    b2 = await resp2.text(
                                        encoding="utf-8", errors="replace"
                                    )
                                    if b1 != b2:
                                        tested.append({
                                            "path": found_url,
                                            "method": "discovered_url",
                                        })
                                        findings.append(Finding.medium(
                                            f"Enumerable resource: {found_url}",
                                            description=(
                                                "URL with sequential numeric ID "
                                                "discovered. Adjacent IDs return "
                                                "different content."
                                            ),
                                            evidence=(
                                                f"URL 1: {found_url} (200)\n"
                                                f"URL 2: {new_url} (200)\n"
                                                f"Sizes: {len(b1)} vs {len(b2)}"
                                            ),
                                            remediation=(
                                                "Use UUIDs instead of sequential "
                                                "IDs. Implement proper access "
                                                "controls."
                                            ),
                                            tags=["pentesting", "idor"],
                                        ))
                        except Exception as e:
                            logger.debug("idor_check: %s", e)
                            continue
        except Exception as e:
            logger.debug("idor_check: %s", e)

        if not findings:
            findings.append(Finding.info(
                "No IDOR vulnerabilities detected",
                tags=["pentesting", "idor"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"idor_tests": tested},
        )
