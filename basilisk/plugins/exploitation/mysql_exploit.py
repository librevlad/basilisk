"""MySQL exploitation — UDF, SELECT INTO OUTFILE, file read."""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)


class MysqlExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="mysql_exploit",
        display_name="MySQL Exploitation",
        category=PluginCategory.EXPLOITATION,
        description="Anonymous/default login, file read, UDF exploitation",
        depends_on=["service_brute"],
        produces=["mysql_access"],
        timeout=60.0,
        requires_http=False,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"accessible": False}

        # Find MySQL port — prefer autonomous executor's service port, then pipeline
        mysql_port = ctx.state.get("target_service_port") or 3306
        port_result = ctx.pipeline.get(f"port_scan:{target.host}")
        if mysql_port == 3306 and port_result and port_result.ok:
            for p in port_result.data.get("open_ports", []):
                p_info = p if isinstance(p, dict) else {"port": p}
                svc = str(p_info.get("service", "")).lower()
                banner = str(p_info.get("banner", "")).lower()
                if p_info.get("port") == 3306 or "mysql" in svc or "mysql" in banner:
                    mysql_port = p_info.get("port", 3306)
                    break

        if ctx.net:
            port_info = await ctx.net.check_port(target.host, mysql_port, timeout=3.0)
            if port_info.state.value != "open":
                return PluginResult.success(
                    self.meta.name, target.host,
                    findings=[Finding.info("MySQL port not open", tags=["mysql"])],
                )

        # Grab banner
        banner = ""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target.host, mysql_port), timeout=5.0,
            )
            banner_bytes = await asyncio.wait_for(reader.read(1024), timeout=3.0)
            banner = banner_bytes.decode("utf-8", errors="replace")
            writer.close()
        except Exception:
            pass

        if banner and len(banner) > 5:
            version_end = banner.find("\x00", 5)
            if version_end > 5:
                version = banner[5:version_end]
                data["version"] = version
                findings.append(Finding.info(
                    f"MySQL version: {version}",
                    evidence=f"Banner: {version}",
                    tags=["mysql"],
                ))

        # Note: actual MySQL exploitation requires mysql connector
        # which is not in base deps. Report what we find.
        findings.append(Finding.info(
            f"MySQL service detected on port {mysql_port}",
            evidence=f"Banner length: {len(banner)} bytes",
            description=f"Test with: mysql -h {target.host} -p{mysql_port} -u root -p",
            tags=["mysql"],
        ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
