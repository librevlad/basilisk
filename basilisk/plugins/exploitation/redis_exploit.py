"""Redis exploitation — CONFIG SET, SLAVEOF, unauthenticated access."""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

REDIS_PORT = 6379


class RedisExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="redis_exploit",
        display_name="Redis Exploitation",
        category=PluginCategory.EXPLOITATION,
        description="Unauthenticated access, CONFIG SET dir/dbfilename, Lua eval",
        depends_on=["service_brute"],
        produces=["redis_access"],
        timeout=30.0,
        requires_http=False,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"accessible": False, "noauth": False}

        if ctx.net and not await ctx.net.port_open(target.host, REDIS_PORT, timeout=3.0):
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("Redis port not open", tags=["redis"])],
            )

        # Try unauthenticated INFO command
        info = await self._send_command(target.host, "INFO server")
        if info and "redis_version" in info:
            data["accessible"] = True
            data["noauth"] = True

            version = ""
            for line in info.splitlines():
                if line.startswith("redis_version:"):
                    version = line.split(":")[1].strip()
                    data["version"] = version

            findings.append(Finding.critical(
                "Redis unauthenticated access",
                description="Redis is accessible without authentication",
                evidence=f"Version: {version}\n{info[:300]}",
                remediation="Set requirepass in redis.conf, bind to 127.0.0.1",
                tags=["redis", "noauth"],
            ))

            # Check CONFIG capability
            config_resp = await self._send_command(target.host, "CONFIG GET dir")
            if config_resp and "ERR" not in config_resp:
                data["config_writable"] = True
                findings.append(Finding.critical(
                    "Redis CONFIG writable — RCE possible",
                    description=(
                        "CONFIG SET is available. An attacker can write files "
                        "via CONFIG SET dir/dbfilename + SAVE (cron, SSH keys, webshell)"
                    ),
                    evidence=f"CONFIG GET dir: {config_resp[:200]}",
                    remediation="Disable CONFIG command: rename-command CONFIG \"\"",
                    tags=["redis", "rce", "config"],
                ))

            # Check EVAL (Lua)
            eval_resp = await self._send_command(
                target.host, 'EVAL "return 1+1" 0',
            )
            if eval_resp and "2" in eval_resp:
                findings.append(Finding.high(
                    "Redis Lua EVAL available",
                    evidence="EVAL 'return 1+1' 0 => 2",
                    tags=["redis", "lua"],
                ))

        elif info and "NOAUTH" in info:
            findings.append(Finding.info(
                "Redis requires authentication",
                evidence="NOAUTH Authentication required",
                tags=["redis"],
            ))
        else:
            findings.append(Finding.info(
                "Redis port open but unresponsive",
                tags=["redis"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _send_command(self, host: str, command: str) -> str:
        """Send a raw Redis command and return response."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, REDIS_PORT), timeout=5.0,
            )
            # RESP protocol
            parts = command.split()
            resp_cmd = f"*{len(parts)}\r\n"
            for part in parts:
                resp_cmd += f"${len(part)}\r\n{part}\r\n"

            writer.write(resp_cmd.encode())
            await writer.drain()
            data = await asyncio.wait_for(reader.read(4096), timeout=3.0)
            writer.close()
            return data.decode("utf-8", errors="replace")
        except Exception:
            return ""
