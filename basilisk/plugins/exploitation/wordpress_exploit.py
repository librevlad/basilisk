"""WordPress exploitation — plugin SQLi→RCE, theme editor, xmlrpc."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Known vulnerable WordPress plugin paths
VULN_PLUGIN_PATHS = [
    ("/wp-content/plugins/wp-file-manager/readme.txt",
     "WP File Manager RCE (CVE-2020-25213)"),
    ("/wp-content/plugins/easy-wp-smtp/readme.txt",
     "Easy WP SMTP password reset hijack"),
    ("/wp-content/plugins/duplicator/installer.php",
     "Duplicator arbitrary file download"),
    ("/wp-content/plugins/revslider/temp/update_extract/revslider/",
     "RevSlider arbitrary file download"),
    ("/wp-content/plugins/mailpoet/readme.txt",
     "MailPoet file upload RCE"),
    ("/wp-content/plugins/social-warfare/readme.txt",
     "Social Warfare RCE (CVE-2019-9978)"),
    ("/wp-content/plugins/wp-gdpr-compliance/readme.txt",
     "WP GDPR Compliance privilege escalation"),
]

# Theme editor paths (require auth)
THEME_EDITOR_PATHS = [
    "/wp-admin/theme-editor.php",
    "/wp-admin/plugin-editor.php",
]

# XMLRPC exploitation
XMLRPC_METHODS = [
    "system.listMethods",
    "wp.getUsersBlogs",
    "wp.getUsers",
]


class WordpressExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="wordpress_exploit",
        display_name="WordPress Exploitation",
        category=PluginCategory.EXPLOITATION,
        description="WordPress plugin vulnerabilities, theme editor RCE, xmlrpc abuse",
        depends_on=["wp_deep_scan"],
        produces=["wp_vulns"],
        timeout=60.0,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        data: dict = {"vuln_plugins": [], "xmlrpc": False}

        base_urls = await resolve_base_urls(target, ctx)
        if not base_urls:
            return PluginResult.fail(
                self.meta.name, target.host, error="Host not reachable",
            )

        base_url = base_urls[0]

        # Check vuln plugins
        for path, vuln_name in VULN_PLUGIN_PATHS:
            if ctx.should_stop:
                break
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(
                        base_url + path, timeout=5.0,
                    )
                    if resp.status == 200:
                        body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )
                        if len(body) > 50 and "404" not in body[:200].lower():
                            data["vuln_plugins"].append(path)
                            findings.append(Finding.high(
                                f"Vulnerable WP plugin: {vuln_name}",
                                evidence=f"URL: {base_url}{path}\nStatus: 200",
                                description=f"Known vulnerable: {vuln_name}",
                                remediation="Update or remove the vulnerable plugin",
                                tags=["wordpress", "plugin", "vuln"],
                            ))
            except Exception:
                continue

        # Check xmlrpc
        if not ctx.should_stop:
            try:
                async with ctx.rate:
                    resp = await ctx.http.post(
                        base_url + "/xmlrpc.php",
                        headers={"Content-Type": "text/xml"},
                        data=(
                            '<?xml version="1.0"?>'
                            "<methodCall>"
                            "<methodName>system.listMethods</methodName>"
                            "<params></params>"
                            "</methodCall>"
                        ),
                        timeout=5.0,
                    )
                    if resp.status == 200:
                        body = await resp.text(
                            encoding="utf-8", errors="replace",
                        )
                        if "methodResponse" in body:
                            data["xmlrpc"] = True
                            methods = body.count("<value><string>")
                            findings.append(Finding.medium(
                                f"WordPress XMLRPC enabled ({methods} methods)",
                                evidence=f"URL: {base_url}/xmlrpc.php",
                                description=(
                                    "XMLRPC can be used for brute force "
                                    "(wp.getUsersBlogs) and DDoS (pingback)"
                                ),
                                remediation="Disable XMLRPC if not needed",
                                tags=["wordpress", "xmlrpc"],
                            ))
            except Exception:
                pass

        # Check wp-login for user enumeration
        if not ctx.should_stop:
            for user_id in range(1, 6):
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            f"{base_url}/?author={user_id}",
                            timeout=5.0,
                            allow_redirects=False,
                        )
                        if resp.status in (200, 301):
                            location = resp.headers.get("Location", "")
                            if "/author/" in location:
                                username = location.split("/author/")[1].rstrip("/")
                                findings.append(Finding.low(
                                    f"WordPress user enumerated: {username}",
                                    evidence=f"?author={user_id} -> {username}",
                                    tags=["wordpress", "user-enum"],
                                ))
                except Exception:
                    continue

        if not findings:
            findings.append(Finding.info(
                "WordPress detected but no known vulnerabilities found",
                tags=["wordpress"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
