"""LDAP enumeration â€” anonymous bind, users, groups, computers."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

LDAP_PORTS = [389, 636, 3268, 3269]


class LdapEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="ldap_enum",
        display_name="LDAP/AD Enumeration",
        category=PluginCategory.EXPLOITATION,
        description="Anonymous bind, user/group/computer enumeration, SPN/AS-REP discovery",
        depends_on=["port_scan"],
        produces=["ldap_users", "ldap_groups", "spn_users", "asrep_users"],
        timeout=120.0,
        requires_http=False,
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {
            "users": [], "groups": [], "computers": [],
            "spn_users": [], "asrep_users": [], "domain_admins": [],
        }

        ldap_port = await self._find_ldap_port(target, ctx)
        if not ldap_port:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("LDAP ports not open", tags=["ldap"])],
            )

        if not ctx.ldap:
            findings.append(Finding.info(
                f"LDAP port {ldap_port} open (ldap3 not installed for deep enum)",
                evidence=f"Port {ldap_port} open on {target.host}",
                tags=["ldap"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        use_ssl = ldap_port in (636, 3269)
        connected = await ctx.ldap.connect(target.host, ldap_port, use_ssl=use_ssl)
        if not connected:
            findings.append(Finding.info("LDAP connection failed", tags=["ldap"]))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        # Try anonymous bind
        anon = await ctx.ldap.anonymous_bind()
        if anon:
            findings.append(Finding.high(
                "LDAP anonymous bind allowed",
                description="Anonymous LDAP access enables user/group enumeration",
                evidence=f"Anonymous bind on {target.host}:{ldap_port}",
                remediation="Disable anonymous LDAP binds",
                tags=["ldap", "anonymous"],
            ))
        else:
            # Try with credentials
            creds = ctx.state.get("credentials", [])
            bound = False
            for cred in creds:
                if await ctx.ldap.bind(
                    cred.get("username", ""), cred.get("password", ""),
                    cred.get("domain", ""),
                ):
                    bound = True
                    break
            if not bound:
                findings.append(Finding.info(
                    "LDAP requires authentication (no anon bind)",
                    tags=["ldap"],
                ))
                await ctx.ldap.close()
                return PluginResult.success(
                    self.meta.name, target.host, findings=findings, data=data,
                )

        # Get base DN
        base_dn = await ctx.ldap.get_base_dn()
        if base_dn:
            data["base_dn"] = base_dn

        # Enumerate users
        if not ctx.should_stop:
            users = await ctx.ldap.get_users(base_dn)
            data["users"] = [
                {"username": u.username, "dn": u.dn, "enabled": u.enabled}
                for u in users
            ]
            if users:
                findings.append(Finding.medium(
                    f"LDAP user enumeration: {len(users)} users found",
                    evidence="\n".join(
                        f"  {u.username} ({'enabled' if u.enabled else 'disabled'})"
                        for u in users[:20]
                    ),
                    tags=["ldap", "users"],
                ))

        # Enumerate domain admins
        if not ctx.should_stop:
            admins = await ctx.ldap.get_domain_admins(base_dn)
            data["domain_admins"] = admins
            if admins:
                findings.append(Finding.high(
                    f"Domain Admins enumerated: {len(admins)} members",
                    evidence="\n".join(f"  {a}" for a in admins[:20]),
                    tags=["ldap", "domain-admins"],
                ))

        # Find Kerberoastable users
        if not ctx.should_stop:
            spn_users = await ctx.ldap.get_spns(base_dn)
            data["spn_users"] = [
                {"username": u.username, "spn": u.spn} for u in spn_users
            ]
            if spn_users:
                findings.append(Finding.high(
                    f"Kerberoastable accounts found: {len(spn_users)}",
                    description="These accounts have SPNs and can be Kerberoasted",
                    evidence="\n".join(
                        f"  {u.username}: {', '.join(u.spn[:3])}"
                        for u in spn_users[:10]
                    ),
                    tags=["ldap", "kerberoast", "spn"],
                ))

        # Find AS-REP roastable users
        if not ctx.should_stop:
            asrep = await ctx.ldap.get_asrep_roastable(base_dn)
            data["asrep_users"] = [{"username": u.username} for u in asrep]
            if asrep:
                findings.append(Finding.high(
                    f"AS-REP roastable accounts found: {len(asrep)}",
                    description="These accounts don't require Kerberos pre-auth",
                    evidence="\n".join(f"  {u.username}" for u in asrep[:10]),
                    tags=["ldap", "asrep-roast"],
                ))

        await ctx.ldap.close()
        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _find_ldap_port(self, target: Target, ctx) -> int | None:
        """Find which LDAP port is open."""
        port_result = ctx.pipeline.get(f"port_scan:{target.host}")
        if port_result and port_result.ok:
            open_ports = port_result.data.get("open_ports", [])
            for p in LDAP_PORTS:
                if p in open_ports:
                    return p
        if ctx.net:
            for p in LDAP_PORTS:
                if await ctx.net.port_open(target.host, p, timeout=3.0):
                    return p
        return None
