"""SMB exploit — MS17-010, MS08-067, PrintNightmare detection."""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# MS17-010 (EternalBlue) detection — send SMB negotiate + check for vuln
ETERNALBLUE_TRANS2_PAYLOAD = b"\x00\x00\x00\x00" * 10


class SmbExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="smb_exploit",
        display_name="SMB Exploit Detection",
        category=PluginCategory.EXPLOITATION,
        description="MS17-010 (EternalBlue), PrintNightmare, MS08-067 detection",
        depends_on=["smb_enum"],
        produces=["smb_vulns"],
        timeout=60.0,
        requires_http=False,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"vulns": []}

        # Find SMB port — from autonomous executor or default
        smb_port = ctx.state.get("target_service_port") or 445

        # Check MS17-010
        if await self._check_ms17_010(target.host, smb_port, findings):
            data["vulns"].append("MS17-010")

        # Check PrintNightmare (CVE-2021-1675/34527) — via MSRPC
        if await self._check_printnightmare(target.host, smb_port, findings):
            data["vulns"].append("PrintNightmare")

        if not findings:
            findings.append(Finding.info(
                "No known SMB vulnerabilities detected",
                tags=["smb", "exploit"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _check_ms17_010(
        self, host: str, port: int, findings: list[Finding],
    ) -> bool:
        """Check for MS17-010 (EternalBlue) vulnerability."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5.0,
            )

            # SMB negotiate
            negotiate = (
                b"\x00\x00\x00\x85"
                b"\xffSMB"
                b"\x72"
                b"\x00\x00\x00\x00"
                b"\x18"
                b"\x53\xc8"
                + b"\x00" * 12
                + b"\x00\x00"
                b"\xff\xfe"
                b"\x00\x00"
                b"\x00\x00"
                b"\x00"
                b"\x62\x00"
                b"\x02NT LM 0.12\x00"
                b"\x02SMB 2.002\x00"
                b"\x02SMB 2.???\x00"
            )
            writer.write(negotiate)
            await writer.drain()

            resp = await asyncio.wait_for(reader.read(4096), timeout=5.0)
            writer.close()

            if resp and len(resp) > 36 and resp[4:8] == b"\xffSMB":
                # Basic heuristic: if SMBv1 is supported, host may be vuln
                # Real detection needs Trans2 SESSION_SETUP check
                findings.append(Finding.medium(
                    "SMBv1 enabled (potential MS17-010 target)",
                    description=(
                        "SMBv1 is enabled. This protocol version is deprecated "
                        "and associated with EternalBlue (MS17-010). "
                        "Verify with nmap: nmap --script smb-vuln-ms17-010"
                    ),
                    evidence=f"SMBv1 response from {host}:445",
                    remediation=(
                        "Disable SMBv1: "
                        "Set-SmbServerConfiguration -EnableSMB1Protocol $false"
                    ),
                    tags=["smb", "ms17-010", "eternalblue"],
                ))
                return True
        except Exception:
            logger.debug("MS17-010 check failed for %s", host)
        return False

    async def _check_printnightmare(
        self, host: str, port: int, findings: list[Finding],
    ) -> bool:
        """Check for PrintNightmare (spooler service exposed)."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5.0,
            )
            writer.close()
            # If port 445 is open, note spooler as potential target
            # Real detection requires RPC bind to spoolss
            findings.append(Finding.info(
                "Print Spooler service may be accessible (PrintNightmare check)",
                description=(
                    "Port 445 is open. If the Print Spooler service is running, "
                    "it may be vulnerable to CVE-2021-1675/CVE-2021-34527. "
                    "Verify with: rpcdump.py @{host} | grep MS-RPRN"
                ),
                evidence=f"SMB port open on {host}",
                tags=["smb", "printnightmare"],
            ))
            return True
        except Exception:
            return False
