"""Virtual host enumeration â€” critical for HTB and real pentests."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Common vhost prefixes for brute-forcing
VHOST_PREFIXES = [
    "admin", "api", "app", "beta", "blog", "cms", "console", "dashboard",
    "dev", "developer", "devops", "docs", "git", "gitlab", "grafana",
    "help", "internal", "intranet", "jenkins", "jira", "kibana",
    "login", "mail", "manage", "monitor", "new", "old", "panel",
    "phpmyadmin", "portal", "prometheus", "proxy", "qa", "registry",
    "staging", "static", "status", "store", "support", "test",
    "testing", "tool", "tools", "vault", "vpn", "webmail", "wiki",
    "www", "www2", "backup", "db", "debug", "demo", "deploy", "edge",
    "elastic", "elk", "files", "ftp", "gateway", "graphql", "home",
    "hub", "id", "img", "images", "infra", "ldap", "log", "logs",
    "media", "metrics", "mobile", "mysql", "nextcloud", "nginx",
    "node", "ns1", "ns2", "office", "owa", "pma", "pop", "postgres",
    "puppet", "queue", "rabbitmq", "redis", "remote", "repo", "rest",
    "sentry", "shop", "smtp", "sonar", "splunk", "ssh", "ssl",
    "sso", "stack", "stage", "traefik", "webdav", "zabbix",
]


class VhostEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="vhost_enum",
        display_name="Virtual Host Enumeration",
        category=PluginCategory.EXPLOITATION,
        description="Discover virtual hosts by fuzzing the Host header",
        depends_on=["port_scan"],
        produces=["vhosts"],
        timeout=120.0,
        requires_http=True,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        data: dict = {"vhosts": []}

        base_urls = await resolve_base_urls(target, ctx)
        if not base_urls:
            return PluginResult.fail(
                self.meta.name, target.host, error="Host not reachable",
            )

        base_url = base_urls[0]

        # Get baseline response
        baseline = await self._get_baseline(ctx, base_url, target.host)
        if baseline is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="Could not get baseline response",
            )

        # Extract domain for vhost construction
        domain = target.host
        # Build vhost list
        vhosts = [f"{prefix}.{domain}" for prefix in VHOST_PREFIXES]

        # Also try wordlist if available
        if ctx.wordlists:
            try:
                wl = await ctx.wordlists.get("vhosts")
                if wl:
                    for word in wl[:1000]:
                        vhosts.append(f"{word.strip()}.{domain}")
            except Exception:
                pass

        # Deduplicate
        vhosts = list(dict.fromkeys(vhosts))

        # Fuzz Host header
        found = []
        for vhost in vhosts:
            if ctx.should_stop:
                break
            async with ctx.rate:
                try:
                    resp = await ctx.http.get(
                        base_url + "/",
                        headers={"Host": vhost},
                        timeout=5.0,
                    )
                    status = resp.status
                    body = await resp.text(encoding="utf-8", errors="replace")
                    length = len(body)

                    # Compare with baseline
                    if self._is_different(baseline, status, length, body):
                        found.append({
                            "vhost": vhost, "status": status,
                            "length": length,
                        })
                        data["vhosts"].append(vhost)
                except Exception:
                    continue

        if found:
            findings.append(Finding.high(
                f"Virtual hosts discovered: {len(found)}",
                description="Different responses for different Host headers",
                evidence="\n".join(
                    f"  {v['vhost']}: HTTP {v['status']} ({v['length']} bytes)"
                    for v in found[:20]
                ),
                remediation="Review virtual host configuration",
                tags=["vhost", "enumeration"],
            ))
        else:
            findings.append(Finding.info(
                "No additional virtual hosts found",
                tags=["vhost"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _get_baseline(self, ctx, base_url: str, host: str):
        """Get baseline response for comparison."""
        try:
            # Use a random nonexistent vhost as baseline
            resp = await ctx.http.get(
                base_url + "/",
                headers={"Host": f"nonexistent-8xz7.{host}"},
                timeout=5.0,
            )
            body = await resp.text(encoding="utf-8", errors="replace")
            return {
                "status": resp.status, "length": len(body),
                "body_start": body[:500],
            }
        except Exception:
            return None

    @staticmethod
    def _is_different(baseline: dict, status: int, length: int, body: str) -> bool:
        """Check if response differs from baseline."""
        if status != baseline["status"]:
            return True
        if abs(length - baseline["length"]) > 100:
            return True
        return body[:500] != baseline["body_start"]
