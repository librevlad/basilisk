"""SMB enumeration â€” null session, guest, share listing, file enumeration."""

from __future__ import annotations

import asyncio
import logging
import struct
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# SMB ports to check
SMB_PORTS = [445, 139]

# Interesting file patterns in shares
INTERESTING_FILES = [
    ".xml", ".config", ".conf", ".ini", ".txt", ".bat", ".ps1",
    ".vbs", ".cmd", ".kdbx", ".key", ".pem", ".pfx", ".p12",
    ".bak", ".old", ".sql", ".mdb", ".accdb",
]

SENSITIVE_FILENAMES = [
    "password", "credential", "secret", "backup", "web.config",
    "unattend.xml", "sysprep.xml", "groups.xml", "scheduledtasks.xml",
    "services.xml", "printers.xml", "drives.xml", "datasources.xml",
]


class SmbEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="smb_enum",
        display_name="SMB Enumeration",
        category=PluginCategory.EXPLOITATION,
        description="Null/guest session, share listing, sensitive file enumeration",
        depends_on=["port_scan"],
        produces=["smb_shares", "smb_files", "credentials"],
        timeout=90.0,
        requires_http=False,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"shares": [], "files": [], "credentials": []}

        # Check if SMB port is open
        smb_port = await self._find_smb_port(target, ctx)
        if not smb_port:
            return PluginResult.success(
                self.meta.name, target.host, findings=[
                    Finding.info("SMB ports not open (445/139)", tags=["smb"]),
                ],
            )

        # Try null session
        null_success = await self._try_null_session(
            target.host, smb_port, findings, data, ctx,
        )

        # Try guest session
        if not null_success:
            await self._try_guest_session(
                target.host, smb_port, findings, data, ctx,
            )

        # Try with found credentials
        if ctx.state.get("credentials"):
            for cred in ctx.state["credentials"]:
                if ctx.should_stop:
                    break
                await self._try_cred_session(
                    target.host, smb_port, cred, findings, data, ctx,
                )

        if not findings:
            findings.append(Finding.info(
                "SMB accessible but no anonymous/guest access",
                tags=["smb"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _find_smb_port(self, target: Target, ctx) -> int | None:
        """Find which SMB port is open."""
        port_result = ctx.pipeline.get(f"port_scan:{target.host}")
        if port_result and port_result.ok:
            open_ports = port_result.data.get("open_ports", [])
            for p in SMB_PORTS:
                if p in open_ports:
                    return p

        # Direct check
        if ctx.net:
            for p in SMB_PORTS:
                if await ctx.net.port_open(target.host, p, timeout=3.0):
                    return p
        return None

    async def _try_null_session(
        self, host: str, port: int, findings: list[Finding],
        data: dict, ctx,
    ) -> bool:
        """Try null session authentication."""
        if not ctx.smb:
            return await self._try_null_session_raw(host, port, findings, data)

        try:
            conn = await ctx.smb.connect(host, port)
            if await ctx.smb.null_session(conn):
                findings.append(Finding.high(
                    "SMB null session allowed",
                    description="Anonymous access to SMB shares is permitted",
                    evidence=f"Null session on {host}:{port}",
                    remediation="Disable null sessions: RestrictAnonymous=2",
                    tags=["smb", "null-session"],
                ))
                await self._enum_shares(ctx.smb, conn, findings, data, "null")
                await ctx.smb.close(conn)
                return True
            await ctx.smb.close(conn)
        except Exception:
            logger.debug("SMB null session failed on %s", host)
        return False

    async def _try_null_session_raw(
        self, host: str, port: int, findings: list[Finding], data: dict,
    ) -> bool:
        """Raw SMB null session probe without impacket."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port), timeout=5.0,
            )
            # SMB negotiate + null session setup
            negotiate = self._build_smb_negotiate()
            writer.write(negotiate)
            await writer.drain()
            resp = await asyncio.wait_for(reader.read(4096), timeout=5.0)
            writer.close()

            if resp and len(resp) > 36:
                # Check if SMB is responsive
                findings.append(Finding.info(
                    f"SMB service on port {port}",
                    evidence=f"Response size: {len(resp)} bytes",
                    tags=["smb"],
                ))
                return False
        except Exception:
            pass
        return False

    async def _try_guest_session(
        self, host: str, port: int, findings: list[Finding],
        data: dict, ctx,
    ) -> bool:
        """Try guest session authentication."""
        if not ctx.smb:
            return False
        try:
            conn = await ctx.smb.connect(host, port)
            if await ctx.smb.guest_session(conn):
                findings.append(Finding.medium(
                    "SMB guest session allowed",
                    description="Guest access to SMB shares is permitted",
                    evidence=f"Guest session on {host}:{port}",
                    remediation="Disable guest access in SMB configuration",
                    tags=["smb", "guest-session"],
                ))
                await self._enum_shares(ctx.smb, conn, findings, data, "guest")
                await ctx.smb.close(conn)
                return True
            await ctx.smb.close(conn)
        except Exception:
            logger.debug("SMB guest session failed on %s", host)
        return False

    async def _try_cred_session(
        self, host: str, port: int, cred: dict, findings: list[Finding],
        data: dict, ctx,
    ) -> bool:
        """Try session with found credentials."""
        if not ctx.smb:
            return False
        try:
            conn = await ctx.smb.connect(host, port)
            success = await ctx.smb.authenticate(
                conn, cred.get("username", ""),
                cred.get("password", ""),
                cred.get("domain", ""),
            )
            if success:
                findings.append(Finding.high(
                    f"SMB auth success: {cred.get('username', '')}",
                    evidence=f"User {cred['username']}@{host}",
                    tags=["smb", "credential"],
                ))
                await self._enum_shares(
                    ctx.smb, conn, findings, data, cred["username"],
                )
            await ctx.smb.close(conn)
            return success
        except Exception:
            return False

    async def _enum_shares(self, smb, conn, findings, data, auth_type):
        """Enumerate shares and look for interesting files."""
        shares = await smb.list_shares(conn)
        share_info = []
        for share in shares:
            share_dict = {
                "name": share.name, "comment": share.comment,
                "readable": False, "writable": False,
            }
            # Try to list files (determines read access)
            files = await smb.list_files(conn, share.name)
            if files:
                share_dict["readable"] = True
                file_names = [f.name for f in files[:50]]
                share_dict["files"] = file_names

                # Check for interesting files
                for f in files:
                    name_lower = f.name.lower()
                    if any(name_lower.endswith(ext) for ext in INTERESTING_FILES):
                        data["files"].append({
                            "share": share.name, "file": f.name,
                            "size": f.size,
                        })
                    if any(s in name_lower for s in SENSITIVE_FILENAMES):
                        findings.append(Finding.high(
                            f"Sensitive file in SMB share: {share.name}/{f.name}",
                            evidence=f"File: \\\\{conn.host}\\{share.name}\\{f.name}",
                            description=f"Found via {auth_type} session",
                            tags=["smb", "sensitive-file"],
                        ))
            share_info.append(share_dict)

        data["shares"] = share_info
        if share_info:
            readable = [s for s in share_info if s["readable"]]
            findings.append(Finding.medium(
                f"SMB shares enumerated: {len(share_info)} total, "
                f"{len(readable)} readable ({auth_type})",
                evidence="\n".join(
                    f"  {s['name']}: {'R' if s['readable'] else '-'}"
                    for s in share_info
                ),
                tags=["smb", "shares"],
            ))

    @staticmethod
    def _build_smb_negotiate() -> bytes:
        """Build minimal SMB negotiate packet."""
        # NetBIOS session + SMB1 negotiate
        smb_header = b"\xffSMB"  # Protocol
        smb_header += b"\x72"     # Negotiate
        smb_header += b"\x00" * 27  # Minimal header
        dialects = b"\x02NT LM 0.12\x00"
        length = len(smb_header) + len(dialects)
        netbios = struct.pack(">I", length)
        return netbios + smb_header + dialects
