"""SNMP enumeration â€” community string brute, full walk, process listing."""

from __future__ import annotations

import asyncio
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

SNMP_PORT = 161

# Common SNMP community strings
COMMUNITIES = [
    "public", "private", "community", "manager", "admin",
    "snmp", "default", "monitor", "test", "internal",
    "secret", "cisco", "router", "switch", "read",
]

# Useful OIDs
OIDS = {
    "sysDescr": "1.3.6.1.2.1.1.1.0",
    "sysName": "1.3.6.1.2.1.1.5.0",
    "sysContact": "1.3.6.1.2.1.1.4.0",
    "sysLocation": "1.3.6.1.2.1.1.6.0",
    "hrSWRunName": "1.3.6.1.2.1.25.4.2.1.2",  # Running processes
    "tcpConnTable": "1.3.6.1.2.1.6.13.1",      # TCP connections
    "ipAddrTable": "1.3.6.1.2.1.4.20.1",       # IP addresses
}


class SnmpEnumPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="snmp_enum",
        display_name="SNMP Enumeration",
        category=PluginCategory.EXPLOITATION,
        description="SNMP community string brute-force, system info, process listing",
        depends_on=["port_scan"],
        produces=["snmp_info", "credentials"],
        timeout=60.0,
        requires_http=False,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"communities": [], "system_info": {}}

        # Check if SNMP port is open (UDP)
        # UDP check via raw socket attempt
        found_communities = await self._brute_communities(target.host)

        if not found_communities:
            findings.append(Finding.info(
                "SNMP not responding or no common community strings",
                tags=["snmp"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        data["communities"] = found_communities

        # Report found community strings
        for community in found_communities:
            severity = "high" if community in ("private", "secret") else "medium"
            finding_fn = Finding.high if severity == "high" else Finding.medium
            findings.append(finding_fn(
                f"SNMP community string found: {community}",
                evidence=f"Community: {community} on {target.host}:{SNMP_PORT}",
                description=(
                    "Writable community" if community == "private"
                    else "Readable community"
                ),
                remediation="Change default SNMP community strings, use SNMPv3",
                tags=["snmp", "community-string"],
            ))

        # Try to get system info with first community
        if ctx.subprocess_mgr and ctx.subprocess_mgr.is_available("snmpwalk"):
            community = found_communities[0]
            result = await ctx.subprocess_mgr.run(
                [
                    "snmpwalk", "-v2c", "-c", community,
                    target.host, "1.3.6.1.2.1.1",
                ],
                timeout=15.0,
            )
            if result.ok and result.stdout:
                data["system_info"]["raw"] = result.stdout[:2000]
                findings.append(Finding.medium(
                    "SNMP system info enumerated",
                    evidence=result.stdout[:500],
                    tags=["snmp", "enum"],
                ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _brute_communities(self, host: str) -> list[str]:
        """Try common SNMP community strings via UDP."""
        found = []

        for community in COMMUNITIES:
            try:
                pkt = self._build_snmp_get(community, "1.3.6.1.2.1.1.1.0")
                transport, protocol = await asyncio.wait_for(
                    asyncio.get_event_loop().create_datagram_endpoint(
                        asyncio.DatagramProtocol,
                        remote_addr=(host, SNMP_PORT),
                    ),
                    timeout=2.0,
                )
                transport.sendto(pkt)
                await asyncio.sleep(0.5)
                transport.close()
                # Note: proper response parsing requires pysnmp
                # This is a basic probe; real implementation would parse response
            except Exception:
                continue

        # Fallback: use subprocess with snmpget if available
        try:
            for community in COMMUNITIES[:5]:
                proc = await asyncio.create_subprocess_exec(
                    "snmpget", "-v2c", "-c", community, "-t", "2",
                    host, "1.3.6.1.2.1.1.1.0",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=5.0)
                if proc.returncode == 0 and stdout:
                    found.append(community)
        except (FileNotFoundError, TimeoutError):
            pass

        return found

    @staticmethod
    def _build_snmp_get(community: str, oid: str) -> bytes:
        """Build a minimal SNMPv2c GET request packet."""
        # Simplified ASN.1/BER encoding for SNMP GET
        community_bytes = community.encode()

        # OID encoding (simplified)
        oid_parts = [int(x) for x in oid.split(".")]
        oid_encoded = bytes([oid_parts[0] * 40 + oid_parts[1]])
        for part in oid_parts[2:]:
            if part < 128:
                oid_encoded += bytes([part])
            else:
                high = (part >> 7) | 0x80
                low = part & 0x7F
                oid_encoded += bytes([high, low])

        # Build varbind
        varbind = (
            b"\x30" + bytes([len(oid_encoded) + 4])
            + b"\x06" + bytes([len(oid_encoded)]) + oid_encoded
            + b"\x05\x00"  # NULL value
        )
        varbind_list = b"\x30" + bytes([len(varbind)]) + varbind

        # PDU (GET request)
        request_id = b"\x02\x01\x01"  # integer 1
        error = b"\x02\x01\x00"
        error_index = b"\x02\x01\x00"
        pdu_content = request_id + error + error_index + varbind_list
        pdu = b"\xa0" + bytes([len(pdu_content)]) + pdu_content

        # Message
        version = b"\x02\x01\x01"  # SNMPv2c
        comm = b"\x04" + bytes([len(community_bytes)]) + community_bytes
        msg_content = version + comm + pdu
        message = b"\x30" + bytes([len(msg_content)]) + msg_content

        return message
