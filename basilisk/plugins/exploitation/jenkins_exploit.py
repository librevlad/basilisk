"""Jenkins exploitation â€” Script console, unauth API, CVEs."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target
from basilisk.utils.http import resolve_base_urls

logger = logging.getLogger(__name__)

# Jenkins endpoints to check
JENKINS_PATHS = [
    ("/script", "Script Console (Groovy RCE)"),
    ("/manage", "Management Dashboard"),
    ("/api/json", "JSON API (info disclosure)"),
    ("/asynchPeople/", "User Enumeration"),
    ("/credentials/", "Credential Manager"),
    ("/systemInfo", "System Information"),
    ("/env", "Environment Variables"),
    ("/log/", "Build Logs"),
    ("/computer/", "Node Information"),
    ("/pluginManager/", "Plugin Manager"),
    ("/configureSecurity/", "Security Configuration"),
]


class JenkinsExploitPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="jenkins_exploit",
        display_name="Jenkins Exploitation",
        category=PluginCategory.EXPLOITATION,
        description="Jenkins Script Console RCE, unauth API, credential extraction",
        depends_on=["tech_detect"],
        produces=["jenkins_access"],
        timeout=60.0,
        risk_level="noisy",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        if ctx.http is None:
            return PluginResult.fail(
                self.meta.name, target.host, error="HTTP client not available",
            )

        findings: list[Finding] = []
        data: dict = {"accessible_endpoints": [], "version": ""}

        base_urls = await resolve_base_urls(target, ctx)
        if not base_urls:
            return PluginResult.fail(
                self.meta.name, target.host, error="Host not reachable",
            )

        for base_url in base_urls:
            if ctx.should_stop:
                break

            # Check if it's Jenkins
            try:
                async with ctx.rate:
                    resp = await ctx.http.get(base_url + "/", timeout=5.0)
                    headers = dict(resp.headers)
                    if "x-jenkins" in {k.lower() for k in headers}:
                        version = headers.get(
                            "X-Jenkins", headers.get("x-jenkins", ""),
                        )
                        data["version"] = version
                        findings.append(Finding.info(
                            f"Jenkins version: {version}",
                            evidence=f"X-Jenkins: {version}",
                            tags=["jenkins"],
                        ))
                    else:
                        body = await resp.text(encoding="utf-8", errors="replace")
                        if "jenkins" not in body.lower():
                            continue
            except Exception:
                continue

            # Check each endpoint
            for path, description in JENKINS_PATHS:
                if ctx.should_stop:
                    break
                try:
                    async with ctx.rate:
                        resp = await ctx.http.get(
                            base_url + path, timeout=5.0,
                        )
                        if resp.status == 200:
                            body = await resp.text(
                                encoding="utf-8", errors="replace",
                            )
                            if (
                                "login" not in body.lower()[:500]
                                and len(body) > 100
                            ):
                                data["accessible_endpoints"].append(path)
                                severity = "critical" if path == "/script" else (
                                    "high" if path in (
                                        "/credentials/", "/manage",
                                        "/configureSecurity/",
                                    ) else "medium"
                                )
                                finding_fn = {
                                    "critical": Finding.critical,
                                    "high": Finding.high,
                                    "medium": Finding.medium,
                                }[severity]
                                findings.append(finding_fn(
                                    f"Jenkins {description} accessible",
                                    evidence=f"URL: {base_url}{path}\n"
                                    f"Status: 200\nBody: {body[:200]}",
                                    description=(
                                        "Script Console = direct RCE via Groovy"
                                        if path == "/script"
                                        else f"Unauthenticated access to {description}"
                                    ),
                                    remediation=(
                                        "Enable authentication, restrict access "
                                        "to Jenkins admin interface"
                                    ),
                                    tags=["jenkins", "unauth"],
                                ))
                except Exception:
                    continue

        if not findings:
            findings.append(Finding.info(
                "Jenkins not detected or fully authenticated",
                tags=["jenkins"],
            ))

        return PluginResult.success(
            self.meta.name, target.host, findings=findings, data=data,
        )
