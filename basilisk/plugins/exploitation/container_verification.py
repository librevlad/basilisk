"""Container finding verification â€” re-probe container security findings."""

from __future__ import annotations

import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)


class ContainerVerificationPlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="container_verification",
        display_name="Container Finding Verification",
        category=PluginCategory.EXPLOITATION,
        description="Re-verify container security findings to reduce false positives",
        depends_on=["container_config_audit", "container_escape_probe"],
        produces=["verified_container_findings"],
        timeout=30.0,
        requires_http=False,
        risk_level="safe",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        verified: list[dict] = []

        # Gather container findings from pipeline
        container_findings = self._collect_container_findings(target.host, ctx)

        if not container_findings:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No container findings to verify", tags=["container"])],
                data={"verified_container_findings": []},
            )

        api_url = self._get_api_url(target.host, ctx)
        containers = self._collect_containers(target.host, ctx)

        for cf in container_findings:
            title = cf.get("title", "")
            severity = cf.get("severity", "info")

            # Only verify HIGH/CRITICAL findings
            if severity not in ("high", "critical"):
                continue

            confirmed = await self._verify_finding(
                ctx, cf, api_url, containers,
            )

            if confirmed:
                verified.append({"title": title, "confirmed": True})
                findings.append(Finding(
                    title=f"Verified: {title}",
                    severity=cf.get("severity_obj", Finding.high("").severity),
                    evidence=f"Re-verification confirmed: {title}",
                    description="Finding confirmed on re-probe",
                    tags=["container", "verified"],
                    confidence=0.85,
                ))
            else:
                verified.append({"title": title, "confirmed": False})
                findings.append(Finding.info(
                    f"Not confirmed: {title}",
                    description="Finding not reproduced on re-verification",
                    tags=["container", "false_positive"],
                ))

        if not findings:
            findings.append(Finding.info(
                "Container verification complete", tags=["container"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"verified_container_findings": verified},
        )

    async def _verify_finding(
        self, ctx, finding: dict, api_url: str, containers: list[dict],
    ) -> bool:
        """Re-probe a specific finding to confirm it."""
        title = finding.get("title", "").lower()

        # Verify privileged container
        if "privileged" in title:
            return any(c.get("privileged") for c in containers)

        # Verify docker socket mount
        if "socket" in title or "docker.sock" in title:
            for c in containers:
                mounts = c.get("mounts", [])
                for m in mounts:
                    path = m if isinstance(m, str) else m.get("Source", "")
                    if "docker.sock" in path:
                        return True
            return False

        # Verify host PID
        if "pid" in title:
            return any(c.get("pid_mode") == "host" for c in containers)

        # Verify host network
        if "network" in title:
            return any(c.get("network_mode") == "host" for c in containers)

        # Verify Docker API access
        if "api" in title and api_url:
            return await self._verify_api_access(ctx, api_url)

        # Verify CAP_SYS_ADMIN
        if "cap_sys_admin" in title or "sys_admin" in title:
            for c in containers:
                caps = c.get("capabilities", [])
                if "CAP_SYS_ADMIN" in caps or "SYS_ADMIN" in caps:
                    return True
            return False

        # Default: cannot verify, treat as unconfirmed
        return False

    async def _verify_api_access(self, ctx, api_url: str) -> bool:
        """Re-check Docker API accessibility."""
        if not ctx.http:
            return False
        try:
            async with ctx.rate:
                resp = await ctx.http.get(api_url + "/version", timeout=5.0)
                if resp.status == 200:
                    body = await resp.text(encoding="utf-8", errors="replace")
                    return "ApiVersion" in body or "Version" in body
        except Exception:
            pass
        return False

    def _collect_container_findings(self, host: str, ctx) -> list[dict]:
        """Collect HIGH/CRITICAL container findings from pipeline."""
        container_findings = []
        for _key, result in ctx.pipeline.items():
            if not result.ok:
                continue
            for f in result.findings:
                tags = getattr(f, "tags", []) or []
                if "container" not in tags:
                    continue
                sev = f.severity.name.lower() if hasattr(f.severity, "name") else str(f.severity)
                if sev in ("high", "critical"):
                    container_findings.append({
                        "title": f.title,
                        "severity": sev,
                        "severity_obj": f.severity,
                        "evidence": getattr(f, "evidence", ""),
                    })
        return container_findings

    def _collect_containers(self, host: str, ctx) -> list[dict]:
        """Collect container data from state and pipeline."""
        containers = ctx.state.get("containers", {}).get(host, [])
        if containers:
            return containers
        enum_key = f"container_enumeration:{host}"
        enum_result = ctx.pipeline.get(enum_key)
        if enum_result and enum_result.ok:
            return enum_result.data.get("containers", [])
        return []

    def _get_api_url(self, host: str, ctx) -> str:
        """Find Docker API URL from state."""
        runtimes = ctx.state.get("container_runtimes", {}).get(host, [])
        for rt in runtimes:
            if isinstance(rt, dict) and rt.get("api_url"):
                return rt["api_url"]
        return ""
