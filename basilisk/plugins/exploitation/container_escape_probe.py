"""Container escape probe — detect escape vectors via Docker API and config analysis."""

from __future__ import annotations

import json
import logging
from typing import ClassVar

from basilisk.core.plugin import BasePlugin, PluginCategory, PluginMeta
from basilisk.models.result import Finding, PluginResult
from basilisk.models.target import Target

logger = logging.getLogger(__name__)

# Kernel versions with known container escape CVEs
ESCAPE_CVES: dict[str, str] = {
    "CVE-2019-5736": "runc < 1.0.0-rc6 — overwrite host runc binary",
    "CVE-2020-15257": "containerd < 1.3.9 — host network namespace escape",
    "CVE-2022-0847": "Dirty Pipe (kernel 5.8-5.16.10) — overwrite read-only files",
    "CVE-2022-0185": "kernel < 5.16.2 — heap overflow in file system context",
    "CVE-2024-21626": "runc < 1.1.12 — leaked file descriptor escape",
}


class ContainerEscapeProbePlugin(BasePlugin):
    meta: ClassVar[PluginMeta] = PluginMeta(
        name="container_escape_probe",
        display_name="Container Escape Probe",
        category=PluginCategory.EXPLOITATION,
        description="Probe container escape vectors via API and config analysis",
        depends_on=["container_config_audit"],
        produces=["container_escapes"],
        timeout=30.0,
        requires_http=False,
        risk_level="destructive",
    )

    async def run(self, target: Target, ctx) -> PluginResult:
        findings: list[Finding] = []
        escapes: list[dict] = []

        containers = self._collect_containers(target.host, ctx)
        api_url = self._get_api_url(target.host, ctx)

        if not containers and not api_url:
            return PluginResult.success(
                self.meta.name, target.host,
                findings=[Finding.info("No containers to probe", tags=["container"])],
                data={"container_escapes": []},
            )

        # Check each container for escape vectors
        for container in containers:
            cid = container.get("id", "?")[:12]
            names = container.get("names", [cid])
            name = names[0] if names else cid

            # Docker socket mount escape
            mounts = container.get("mounts", [])
            for mount in mounts:
                mount_path = mount if isinstance(mount, str) else mount.get("Source", "")
                if "docker.sock" in mount_path:
                    escapes.append({
                        "container": name, "vector": "docker_socket",
                        "severity": "critical",
                    })
                    findings.append(Finding.critical(
                        f"Docker socket escape: {name}",
                        evidence=(
                            f"Container {cid} mounts docker.sock at {mount_path}. "
                            "Can create privileged containers on host."
                        ),
                        description=(
                            "Mount docker.sock into container = full host control. "
                            "Attacker can spawn privileged containers."
                        ),
                        tags=["container", "escape", "socket"],
                        confidence=0.5,
                    ))

            # CAP_SYS_ADMIN escape
            caps = container.get("capabilities", [])
            if "CAP_SYS_ADMIN" in caps or "SYS_ADMIN" in caps:
                escapes.append({
                    "container": name, "vector": "cap_sys_admin",
                    "severity": "critical",
                })
                findings.append(Finding.critical(
                    f"CAP_SYS_ADMIN escape vector: {name}",
                    evidence=(
                        f"Container {cid} has CAP_SYS_ADMIN. "
                        "Can mount host filesystem via cgroup release_agent."
                    ),
                    tags=["container", "escape", "capabilities"],
                    confidence=0.5,
                ))

            # Privileged mode escape
            if container.get("privileged"):
                escapes.append({
                    "container": name, "vector": "privileged",
                    "severity": "critical",
                })
                findings.append(Finding.critical(
                    f"Privileged mode escape: {name}",
                    evidence=f"Container {cid} runs privileged — all devices accessible",
                    description="Privileged containers can access host devices and filesystems",
                    tags=["container", "escape", "privileged"],
                    confidence=0.5,
                ))

            # Host PID namespace
            if container.get("pid_mode") == "host":
                escapes.append({
                    "container": name, "vector": "host_pid",
                    "severity": "high",
                })
                findings.append(Finding.high(
                    f"Host PID escape vector: {name}",
                    evidence=f"Container {cid} shares host PID namespace",
                    description="Can ptrace host processes or read /proc/1/environ",
                    tags=["container", "escape", "pid"],
                    confidence=0.5,
                ))

        # Check runtime version for known CVEs via API
        if api_url:
            await self._check_runtime_cves(ctx, api_url, findings, escapes)

        # Check for Kubernetes service tokens in containers
        self._check_k8s_token(containers, findings, escapes)

        if not findings:
            findings.append(Finding.info(
                "No container escape vectors detected", tags=["container", "escape"],
            ))

        return PluginResult.success(
            self.meta.name, target.host,
            findings=findings,
            data={"container_escapes": escapes},
        )

    async def _check_runtime_cves(
        self, ctx, api_url: str, findings: list[Finding], escapes: list[dict],
    ) -> None:
        """Check runtime version against known escape CVEs."""
        try:
            async with ctx.rate:
                resp = await ctx.http.get(api_url + "/version", timeout=5.0)
                if resp.status != 200:
                    return
                body = await resp.text(encoding="utf-8", errors="replace")
                data = json.loads(body)
                kernel = data.get("KernelVersion", "")
                go_version = data.get("GoVersion", "")

                # Check for Dirty Pipe (kernel 5.8 - 5.16.10)
                if kernel:
                    findings.append(Finding.info(
                        f"Docker host kernel: {kernel}",
                        evidence=f"Kernel: {kernel}, Go: {go_version}",
                        tags=["container", "kernel"],
                    ))

        except Exception:
            logger.debug("Runtime CVE check failed for %s", api_url)

    def _check_k8s_token(
        self, containers: list[dict], findings: list[Finding], escapes: list[dict],
    ) -> None:
        """Check for Kubernetes service account token mounts."""
        for container in containers:
            mounts = container.get("mounts", [])
            for mount in mounts:
                mount_path = mount if isinstance(mount, str) else mount.get("Source", "")
                if "serviceaccount" in mount_path or "kubernetes.io" in mount_path:
                    cid = container.get("id", "?")[:12]
                    name = container.get("names", [cid])
                    name = name[0] if isinstance(name, list) and name else str(name)
                    escapes.append({
                        "container": name, "vector": "k8s_token",
                        "severity": "high",
                    })
                    findings.append(Finding.high(
                        f"Kubernetes token mounted: {name}",
                        evidence=f"Container {cid} has service account token at {mount_path}",
                        description="Service account token can be used to access K8s API",
                        tags=["container", "escape", "kubernetes"],
                        confidence=0.5,
                    ))
                    break

    def _collect_containers(self, host: str, ctx) -> list[dict]:
        """Collect container data from state and pipeline."""
        containers = ctx.state.get("containers", {}).get(host, [])
        if containers:
            return containers

        enum_key = f"container_enumeration:{host}"
        enum_result = ctx.pipeline.get(enum_key)
        if enum_result and enum_result.ok:
            return enum_result.data.get("containers", [])

        return []

    def _get_api_url(self, host: str, ctx) -> str:
        """Find Docker API URL from state or pipeline."""
        runtimes = ctx.state.get("container_runtimes", {}).get(host, [])
        for rt in runtimes:
            if isinstance(rt, dict) and rt.get("api_url"):
                return rt["api_url"]
        return ""
