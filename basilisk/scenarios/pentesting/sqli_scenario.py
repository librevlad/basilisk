"""SQL Injection scenario â€” native v4 implementation."""

from __future__ import annotations

import re
from typing import Any, ClassVar

from basilisk.domain.finding import Finding, Proof
from basilisk.domain.scenario import Scenario, ScenarioMeta, ScenarioResult
from basilisk.domain.surface import SearchSurface, Surface
from basilisk.domain.target import BaseTarget

# Error patterns indicating SQL injection
_SQL_ERRORS = [
    (r"you have an error in your sql syntax", "MySQL"),
    (r"warning.*mysql_", "MySQL"),
    (r"unclosed quotation mark", "MSSQL"),
    (r"microsoft ole db provider for sql server", "MSSQL"),
    (r"pg_query\(\).*failed", "PostgreSQL"),
    (r"unterminated quoted string", "PostgreSQL"),
    (r"sqlite3\.operationalerror", "SQLite"),
    (r"near \".*\": syntax error", "SQLite"),
    (r"ora-\d{5}", "Oracle"),
    (r"quoted string not properly terminated", "Oracle"),
]

_SQLI_PAYLOADS = [
    "'",
    "' OR '1'='1",
    "1 OR 1=1--",
    "' UNION SELECT NULL--",
    "1' AND SLEEP(0)--",
    "'; WAITFOR DELAY '0:0:0'--",
]


class SqliScenario(Scenario):
    """Detects SQL injection via error-based and boolean-based techniques."""

    meta: ClassVar[ScenarioMeta] = ScenarioMeta(
        name="sqli_scenario",
        display_name="SQL Injection (v4)",
        category="pentesting",
        description="Detects SQL injection via error-based and boolean-based techniques",
        target_surfaces=["search", "login", "generic"],
        produces=["sqli_findings"],
        timeout=120.0,
        risk_level="noisy",
        requires_knowledge=["Host", "Service:http", "Endpoint:params"],
        produces_knowledge=["Finding", "Vulnerability"],
        cost_score=5.0,
        noise_score=6.0,
    )

    async def run(
        self,
        target: BaseTarget,
        actor: Any,
        surfaces: list[Surface],
        tools: dict[str, Any],
    ) -> ScenarioResult:
        findings: list[Finding] = []
        data: dict[str, Any] = {"sqli_tests": []}
        tested: set[str] = set()

        base_url = target.base_url
        if not base_url or base_url.startswith(("http://", "https://")) is False:
            base_url = f"http://{target.host}"

        # Collect testable surfaces
        test_surfaces = surfaces or self._default_surfaces(target)

        for surface in test_surfaces:
            if actor.should_stop:
                break

            for param_name, _param_value in surface.params.items():
                key = f"{surface.method}:{surface.url}:{param_name}"
                if key in tested:
                    continue
                tested.add(key)

                for payload in _SQLI_PAYLOADS:
                    if actor.should_stop:
                        break

                    test_params = dict(surface.params)
                    test_params[param_name] = payload

                    try:
                        if surface.method == "POST":
                            resp = await actor.http_post(
                                surface.url or base_url,
                                data=test_params,
                                timeout=10,
                            )
                        else:
                            url = surface.url or base_url
                            qs = "&".join(f"{k}={v}" for k, v in test_params.items())
                            resp = await actor.http_get(f"{url}?{qs}", timeout=10)
                    except Exception:
                        continue

                    body = resp.text.lower()
                    data["sqli_tests"].append({
                        "param": param_name, "payload": payload, "status": resp.status,
                    })

                    # Check for SQL error patterns
                    for pattern, dbms in _SQL_ERRORS:
                        if re.search(pattern, body):
                            findings.append(Finding.critical(
                                f"SQL Injection in {param_name} ({dbms})",
                                proof=Proof(
                                    description=f"Error-based SQLi: {pattern}",
                                    payload_used=payload,
                                    raw_request=f"{surface.method} {surface.url}"
                                    f"?{param_name}={payload}",
                                    raw_response=resp.text[:500],
                                ),
                                host=target.host,
                                endpoint=surface.url or "",
                                scenario_name=self.meta.name,
                                confidence=0.9,
                                tags=frozenset({"sqli", "error-based", dbms.lower()}),
                            ))
                            break
                    else:
                        continue
                    break  # Found SQLi for this param, move to next

        return ScenarioResult(
            scenario=self.meta.name,
            target=target.host,
            findings=findings,
            data=data,
            status="success",
        )

    @staticmethod
    def _default_surfaces(target: BaseTarget) -> list[Surface]:
        """Generate default test surfaces if none provided."""
        base = target.base_url
        return [
            SearchSurface(
                host=target.host, url=f"{base}/search",
                params={"q": "test"}, query_param="q",
            ),
            Surface(
                host=target.host, url=f"{base}/",
                params={"id": "1"},
            ),
        ]
