"""Tests for ExploitChainEngine."""

from __future__ import annotations

from basilisk.core.exploit_chain import (
    ChainStep,
    ExploitChain,
    ExploitChainEngine,
)
from basilisk.models.result import PluginResult, Severity


class TestChainStep:
    def test_create_step(self):
        step = ChainStep(
            name="SQLi Detection",
            description="Found SQL injection",
            source_plugin="sqli_basic",
        )
        assert step.name == "SQLi Detection"
        assert step.success is False  # Default is False
        assert step.evidence == ""

    def test_step_with_data(self):
        step = ChainStep(
            name="Data Extraction",
            description="Extracted user table",
            source_plugin="sqli_advanced",
            evidence="user table: admin, password_hash",
            data={"tables": ["users"]},
        )
        assert step.data == {"tables": ["users"]}


class TestExploitChain:
    def test_create_chain(self):
        chain = ExploitChain(
            chain_id="test-1",
            name="SQLi → Data Extract",
            description="Full SQLi exploitation chain",
            target="example.com",
        )
        assert chain.chain_id == "test-1"
        assert len(chain.steps) == 0
        assert not chain.completed

    def test_add_step(self):
        chain = ExploitChain(
            chain_id="test-2",
            name="Test Chain",
            description="Test",
            target="example.com",
        )
        step = ChainStep(
            name="Step 1",
            description="First step",
            source_plugin="plugin_a",
        )
        chain.add_step(step)
        assert len(chain.steps) == 1

    def test_to_finding(self):
        chain = ExploitChain(
            chain_id="test-3",
            name="XSS → Session Hijack",
            description="XSS chain",
            target="example.com",
            severity=Severity.HIGH,
            completed=True,
        )
        chain.add_step(ChainStep(
            name="XSS Found",
            description="Reflected XSS",
            source_plugin="xss_basic",
        ))
        chain.add_step(ChainStep(
            name="Session Cookies Accessible",
            description="Cookies not HttpOnly",
            source_plugin="cookie_scan",
        ))

        finding = chain.to_finding()
        assert finding.severity == Severity.HIGH
        assert "XSS → Session Hijack" in finding.title
        assert "2 steps" in finding.description


class TestExploitChainEngine:
    def test_engine_creation(self):
        engine = ExploitChainEngine()
        assert engine is not None

    def test_analyze_empty_pipeline(self):
        engine = ExploitChainEngine()

        class FakePipeline(dict):
            def get(self, key, default=None):
                return super().get(key, default)

        chains = engine.analyze(FakePipeline(), "example.com")
        assert isinstance(chains, list)
        # No data → no chains
        assert len(chains) == 0

    def test_chains_property(self):
        engine = ExploitChainEngine()
        assert engine.chains == []

    def test_sqli_extract_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "sqli_basic:example.com": PluginResult.success(
                "sqli_basic", "example.com",
                data={"sqli_tests": [{"dbms": "mysql", "payload": "' OR 1=1--"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        assert len(chains) == 1
        assert chains[0].chain_id == "sqli_extract"
        assert chains[0].severity == Severity.CRITICAL
        assert chains[0].completed

    def test_sqli_extract_with_advanced_data(self):
        engine = ExploitChainEngine()
        pipeline = {
            "sqli_basic:example.com": PluginResult.success(
                "sqli_basic", "example.com",
                data={"sqli_tests": [{"dbms": "mysql", "payload": "test"}]},
            ),
            "sqli_advanced:example.com": PluginResult.success(
                "sqli_advanced", "example.com",
                data={"extracted": {"password_hash": "abc123", "username": "admin"}},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        assert len(chains) == 1
        chain = chains[0]
        # Should have 3 steps: confirmed, extraction, credential discovery
        assert len(chain.steps) == 3
        assert chain.steps[2].name == "Credential Discovery"

    def test_sqli_no_tests_no_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "sqli_basic:example.com": PluginResult.success(
                "sqli_basic", "example.com",
                data={"sqli_tests": []},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        assert len(chains) == 0

    def test_ssrf_cloud_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssrf_check:example.com": PluginResult.success(
                "ssrf_check", "example.com",
                data={"ssrf_tests": [{"confirmed": True, "payload": "http://169.254.169.254"}]},
            ),
            "cloud_metadata_ssrf:example.com": PluginResult.success(
                "cloud_metadata_ssrf", "example.com",
                data={
                    "cloud_metadata": {"role": "admin"},
                    "cloud_provider": "aws",
                    "credentials_found": ["AKIAxxxx"],
                },
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        ssrf_chains = [c for c in chains if c.chain_id == "ssrf_cloud"]
        assert len(ssrf_chains) == 1
        assert len(ssrf_chains[0].steps) == 3  # SSRF + metadata + creds

    def test_ssrf_cloud_no_confirmed(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssrf_check:example.com": PluginResult.success(
                "ssrf_check", "example.com",
                data={"ssrf_tests": [{"confirmed": False}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        ssrf_chains = [c for c in chains if c.chain_id == "ssrf_cloud"]
        assert len(ssrf_chains) == 0

    def test_ssrf_internal_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssrf_advanced:example.com": PluginResult.success(
                "ssrf_advanced", "example.com",
                data={"internal_ports": [6379, 3306, 8080]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        internal_chains = [c for c in chains if c.chain_id == "ssrf_internal"]
        assert len(internal_chains) == 1
        chain = internal_chains[0]
        assert chain.severity == Severity.CRITICAL  # Has sensitive ports
        assert len(chain.steps) == 2

    def test_ssrf_internal_no_sensitive_ports(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssrf_advanced:example.com": PluginResult.success(
                "ssrf_advanced", "example.com",
                data={"internal_ports": [12345]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        internal_chains = [c for c in chains if c.chain_id == "ssrf_internal"]
        assert len(internal_chains) == 1
        assert internal_chains[0].severity == Severity.HIGH  # No sensitive ports

    def test_ssti_rce_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssti_check:example.com": PluginResult.success(
                "ssti_check", "example.com",
                data={"ssti_tests": [{"confirmed": True, "engine": "jinja2"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        ssti_chains = [c for c in chains if c.chain_id == "ssti_rce"]
        assert len(ssti_chains) == 1
        assert ssti_chains[0].steps[1].success  # jinja2 supports RCE

    def test_ssti_rce_verify_fallback(self):
        engine = ExploitChainEngine()
        pipeline = {
            "ssti_verify:example.com": PluginResult.success(
                "ssti_verify", "example.com",
                data={"ssti_tests": [{"verdict": "confirmed", "engine": "unknown"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        ssti_chains = [c for c in chains if c.chain_id == "ssti_rce"]
        assert len(ssti_chains) == 1
        assert not ssti_chains[0].steps[1].success  # unknown engine

    def test_xss_session_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "xss_basic:example.com": PluginResult.success(
                "xss_basic", "example.com",
                data={"xss_tests": [{"reflected": True, "param": "q"}]},
            ),
            "cookie_scan:example.com": PluginResult.success(
                "cookie_scan", "example.com",
                data={"insecure_cookies": [{"name": "session", "httponly": False}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        xss_chains = [c for c in chains if c.chain_id == "xss_session"]
        assert len(xss_chains) == 1
        assert xss_chains[0].severity == Severity.CRITICAL

    def test_xss_session_no_reflected(self):
        engine = ExploitChainEngine()
        pipeline = {
            "xss_basic:example.com": PluginResult.success(
                "xss_basic", "example.com",
                data={"xss_tests": [{"reflected": False}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        xss_chains = [c for c in chains if c.chain_id == "xss_session"]
        assert len(xss_chains) == 0

    def test_xss_advanced_fallback(self):
        engine = ExploitChainEngine()
        pipeline = {
            "xss_advanced:example.com": PluginResult.success(
                "xss_advanced", "example.com",
                data={"xss_tests": [{"reflected": True, "param": "search"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        xss_chains = [c for c in chains if c.chain_id == "xss_session"]
        assert len(xss_chains) == 1

    def test_lfi_rce_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "lfi_check:example.com": PluginResult.success(
                "lfi_check", "example.com",
                data={"lfi_tests": [{"payload": "../../etc/passwd"}]},
            ),
            "tech_detect:example.com": PluginResult.success(
                "tech_detect", "example.com",
                data={"technologies": ["PHP", "Apache"]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        lfi_chains = [c for c in chains if c.chain_id == "lfi_rce"]
        assert len(lfi_chains) == 1
        assert len(lfi_chains[0].steps) == 2  # LFI + PHP wrapper

    def test_lfi_rce_no_php(self):
        engine = ExploitChainEngine()
        pipeline = {
            "lfi_check:example.com": PluginResult.success(
                "lfi_check", "example.com",
                data={"lfi_tests": [{"payload": "../../etc/passwd"}]},
            ),
            "tech_detect:example.com": PluginResult.success(
                "tech_detect", "example.com",
                data={"technologies": ["Python", "Nginx"]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        lfi_chains = [c for c in chains if c.chain_id == "lfi_rce"]
        assert len(lfi_chains) == 1
        assert len(lfi_chains[0].steps) == 1  # Only LFI, no PHP

    def test_cred_reuse_chain(self):
        engine = ExploitChainEngine()
        pipeline = {
            "default_creds:example.com": PluginResult.success(
                "default_creds", "example.com",
                data={"found_creds": [{"user": "admin", "pass": "admin"}]},
            ),
            "admin_finder:example.com": PluginResult.success(
                "admin_finder", "example.com",
                data={"admin_panels": ["/admin", "/wp-admin"]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        cred_chains = [c for c in chains if c.chain_id == "cred_reuse"]
        assert len(cred_chains) == 1
        assert len(cred_chains[0].steps) == 2

    def test_cred_reuse_no_admin_panel(self):
        engine = ExploitChainEngine()
        pipeline = {
            "default_creds:example.com": PluginResult.success(
                "default_creds", "example.com",
                data={"found_creds": [{"user": "admin", "pass": "admin"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        cred_chains = [c for c in chains if c.chain_id == "cred_reuse"]
        assert len(cred_chains) == 1
        assert len(cred_chains[0].steps) == 1

    def test_multiple_chains(self):
        """Multiple chains can be detected from the same pipeline."""
        engine = ExploitChainEngine()
        pipeline = {
            "sqli_basic:example.com": PluginResult.success(
                "sqli_basic", "example.com",
                data={"sqli_tests": [{"dbms": "mysql", "payload": "test"}]},
            ),
            "lfi_check:example.com": PluginResult.success(
                "lfi_check", "example.com",
                data={"lfi_tests": [{"payload": "../../etc/passwd"}]},
            ),
        }
        chains = engine.analyze(pipeline, "example.com")
        chain_ids = {c.chain_id for c in chains}
        assert "sqli_extract" in chain_ids
        assert "lfi_rce" in chain_ids
