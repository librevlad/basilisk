"""Tests for pentesting plugins — new batch 1."""

from unittest.mock import AsyncMock, MagicMock

from basilisk.models.target import Target


def _make_inline_scheme_ctx(mock_ctx):
    """Setup mock_ctx for plugins using inline https->http scheme detection."""
    mock_head = MagicMock()
    mock_head.status = 200
    mock_ctx.http.head = AsyncMock(return_value=mock_head)
    mock_resp = MagicMock()
    mock_resp.status = 200
    mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
    mock_resp.headers = {"Content-Type": "text/html"}
    mock_ctx.http.get = AsyncMock(return_value=mock_resp)
    mock_ctx.http.post = AsyncMock(return_value=mock_resp)
    return mock_ctx


# ── 1. SSRF Check ─────────────────────────────────────────────────────


class TestSsrfCheck:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_check import SsrfCheckPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = SsrfCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_ssrf_found(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_check import SsrfCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {"example.com": "https"}

        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.head = AsyncMock(return_value=mock_resp)

        plugin = SsrfCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No SSRF" in f.title for f in result.findings)

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_check import SsrfCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = SsrfCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 2. WordPress Scan ──────────────────────────────────────────────────


class TestWordpressScan:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.wordpress_scan import WordPressScanPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = WordPressScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_not_wordpress(self, mock_ctx):
        from basilisk.plugins.pentesting.wordpress_scan import WordPressScanPlugin

        target = Target.domain("example.com")

        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html><body>Not WordPress</body></html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = WordPressScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert result.data.get("is_wordpress") is False
        assert any("Not a WordPress" in f.title for f in result.findings)

    async def test_wordpress_detected(self, mock_ctx):
        from basilisk.plugins.pentesting.wordpress_scan import WordPressScanPlugin

        target = Target.domain("example.com")

        async def fake_get(url, **kwargs):
            resp = MagicMock()
            if url.rstrip("/") in (
                "https://example.com", "http://example.com",
            ):
                resp.status = 200
                resp.text = AsyncMock(
                    return_value=(
                        '<html><head><meta name="generator" '
                        'content="WordPress 6.4.2"/></head>'
                        '<link rel="stylesheet" href="/wp-content/themes/style.css"/>'
                        "</html>"
                    )
                )
            elif "/xmlrpc.php" in url:
                resp.status = 200
                resp.text = AsyncMock(return_value="XML-RPC server accepts POST requests only.")
            else:
                resp.status = 404
                resp.text = AsyncMock(return_value="Not found")
            return resp

        mock_ctx.http.get = fake_get

        plugin = WordPressScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert result.data.get("is_wordpress") is True
        assert result.data.get("version") == "6.4.2"


# ── 3. NoSQL Injection Check ──────────────────────────────────────────


class TestNosqliCheck:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_check import NosqliCheckPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = NosqliCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_nosqli_found(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_check import NosqliCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {"example.com": "https"}

        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)

        plugin = NosqliCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No NoSQL" in f.title for f in result.findings)

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_check import NosqliCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = NosqliCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 4. Path Traversal ─────────────────────────────────────────────────


class TestPathTraversal:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.path_traversal import PathTraversalPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = PathTraversalPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_traversal_found(self, mock_ctx):
        from basilisk.plugins.pentesting.path_traversal import PathTraversalPlugin

        target = Target.domain("example.com")
        _make_inline_scheme_ctx(mock_ctx)

        plugin = PathTraversalPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No path traversal" in f.title for f in result.findings
        )

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.path_traversal import PathTraversalPlugin

        target = Target.domain("example.com")
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = PathTraversalPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 5. IDOR Check ─────────────────────────────────────────────────────


class TestIdorCheck:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.idor_check import IdorCheckPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = IdorCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_idor_found(self, mock_ctx):
        from basilisk.plugins.pentesting.idor_check import IdorCheckPlugin

        target = Target.domain("example.com")

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        # All API endpoints return 404
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="<html>Not Found</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = IdorCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No IDOR" in f.title for f in result.findings)

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.idor_check import IdorCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = IdorCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 6. Port Vulnerability Check ───────────────────────────────────────


class TestPortVulnCheck:
    async def test_no_open_ports(self, mock_ctx):
        from basilisk.plugins.pentesting.port_vuln_check import PortVulnCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}

        plugin = PortVulnCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No open ports" in f.title for f in result.findings)

    async def test_no_vulns_on_ports(self, mock_ctx):
        from basilisk.plugins.pentesting.port_vuln_check import PortVulnCheckPlugin

        target = Target.domain("example.com")

        port_result = MagicMock()
        port_result.ok = True
        port_result.data = {"open_ports": [{"port": 12345, "service": "unknown"}]}

        svc_result = MagicMock()
        svc_result.ok = True
        svc_result.data = {
            "services": [{"port": 12345, "service": "custom", "banner": "MyApp/1.0"}],
        }

        mock_ctx.pipeline = {
            f"port_scan:{target.host}": port_result,
            f"service_detect:{target.host}": svc_result,
        }

        plugin = PortVulnCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No known vulnerabilities" in f.title for f in result.findings)

    async def test_banner_match_openssh(self, mock_ctx):
        from basilisk.plugins.pentesting.port_vuln_check import PortVulnCheckPlugin

        target = Target.domain("example.com")

        port_result = MagicMock()
        port_result.ok = True
        port_result.data = {"open_ports": [{"port": 22, "service": "ssh"}]}

        svc_result = MagicMock()
        svc_result.ok = True
        svc_result.data = {
            "services": [{"port": 22, "service": "ssh", "banner": "OpenSSH 8.2"}],
        }

        mock_ctx.pipeline = {
            f"port_scan:{target.host}": port_result,
            f"service_detect:{target.host}": svc_result,
        }

        plugin = PortVulnCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("OpenSSH" in f.title for f in result.findings)


# ── 7. Subdomain Takeover Active ──────────────────────────────────────


class TestSubdomainTakeoverActive:
    async def test_no_dns(self, mock_ctx):
        from basilisk.plugins.pentesting.subdomain_takeover_active import (
            SubdomainTakeoverActivePlugin,
        )

        mock_ctx.dns = None
        target = Target.domain("example.com")
        plugin = SubdomainTakeoverActivePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.subdomain_takeover_active import (
            SubdomainTakeoverActivePlugin,
        )

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = SubdomainTakeoverActivePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_takeover(self, mock_ctx):
        from basilisk.plugins.pentesting.subdomain_takeover_active import (
            SubdomainTakeoverActivePlugin,
        )

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}

        # CNAME resolution returns nothing
        mock_ctx.dns.resolve = AsyncMock(return_value=[])

        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = SubdomainTakeoverActivePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No subdomain takeover" in f.title for f in result.findings
        )

    async def test_dangling_cname_detected(self, mock_ctx):
        from basilisk.plugins.pentesting.subdomain_takeover_active import (
            SubdomainTakeoverActivePlugin,
        )

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}

        # CNAME resolves to github.io (known service)
        cname_record = MagicMock()
        cname_record.value = "myapp.github.io"

        async def fake_dns_resolve(host, rtype="A"):
            if rtype == "CNAME":
                return [cname_record]
            # A/AAAA return empty (NXDOMAIN)
            return []

        mock_ctx.dns.resolve = fake_dns_resolve

        # HTTP fetch returns GitHub Pages takeover signature
        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(
            return_value="There isn't a GitHub Pages site here."
        )
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = SubdomainTakeoverActivePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("takeover" in f.title.lower() for f in result.findings)


# ── 8. Service Brute ──────────────────────────────────────────────────


class TestServiceBrute:
    async def test_no_open_ports(self, mock_ctx):
        from basilisk.plugins.pentesting.service_brute import ServiceBrutePlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}

        plugin = ServiceBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No open ports" in f.title for f in result.findings)

    async def test_no_matching_service(self, mock_ctx):
        from basilisk.plugins.pentesting.service_brute import ServiceBrutePlugin

        target = Target.domain("example.com")

        port_result = MagicMock()
        port_result.ok = True
        # Open port that doesn't match any known service
        port_result.data = {"open_ports": [{"port": 12345}]}

        mock_ctx.pipeline = {f"port_scan:{target.host}": port_result}

        plugin = ServiceBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No default credentials" in f.title for f in result.findings
        )

    async def test_elasticsearch_open_port(self, mock_ctx):
        from basilisk.plugins.pentesting.service_brute import ServiceBrutePlugin

        target = Target.domain("example.com")

        port_result = MagicMock()
        port_result.ok = True
        port_result.data = {"open_ports": [{"port": 9200}]}

        mock_ctx.pipeline = {f"port_scan:{target.host}": port_result}

        # Elasticsearch responds without auth
        es_resp = MagicMock()
        es_resp.status = 200
        es_resp.text = AsyncMock(
            return_value='{"cluster_name": "test", "version": {"number": "7.10.0"}}'
        )
        mock_ctx.http.get = AsyncMock(return_value=es_resp)

        plugin = ServiceBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        brute_results = result.data.get("brute_results", [])
        es_results = [r for r in brute_results if r.get("service") == "elasticsearch"]
        assert len(es_results) > 0
        assert es_results[0].get("no_auth") is True


# ── 9. Email Spoofing ─────────────────────────────────────────────────


class TestEmailSpoofing:
    async def test_no_dns(self, mock_ctx):
        from basilisk.plugins.pentesting.email_spoofing import EmailSpoofingPlugin

        mock_ctx.dns = None
        target = Target.domain("example.com")
        plugin = EmailSpoofingPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_spf_no_dmarc(self, mock_ctx):
        from basilisk.plugins.pentesting.email_spoofing import EmailSpoofingPlugin

        target = Target.domain("example.com")
        mock_ctx.dns.resolve = AsyncMock(return_value=[])

        plugin = EmailSpoofingPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        titles = [f.title for f in result.findings]
        assert any("No SPF" in t for t in titles)
        assert any("No DMARC" in t for t in titles)
        assert any("No DKIM" in t for t in titles)

    async def test_strict_spf_reject_dmarc(self, mock_ctx):
        from basilisk.plugins.pentesting.email_spoofing import EmailSpoofingPlugin

        target = Target.domain("example.com")

        spf_record = MagicMock()
        spf_record.value = "v=spf1 include:_spf.google.com -all"

        dmarc_record = MagicMock()
        dmarc_record.value = "v=DMARC1; p=reject; rua=mailto:dmarc@example.com"

        dkim_record = MagicMock()
        dkim_record.value = "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9..."

        async def fake_dns_resolve(host, rtype="A"):
            if rtype == "TXT":
                if host == "example.com":
                    return [spf_record]
                if host == "_dmarc.example.com":
                    return [dmarc_record]
                if "_domainkey." in host:
                    return [dkim_record]
            return []

        mock_ctx.dns.resolve = fake_dns_resolve

        plugin = EmailSpoofingPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        titles = [f.title for f in result.findings]
        assert any("strict" in t.lower() or "-all" in t for t in titles)
        assert any("reject" in t.lower() for t in titles)
        assert any("DKIM found" in t for t in titles)


# ── 10. Admin Brute ───────────────────────────────────────────────────


class TestAdminBrute:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.admin_brute import AdminBrutePlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = AdminBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_login_forms(self, mock_ctx):
        from basilisk.plugins.pentesting.admin_brute import AdminBrutePlugin

        target = Target.domain("example.com")

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        # GET returns pages without forms
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="<html>Not Found</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = AdminBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No default credentials" in f.title for f in result.findings
        )

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.admin_brute import AdminBrutePlugin

        target = Target.domain("example.com")
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = AdminBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 11. Parameter Pollution ───────────────────────────────────────────


class TestParamPollution:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.param_pollution import ParamPollutionPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = ParamPollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_hpp_found(self, mock_ctx):
        from basilisk.plugins.pentesting.param_pollution import ParamPollutionPlugin

        target = Target.domain("example.com")
        _make_inline_scheme_ctx(mock_ctx)

        plugin = ParamPollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No HTTP Parameter Pollution" in f.title for f in result.findings
        )

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.param_pollution import ParamPollutionPlugin

        target = Target.domain("example.com")
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = ParamPollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)


# ── 12. SSTI Verify ──────────────────────────────────────────────────


class TestSstiVerify:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.ssti_verify import SstiVerifyPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = SstiVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_ssti_data(self, mock_ctx):
        from basilisk.plugins.pentesting.ssti_verify import SstiVerifyPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}

        plugin = SstiVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No SSTI findings to verify" in f.title for f in result.findings
        )

    async def test_false_positive_ssti(self, mock_ctx):
        from basilisk.plugins.pentesting.ssti_verify import SstiVerifyPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {
            "http_scheme": {"example.com": "https"},
            "ssti_tests": [
                {
                    "confirmed": True,
                    "page": "/search",
                    "param": "q",
                    "engine": "jinja2/twig",
                },
            ],
        }

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        # Responses never contain evaluated math expressions
        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Safe page with no eval</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = SstiVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "false positive" in f.title.lower() or "false_positive" in f.title.lower()
            for f in result.findings
        )


# ── 13. NoSQLi Verify ────────────────────────────────────────────────


class TestNosqliVerify:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_verify import NosqliVerifyPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = NosqliVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_nosqli_data(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_verify import NosqliVerifyPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}

        plugin = NosqliVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No NoSQL injection findings" in f.title for f in result.findings
        )

    async def test_nosqli_possible(self, mock_ctx):
        from basilisk.plugins.pentesting.nosqli_verify import NosqliVerifyPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {
            "http_scheme": {"example.com": "https"},
            "nosqli_tests": [
                {
                    "page": "/api/search",
                    "method": "GET",
                    "label": "operator_ne",
                },
            ],
        }

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        # Baseline, innocent, and encoded requests all return 200
        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Normal response</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)

        plugin = NosqliVerifyPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        verified = result.data.get("nosqli_verified", [])
        assert len(verified) == 1
        assert verified[0]["verdict"] == "possible"


# ── 14. Default Credentials ──────────────────────────────────────────


class TestDefaultCreds:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.default_creds import DefaultCredsPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = DefaultCredsPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_services_found(self, mock_ctx):
        from basilisk.plugins.pentesting.default_creds import DefaultCredsPlugin

        target = Target.domain("example.com")

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        # All service paths return 404
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not Found")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = DefaultCredsPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any(
            "No default-credential services" in f.title for f in result.findings
        )

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.default_creds import DefaultCredsPlugin

        target = Target.domain("example.com")
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = DefaultCredsPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title.lower() for f in result.findings)

    async def test_service_detected_with_auth(self, mock_ctx):
        from basilisk.plugins.pentesting.default_creds import DefaultCredsPlugin

        target = Target.domain("example.com")

        mock_head = MagicMock()
        mock_head.status = 200
        mock_ctx.http.head = AsyncMock(return_value=mock_head)

        async def fake_get(url, **kwargs):
            resp = MagicMock()
            if "/grafana/" in url:
                resp.status = 401
                resp.text = AsyncMock(return_value="Unauthorized")
            elif "_nonexistent_" in url:
                resp.status = 404
                resp.text = AsyncMock(return_value="Not Found")
            else:
                resp.status = 404
                resp.text = AsyncMock(return_value="Not Found")
            return resp

        mock_ctx.http.get = fake_get

        plugin = DefaultCredsPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        found = result.data.get("services", [])
        grafana_found = [s for s in found if s.get("name") == "Grafana"]
        assert len(grafana_found) == 1
        assert grafana_found[0]["status"] == 401
