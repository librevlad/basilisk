"""Tests for 5 pentesting plugins that lacked functional tests.

Covers: cloud_metadata_ssrf, deserialization_check, sqli_advanced,
ssrf_advanced, xss_advanced.
"""

from __future__ import annotations

from unittest.mock import AsyncMock, MagicMock

from basilisk.models.result import PluginResult
from basilisk.models.target import Target


def _resp(status=200, body="", headers=None):
    r = MagicMock()
    r.status = status
    r.text = AsyncMock(return_value=body)
    hdr = {"Content-Type": "text/html"}
    if headers:
        hdr.update(headers)
    r.headers = hdr
    return r


# ───────────────────────── CloudMetadataSsrf ──────────────────────────


class TestCloudMetadataSsrf:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import (
            CloudMetadataSsrfPlugin,
        )

        mock_ctx.http = None
        target = Target.domain("example.com")
        result = await CloudMetadataSsrfPlugin().run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_ssrf_endpoints_no_reachable(self, mock_ctx):
        """No SSRF pipeline data and host unreachable → info finding."""
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import (
            CloudMetadataSsrfPlugin,
        )

        mock_ctx.pipeline = {}
        mock_ctx.http.head = AsyncMock(side_effect=Exception("unreachable"))
        target = Target.domain("example.com")
        result = await CloudMetadataSsrfPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("No cloud metadata" in f.title for f in result.findings)

    async def test_confirmed_ssrf_extracts_metadata(self, mock_ctx):
        """Confirmed SSRF endpoint returns cloud metadata → critical finding."""
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import (
            CloudMetadataSsrfPlugin,
        )

        ssrf_result = PluginResult.success(
            "ssrf_check", "example.com",
            findings=[], data={
                "ssrf_endpoints": [
                    {"url": "https://example.com/fetch", "param": "url"},
                ],
            },
        )
        cloud_result = PluginResult.success(
            "cloud_detect", "example.com",
            findings=[], data={"providers": ["AWS"]},
        )
        mock_ctx.pipeline = {
            "ssrf_check:example.com": ssrf_result,
            "cloud_detect:example.com": cloud_result,
        }

        # Return metadata-looking content for SSRF-forwarded requests
        body = '{"ami-id": "ami-12345", "instance-id": "i-abc"}'
        mock_ctx.http.get = AsyncMock(return_value=_resp(200, body))

        target = Target.domain("example.com")
        result = await CloudMetadataSsrfPlugin().run(target, mock_ctx)
        assert result.ok
        assert any(f.severity.value >= 3 for f in result.findings)  # HIGH+

    async def test_select_metadata_targets_aws(self):
        """Provider selection returns AWS paths when AWS detected."""
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import (
            CloudMetadataSsrfPlugin,
        )

        targets = CloudMetadataSsrfPlugin._select_metadata_targets(["AWS"])
        assert any("169.254" in t[0] for t in targets)

    async def test_select_metadata_targets_no_provider(self):
        """No provider → returns subset of all cloud paths."""
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import (
            CloudMetadataSsrfPlugin,
        )

        targets = CloudMetadataSsrfPlugin._select_metadata_targets([])
        assert len(targets) > 0


# ──────────────────────── DeserializationCheck ────────────────────────


class TestDeserializationCheck:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.deserialization_check import (
            DeserializationCheckPlugin,
        )

        mock_ctx.http = None
        target = Target.domain("example.com")
        result = await DeserializationCheckPlugin().run(target, mock_ctx)
        assert result.status == "error"

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.deserialization_check import (
            DeserializationCheckPlugin,
        )

        # resolve_base_url returns None when scheme cache says None
        mock_ctx.state["http_scheme"] = {"example.com": None}
        target = Target.domain("example.com")
        result = await DeserializationCheckPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title for f in result.findings)

    async def test_serialized_data_detected_in_body(self, mock_ctx):
        """Java serialized marker in response body → medium finding."""
        from basilisk.plugins.pentesting.deserialization_check import (
            DeserializationCheckPlugin,
        )

        body = '<html><input name="javax.faces.ViewState" value="rO0ABXNyABFqYXZh"/></html>'
        mock_ctx.http.get = AsyncMock(return_value=_resp(200, body))
        mock_ctx.http.post = AsyncMock(return_value=_resp(200, "ok"))

        target = Target.domain("example.com")
        result = await DeserializationCheckPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("Serialized data" in f.title or "Java" in f.title for f in result.findings)

    async def test_no_deserialization_found(self, mock_ctx):
        from basilisk.plugins.pentesting.deserialization_check import (
            DeserializationCheckPlugin,
        )

        mock_ctx.http.get = AsyncMock(return_value=_resp(200, "<html>Safe</html>"))
        mock_ctx.http.post = AsyncMock(return_value=_resp(200, "ok"))

        target = Target.domain("example.com")
        result = await DeserializationCheckPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("No deserialization" in f.title for f in result.findings)


# ─────────────────────────── SqliAdvanced ─────────────────────────────


class TestSqliAdvanced:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.sqli_advanced import SqliAdvancedPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        result = await SqliAdvancedPlugin().run(target, mock_ctx)
        assert result.status == "error"

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.sqli_advanced import SqliAdvancedPlugin

        mock_ctx.state["http_scheme"] = {"example.com": None}
        target = Target.domain("example.com")
        result = await SqliAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title for f in result.findings)

    async def test_no_sqli_detected(self, mock_ctx):
        from basilisk.plugins.pentesting.sqli_advanced import SqliAdvancedPlugin

        mock_ctx.http.get = AsyncMock(return_value=_resp(200, "<html>Safe</html>"))
        mock_ctx.waf_bypass = None

        target = Target.domain("example.com")
        result = await SqliAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("No SQL injection" in f.title for f in result.findings)

    async def test_dbms_fingerprint_mysql(self, mock_ctx):
        """MySQL error in response → DBMS fingerprinted info finding."""
        from basilisk.plugins.pentesting.sqli_advanced import SqliAdvancedPlugin

        def route(url, **kwargs):
            if "EXTRACTVALUE" in url:
                return _resp(200, "XPATH syntax error near MySQL")
            return _resp(200, "<html>Safe</html>")

        mock_ctx.http.get = AsyncMock(side_effect=route)
        mock_ctx.waf_bypass = None

        target = Target.domain("example.com")
        result = await SqliAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        # Should have fingerprinted MySQL
        assert result.data.get("dbms") == "mysql"

    async def test_error_based_sqli_extraction(self, mock_ctx):
        """Error-based SQLi with data extraction → critical finding."""
        from basilisk.plugins.pentesting.sqli_advanced import SqliAdvancedPlugin

        def route(url, **kwargs):
            if "EXTRACTVALUE" in url or "UPDATEXML" in url:
                return _resp(200, "XPATH error: ~5.7.44-mysql~")
            return _resp(200, "<html>Safe</html>")

        mock_ctx.http.get = AsyncMock(side_effect=route)
        mock_ctx.waf_bypass = None

        target = Target.domain("example.com")
        result = await SqliAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any(
            f.severity.value >= 4 and "SQLi" in f.title
            for f in result.findings
        )


# ──────────────────────────── SsrfAdvanced ────────────────────────────


class TestSsrfAdvanced:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_advanced import SsrfAdvancedPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        result = await SsrfAdvancedPlugin().run(target, mock_ctx)
        assert result.status == "error"

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_advanced import SsrfAdvancedPlugin

        mock_ctx.state["http_scheme"] = {"example.com": None}
        target = Target.domain("example.com")
        result = await SsrfAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title for f in result.findings)

    async def test_no_ssrf_detected(self, mock_ctx):
        from basilisk.plugins.pentesting.ssrf_advanced import SsrfAdvancedPlugin

        mock_ctx.pipeline = {}
        mock_ctx.http.get = AsyncMock(return_value=_resp(200, "<html>Safe</html>"))
        mock_ctx.callback = None
        mock_ctx.waf_bypass = None

        target = Target.domain("example.com")
        result = await SsrfAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("No advanced SSRF" in f.title for f in result.findings)

    async def test_cloud_metadata_via_confirmed_ssrf(self, mock_ctx):
        """Confirmed SSRF fetches AWS metadata → critical finding."""
        from basilisk.plugins.pentesting.ssrf_advanced import SsrfAdvancedPlugin

        ssrf_result = PluginResult.success(
            "ssrf_check", "example.com",
            findings=[], data={
                "ssrf_tests": [
                    {"page": "/fetch", "param": "url", "confirmed": True},
                ],
            },
        )
        mock_ctx.pipeline = {"ssrf_check:example.com": ssrf_result}

        def route(url, **kwargs):
            if "169.254" in url or "ami-id" in url:
                return _resp(200, '{"ami-id": "ami-12345"}')
            return _resp(200, "<html>Normal</html>")

        mock_ctx.http.get = AsyncMock(side_effect=route)
        mock_ctx.callback = None
        mock_ctx.waf_bypass = None

        target = Target.domain("example.com")
        result = await SsrfAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        # Should have cloud metadata finding
        assert any(
            "cloud metadata" in f.title.lower() or "SSRF" in f.title
            for f in result.findings
            if f.severity.value >= 3
        )


# ─────────────────────────── XssAdvanced ──────────────────────────────


class TestXssAdvanced:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.xss_advanced import XssAdvancedPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        result = await XssAdvancedPlugin().run(target, mock_ctx)
        assert result.status == "error"

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.xss_advanced import XssAdvancedPlugin

        mock_ctx.state["http_scheme"] = {"example.com": None}
        target = Target.domain("example.com")
        result = await XssAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("not reachable" in f.title for f in result.findings)

    async def test_no_xss_detected(self, mock_ctx):
        from basilisk.plugins.pentesting.xss_advanced import XssAdvancedPlugin

        mock_ctx.http.get = AsyncMock(return_value=_resp(200, "<html>Safe</html>"))
        mock_ctx.http.post = AsyncMock(return_value=_resp(200, "ok"))
        mock_ctx.pipeline = {}
        mock_ctx.waf_bypass = None
        mock_ctx.oob = None

        target = Target.domain("example.com")
        result = await XssAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        assert any("No advanced XSS" in f.title for f in result.findings)

    async def test_context_aware_xss_html_tag(self, mock_ctx):
        """Canary reflected in HTML tag context with payload intact → high finding."""
        from basilisk.plugins.pentesting.xss_advanced import (
            CANARY,
            XssAdvancedPlugin,
        )

        def route(url, **kwargs):
            # Probe with canary → reflect in HTML context
            if "bskPROBE" in url and CANARY in url:
                return _resp(200, f"<div>bskPROBE{CANARY}9z</div>")
            # Payload reflected intact with event handler
            if "onerror" in url or "onload" in url:
                return _resp(
                    200,
                    f'<div><img src=x onerror=alert({CANARY})></div>',
                )
            return _resp(200, "<html>Safe</html>")

        mock_ctx.http.get = AsyncMock(side_effect=route)
        mock_ctx.http.post = AsyncMock(return_value=_resp(200, "ok"))
        mock_ctx.pipeline = {}
        mock_ctx.waf_bypass = None
        mock_ctx.oob = None

        target = Target.domain("example.com")
        result = await XssAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        xss_findings = [
            f for f in result.findings
            if f.severity.value >= 3 and "XSS" in f.title
        ]
        assert len(xss_findings) >= 1

    async def test_dom_xss_detection(self, mock_ctx):
        """Script with source→sink pattern → medium DOM XSS finding."""
        from basilisk.plugins.pentesting.xss_advanced import XssAdvancedPlugin

        body = """<html>
        <script>
        var query = location.hash;
        document.write(query);
        </script></html>"""

        def route(url, **kwargs):
            # Don't reflect canary probes so Phase 1 produces nothing
            return _resp(200, body)

        mock_ctx.http.get = AsyncMock(side_effect=route)
        mock_ctx.http.post = AsyncMock(return_value=_resp(200, "ok"))
        mock_ctx.pipeline = {}
        mock_ctx.waf_bypass = None
        mock_ctx.oob = None

        target = Target.domain("example.com")
        result = await XssAdvancedPlugin().run(target, mock_ctx)
        assert result.ok
        dom_findings = [f for f in result.findings if "DOM" in f.title]
        assert len(dom_findings) >= 1
