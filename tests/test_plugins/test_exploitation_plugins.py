"""Tests for exploitation category plugins â€” meta, discovery, mock run()."""

from __future__ import annotations

from unittest.mock import AsyncMock

import pytest

from basilisk.core.plugin import BasePlugin, PluginCategory
from basilisk.core.registry import PluginRegistry
from basilisk.models.result import PluginResult
from basilisk.models.target import Target

EXPLOITATION_PLUGINS = [
    "credential_reuse", "cve_exploit", "docker_exploit", "file_upload_bypass",
    "jenkins_exploit", "ldap_enum", "lfi_harvest", "mssql_exploit", "mysql_exploit",
    "nfs_enum", "redis_exploit", "rpc_enum", "smb_enum", "smb_exploit",
    "snmp_enum", "sqli_extract", "tomcat_exploit", "vhost_enum", "webshell_deploy",
    "winrm_check", "wordpress_exploit",
]


class TestExploitationDiscovery:
    """Verify all exploitation plugins are discovered and have valid meta."""

    def test_all_exploitation_discovered(self):
        registry = PluginRegistry()
        registry.discover()
        found = registry.by_category(PluginCategory.EXPLOITATION)
        names = {p.meta.name for p in found}
        for expected in EXPLOITATION_PLUGINS:
            assert expected in names, f"Missing exploitation plugin: {expected}"

    def test_exploitation_count(self):
        registry = PluginRegistry()
        registry.discover()
        found = registry.by_category(PluginCategory.EXPLOITATION)
        assert len(found) == 23


class TestExploitationMeta:
    """Validate metadata for each exploitation plugin."""

    @pytest.fixture
    def registry(self):
        r = PluginRegistry()
        r.discover()
        return r

    @pytest.mark.parametrize("plugin_name", EXPLOITATION_PLUGINS)
    def test_meta_fields(self, registry, plugin_name):
        cls = registry.get(plugin_name)
        assert cls is not None, f"Plugin {plugin_name} not found"
        meta = cls.meta
        assert meta.name == plugin_name
        assert meta.display_name
        assert meta.category == PluginCategory.EXPLOITATION
        assert meta.timeout > 0
        assert isinstance(meta.produces, list)

    @pytest.mark.parametrize("plugin_name", EXPLOITATION_PLUGINS)
    def test_is_base_plugin(self, registry, plugin_name):
        cls = registry.get(plugin_name)
        assert issubclass(cls, BasePlugin)


class TestCveExploitRun:
    async def test_no_version_data(self, mock_ctx):
        from basilisk.plugins.exploitation.cve_exploit import CveExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = CveExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestDockerExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.docker_exploit import DockerExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = DockerExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestFileUploadBypassRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.file_upload_bypass import FileUploadBypassPlugin

        target = Target.domain("example.com")
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}
        mock_resp = AsyncMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)
        plugin = FileUploadBypassPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestJenkinsExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.jenkins_exploit import JenkinsExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_resp = AsyncMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=mock_resp)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        plugin = JenkinsExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestLdapEnumRun:
    async def test_no_ldap_port(self, mock_ctx):
        from basilisk.plugins.exploitation.ldap_enum import LdapEnumPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = LdapEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestSmbEnumRun:
    async def test_no_smb_port(self, mock_ctx):
        from basilisk.plugins.exploitation.smb_enum import SmbEnumPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = SmbEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestSmbExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.smb_exploit import SmbExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = SmbExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestRedisExploitRun:
    async def test_no_redis_port(self, mock_ctx):
        from basilisk.plugins.exploitation.redis_exploit import RedisExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = RedisExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestMysqlExploitRun:
    async def test_no_mysql_port(self, mock_ctx):
        from basilisk.plugins.exploitation.mysql_exploit import MysqlExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = MysqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestMssqlExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.mssql_exploit import MssqlExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = MssqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestTomcatExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.tomcat_exploit import TomcatExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_resp = AsyncMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        plugin = TomcatExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestVhostEnumRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.vhost_enum import VhostEnumPlugin

        target = Target.domain("example.com")
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="OK")
        mock_resp.headers = {"Content-Length": "2"}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        plugin = VhostEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestNfsEnumRun:
    async def test_no_nfs_port(self, mock_ctx):
        from basilisk.plugins.exploitation.nfs_enum import NfsEnumPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = NfsEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestRpcEnumRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.rpc_enum import RpcEnumPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = RpcEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestSnmpEnumRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.snmp_enum import SnmpEnumPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = SnmpEnumPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestWebshellDeployRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.webshell_deploy import WebshellDeployPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_resp = AsyncMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        plugin = WebshellDeployPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestWinrmCheckRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.winrm_check import WinrmCheckPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = WinrmCheckPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


class TestWordpressExploitRun:
    async def test_run_returns_result(self, mock_ctx):
        from basilisk.plugins.exploitation.wordpress_exploit import WordpressExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_resp = AsyncMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        plugin = WordpressExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)


# --- SQLi Extract tests ---


class TestSqliExtractRun:
    async def test_no_sqli_data(self, mock_ctx):
        from basilisk.plugins.exploitation.sqli_extract import SqliExtractPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = SqliExtractPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert result.status == "success"
        assert result.data["injection_points"] == 0

    async def test_union_extraction(self, mock_ctx):
        from basilisk.plugins.exploitation.sqli_extract import SqliExtractPlugin

        target = Target.domain("example.com")

        # Mock sqli_basic result with union injection
        sqli_result = PluginResult.success(
            "sqli_basic", "example.com",
            data={
                "sqli_tests": [{
                    "type": "union",
                    "url": "http://example.com/page?id=1",
                    "param": "id",
                    "columns": 3,
                    "dbms": "MySQL",
                    "payload": "' UNION SELECT NULL,NULL,NULL-- -",
                }],
                "detected_dbms": "MySQL",
            },
        )
        mock_ctx.pipeline = {f"sqli_basic:{target.host}": sqli_result}

        # Mock HTTP responses
        call_count = 0

        async def mock_get(url, **kwargs):
            nonlocal call_count
            call_count += 1
            resp = AsyncMock()
            resp.status = 200
            # Return marker on first few calls (column detection)
            if "bslsk_" in url:
                col_marker = "bslsk_1"
                resp.text = AsyncMock(return_value=f"<p>{col_marker}</p>")
            elif "VERSION" in url:
                resp.text = AsyncMock(return_value="<p>8.0.33</p>")
            else:
                resp.text = AsyncMock(return_value="<p>no data</p>")
            return resp

        mock_ctx.http.get = mock_get
        plugin = SqliExtractPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert result.data["injection_points"] == 1

    async def test_error_based_extraction(self, mock_ctx):
        from basilisk.plugins.exploitation.sqli_extract import SqliExtractPlugin

        target = Target.domain("example.com")
        sqli_result = PluginResult.success(
            "sqli_basic", "example.com",
            data={
                "sqli_tests": [{
                    "type": "error-based",
                    "url": "http://example.com/page?id=1",
                    "param": "id",
                    "dbms": "MySQL",
                    "payload": "1'",
                }],
                "detected_dbms": "MySQL",
            },
        )
        mock_ctx.pipeline = {f"sqli_basic:{target.host}": sqli_result}

        async def mock_get(url, **kwargs):
            resp = AsyncMock()
            resp.status = 200
            if "EXTRACTVALUE" in url and "VERSION" in url:
                resp.text = AsyncMock(return_value="XPATH error: ~8.0.33~")
            elif "EXTRACTVALUE" in url and "CURRENT_USER" in url:
                resp.text = AsyncMock(return_value="XPATH error: ~root@localhost~")
            elif "EXTRACTVALUE" in url and "DATABASE" in url:
                resp.text = AsyncMock(return_value="XPATH error: ~testdb~")
            else:
                resp.text = AsyncMock(return_value="error")
            return resp

        mock_ctx.http.get = mock_get
        plugin = SqliExtractPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        extracted = result.data.get("extracted", {})
        assert extracted.get("version") == "8.0.33"
        assert extracted.get("current_user") == "root@localhost"
        assert extracted.get("current_db") == "testdb"
        assert any(f.severity.name == "CRITICAL" for f in result.findings)


# --- LFI Harvest tests ---


class TestLfiHarvestRun:
    async def test_no_lfi_data(self, mock_ctx):
        from basilisk.plugins.exploitation.lfi_harvest import LfiHarvestPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = LfiHarvestPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert result.status == "success"
        assert len(result.data["files"]) == 0

    async def test_config_extraction(self, mock_ctx):
        from basilisk.plugins.exploitation.lfi_harvest import LfiHarvestPlugin

        target = Target.domain("example.com")
        lfi_result = PluginResult.success(
            "lfi_check", "example.com",
            data={
                "lfi_tests": [{
                    "path": "index.php",
                    "param": "file",
                    "payload": "../../../../etc/passwd",
                    "label": "traversal_basic",
                }],
            },
        )
        mock_ctx.pipeline = {f"lfi_check:{target.host}": lfi_result}

        passwd_content = "root:x:0:0:root:/root:/bin/bash\nnobody:x:65534:65534::/:"
        env_content = "DB_PASSWORD=s3cret\nDB_USERNAME=admin\nSECRET_KEY=abc123\n"

        async def mock_get(url, **kwargs):
            resp = AsyncMock()
            resp.status = 200
            # URL-encoded: etc%2Fpasswd or etc/passwd
            if "passwd" in url:
                resp.text = AsyncMock(return_value=passwd_content)
            elif ".env" in url or "env" in url.split("=")[-1]:
                resp.text = AsyncMock(return_value=env_content)
            else:
                resp.status = 404
                resp.text = AsyncMock(return_value="<html>Not found</html>")
            return resp

        mock_ctx.http.get = mock_get
        # Mock resolve_base_urls via http_scheme state
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}

        # Also need to mock http.head for resolve_base_urls
        head_resp = AsyncMock()
        head_resp.status = 200
        mock_ctx.http.head = AsyncMock(return_value=head_resp)

        plugin = LfiHarvestPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert len(result.data["files"]) >= 1
        # Should have found /etc/passwd
        passwd_files = [f for f in result.data["files"] if f["path"] == "/etc/passwd"]
        assert len(passwd_files) >= 1

    async def test_php_filter_extraction(self, mock_ctx):
        import base64

        from basilisk.plugins.exploitation.lfi_harvest import LfiHarvestPlugin

        target = Target.domain("example.com")
        php_source = '<?php $db_password = "secret123"; ?>'
        b64_encoded = base64.b64encode(php_source.encode()).decode()

        lfi_result = PluginResult.success(
            "lfi_check", "example.com",
            data={
                "lfi_tests": [{
                    "path": "index.php",
                    "param": "file",
                    "payload": "php://filter/convert.base64-encode/resource=/etc/passwd",
                    "label": "php_filter_b64",
                }],
            },
        )
        mock_ctx.pipeline = {f"lfi_check:{target.host}": lfi_result}

        async def mock_get(url, **kwargs):
            resp = AsyncMock()
            if "php://filter" in url or "php%3A%2F%2Ffilter" in url:
                resp.status = 200
                resp.text = AsyncMock(return_value=b64_encoded)
            else:
                resp.status = 404
                resp.text = AsyncMock(return_value="Not found")
            return resp

        mock_ctx.http.get = mock_get
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}
        head_resp = AsyncMock()
        head_resp.status = 200
        mock_ctx.http.head = AsyncMock(return_value=head_resp)

        plugin = LfiHarvestPlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        php_files = [f for f in result.data["files"] if f["method"] == "php_filter"]
        if php_files:
            assert "secret123" in php_files[0]["content"]


# --- Credential Reuse tests ---


class TestCredentialReuseRun:
    async def test_no_credentials(self, mock_ctx):
        from basilisk.plugins.exploitation.credential_reuse import CredentialReusePlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_ctx.state = {"http_scheme": {"example.com": "https"}}
        mock_ctx.creds = None
        plugin = CredentialReusePlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert result.status == "success"
        assert len(result.data["successful_logins"]) == 0

    async def test_form_login_success(self, mock_ctx):
        from basilisk.plugins.exploitation.credential_reuse import CredentialReusePlugin

        target = Target.domain("example.com")
        mock_ctx.state = {
            "http_scheme": {"example.com": "https"},
            "credentials": [
                {"username": "admin", "password": "password123", "source": "sqli_extract"},
            ],
            "discovered_forms": {
                "example.com": [{
                    "action": "/login",
                    "inputs": [
                        {"name": "username", "type": "text"},
                        {"name": "password", "type": "password"},
                    ],
                }],
            },
        }
        mock_ctx.pipeline = {}
        mock_ctx.creds = None

        async def mock_post(url, **kwargs):
            resp = AsyncMock()
            resp.status = 302
            resp.headers = {"Location": "/dashboard", "Set-Cookie": "session=abc123"}
            resp.text = AsyncMock(return_value="Redirecting to dashboard")
            return resp

        async def mock_get(url, **kwargs):
            resp = AsyncMock()
            resp.status = 404
            resp.text = AsyncMock(return_value="Not found")
            resp.headers = {}
            return resp

        mock_ctx.http.post = mock_post
        mock_ctx.http.get = mock_get

        # Mock resolve_base_urls
        head_resp = AsyncMock()
        head_resp.status = 200
        mock_ctx.http.head = AsyncMock(return_value=head_resp)

        plugin = CredentialReusePlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert len(result.data["successful_logins"]) >= 1
        assert any(f.severity.name == "CRITICAL" for f in result.findings)

    async def test_no_login_targets(self, mock_ctx):
        from basilisk.plugins.exploitation.credential_reuse import CredentialReusePlugin

        target = Target.domain("example.com")
        mock_ctx.state = {
            "http_scheme": {"example.com": "https"},
            "credentials": [
                {"username": "admin", "password": "test", "source": "test"},
            ],
        }
        mock_ctx.pipeline = {}
        mock_ctx.creds = None

        # All admin paths return 404 without forms
        async def mock_get(url, **kwargs):
            resp = AsyncMock()
            resp.status = 404
            resp.text = AsyncMock(return_value="<html>Not Found</html>")
            resp.headers = {}
            return resp

        mock_ctx.http.get = mock_get
        head_resp = AsyncMock()
        head_resp.status = 200
        mock_ctx.http.head = AsyncMock(return_value=head_resp)

        plugin = CredentialReusePlugin()
        result = await plugin.run(target, mock_ctx)
        assert isinstance(result, PluginResult)
        assert result.data["successful_logins"] == []
