"""Tests for pentesting plugins — new batch 2."""

from unittest.mock import AsyncMock, MagicMock, patch

from basilisk.models.target import Target


def _make_inline_scheme_ctx(mock_ctx):
    mock_head = MagicMock()
    mock_head.status = 200
    mock_ctx.http.head = AsyncMock(return_value=mock_head)
    mock_resp = MagicMock()
    mock_resp.status = 200
    mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
    mock_resp.headers = {"Content-Type": "text/html"}
    mock_ctx.http.get = AsyncMock(return_value=mock_resp)
    mock_ctx.http.post = AsyncMock(return_value=mock_resp)
    return mock_ctx


# ---------------------------------------------------------------------------
# 1. IdorExploitPlugin
# ---------------------------------------------------------------------------
class TestIdorExploit:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.idor_exploit import IdorExploitPlugin

        mock_ctx.http = None
        # Need upstream idor_check result
        from basilisk.models.result import PluginResult

        mock_ctx.pipeline["idor_check:example.com"] = PluginResult.success(
            "idor_check", "example.com",
            data={"idor_endpoints": [{"url": "https://example.com/api/user?id=1", "param": "id"}]},
        )
        target = Target.domain("example.com")
        plugin = IdorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_upstream_result(self, mock_ctx):
        from basilisk.plugins.pentesting.idor_exploit import IdorExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        plugin = IdorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "skipped"

    async def test_no_idor_endpoints(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.idor_exploit import IdorExploitPlugin

        mock_ctx.pipeline["idor_check:example.com"] = PluginResult.success(
            "idor_check", "example.com", data={"idor_endpoints": []},
        )
        target = Target.domain("example.com")
        plugin = IdorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_enumeration_no_vuln(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.idor_exploit import IdorExploitPlugin

        mock_ctx.pipeline["idor_check:example.com"] = PluginResult.success(
            "idor_check", "example.com",
            data={"idor_endpoints": [{"url": "https://example.com/api/user?id=1", "param": "id"}]},
        )
        # All requests return 404 — no valid enumeration
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        target = Target.domain("example.com")
        plugin = IdorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        # Should produce info finding about non-exploitable endpoints
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1


# ---------------------------------------------------------------------------
# 2. CloudMetadataSsrfPlugin
# ---------------------------------------------------------------------------
class TestCloudMetadataSsrf:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import CloudMetadataSsrfPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = CloudMetadataSsrfPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_ssrf_no_cloud(self, mock_ctx):
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import CloudMetadataSsrfPlugin

        target = Target.domain("example.com")
        mock_ctx.pipeline = {}
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        plugin = CloudMetadataSsrfPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        # Should have info finding about no metadata accessible
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_ssrf_endpoints_no_metadata(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.cloud_metadata_ssrf import CloudMetadataSsrfPlugin

        mock_ctx.pipeline["ssrf_check:example.com"] = PluginResult.success(
            "ssrf_check", "example.com",
            data={"ssrf_endpoints": [{"url": "https://example.com/proxy", "param": "url"}]},
        )
        mock_ctx.pipeline["cloud_detect:example.com"] = PluginResult.success(
            "cloud_detect", "example.com", data={"providers": ["aws"]},
        )
        # All requests return 403 — metadata inaccessible
        mock_resp = MagicMock()
        mock_resp.status = 403
        mock_resp.text = AsyncMock(return_value="Forbidden")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        target = Target.domain("example.com")
        plugin = CloudMetadataSsrfPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 3. PpExploitPlugin
# ---------------------------------------------------------------------------
class TestPpExploit:
    async def test_no_http(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.pp_exploit import PpExploitPlugin

        mock_ctx.http = None
        mock_ctx.pipeline["prototype_pollution:example.com"] = PluginResult.success(
            "prototype_pollution", "example.com",
            data={"vulnerable_endpoints": [{"url": "https://example.com/api/"}]},
        )
        target = Target.domain("example.com")
        plugin = PpExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_upstream_result(self, mock_ctx):
        from basilisk.plugins.pentesting.pp_exploit import PpExploitPlugin

        mock_ctx.pipeline = {}
        target = Target.domain("example.com")
        plugin = PpExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "skipped"

    async def test_no_pp_endpoints(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.pp_exploit import PpExploitPlugin

        mock_ctx.pipeline["prototype_pollution:example.com"] = PluginResult.success(
            "prototype_pollution", "example.com",
            data={"vulnerable_endpoints": []},
        )
        target = Target.domain("example.com")
        plugin = PpExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_no_chain_found(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.pp_exploit import PpExploitPlugin

        mock_ctx.pipeline["prototype_pollution:example.com"] = PluginResult.success(
            "prototype_pollution", "example.com",
            data={"vulnerable_endpoints": [{"url": "https://example.com/search"}]},
        )
        # Baseline and polluted return identical responses
        mock_resp = MagicMock()
        mock_resp.status = 200
        mock_resp.text = AsyncMock(return_value="<html>Normal page</html>")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        target = Target.domain("example.com")
        plugin = PpExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1


# ---------------------------------------------------------------------------
# 4. OauthAttackPlugin
# ---------------------------------------------------------------------------
class TestOauthAttack:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.oauth_attack import OauthAttackPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = OauthAttackPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_oauth_endpoints(self, mock_ctx):
        from basilisk.plugins.pentesting.oauth_attack import OauthAttackPlugin

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)
        # All discovery paths return 404 (no OAuth)
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not Found")
        mock_resp.headers = {}
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = OauthAttackPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.oauth_attack import OauthAttackPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = OauthAttackPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 5. GraphqlExploitPlugin
# ---------------------------------------------------------------------------
class TestGraphqlExploit:
    async def test_no_http(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.graphql_exploit import GraphqlExploitPlugin

        mock_ctx.http = None
        mock_ctx.pipeline["graphql_detect:example.com"] = PluginResult.success(
            "graphql_detect", "example.com",
            data={"graphql_endpoints": [{"path": "/graphql"}]},
        )
        target = Target.domain("example.com")
        plugin = GraphqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_upstream_result(self, mock_ctx):
        from basilisk.plugins.pentesting.graphql_exploit import GraphqlExploitPlugin

        mock_ctx.pipeline = {}
        target = Target.domain("example.com")
        plugin = GraphqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "skipped"

    async def test_no_graphql_endpoints(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.graphql_exploit import GraphqlExploitPlugin

        mock_ctx.pipeline["graphql_detect:example.com"] = PluginResult.success(
            "graphql_detect", "example.com",
            data={"graphql_endpoints": []},
        )
        target = Target.domain("example.com")
        plugin = GraphqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_no_exploits_found(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.graphql_exploit import GraphqlExploitPlugin

        mock_ctx.pipeline["graphql_detect:example.com"] = PluginResult.success(
            "graphql_detect", "example.com",
            data={"graphql_endpoints": [{"path": "/graphql"}]},
        )
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # Introspection disabled, suggestions disabled, depth blocked, batch blocked
        mock_resp = MagicMock()
        mock_resp.status = 400
        mock_resp.text = AsyncMock(return_value='{"errors":[{"message":"Not allowed"}]}')
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)

        target = Target.domain("example.com")
        plugin = GraphqlExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1


# ---------------------------------------------------------------------------
# 6. PasswordResetPoisonPlugin
# ---------------------------------------------------------------------------
class TestPasswordResetPoison:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.password_reset_poison import (
            PasswordResetPoisonPlugin,
        )

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = PasswordResetPoisonPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_reset_endpoints(self, mock_ctx):
        from basilisk.plugins.pentesting.password_reset_poison import (
            PasswordResetPoisonPlugin,
        )

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # All reset discovery paths return 404
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not found")
        mock_resp.headers = {}
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = PasswordResetPoisonPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.password_reset_poison import (
            PasswordResetPoisonPlugin,
        )

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = PasswordResetPoisonPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 7. RaceConditionPlugin
# ---------------------------------------------------------------------------
class TestRaceCondition:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.race_condition import RaceConditionPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = RaceConditionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.race_condition import RaceConditionPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = RaceConditionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_no_race_conditions(self, mock_ctx):
        from basilisk.plugins.pentesting.race_condition import RaceConditionPlugin

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # Patch the raw_http engine to avoid real socket connections
        mock_result = MagicMock()
        mock_result.total_connections = 30
        mock_result.ready_connections = 30
        mock_result.failed_connections = 0
        mock_result.sync_jitter_ms = 5.0
        mock_result.responses = []

        with patch(
            "basilisk.utils.raw_http.LastByteSyncEngine"
        ) as mock_engine_cls:
            engine_instance = MagicMock()
            engine_instance.execute = AsyncMock(return_value=mock_result)
            mock_engine_cls.return_value = engine_instance

            plugin = RaceConditionPlugin()
            result = await plugin.run(target, mock_ctx)
            assert result.ok


# ---------------------------------------------------------------------------
# 8. PrototypePollutionPlugin
# ---------------------------------------------------------------------------
class TestPrototypePollution:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.prototype_pollution import (
            PrototypePollutionPlugin,
        )

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = PrototypePollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_pp_found(self, mock_ctx):
        from basilisk.plugins.pentesting.prototype_pollution import (
            PrototypePollutionPlugin,
        )

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        plugin = PrototypePollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.prototype_pollution import (
            PrototypePollutionPlugin,
        )

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = PrototypePollutionPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 9. WpBrutePlugin
# ---------------------------------------------------------------------------
class TestWpBrute:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.wp_brute import WpBrutePlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = WpBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_not_wordpress(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.wp_brute import WpBrutePlugin

        mock_ctx.pipeline["wordpress_scan:example.com"] = PluginResult.success(
            "wordpress_scan", "example.com", data={"is_wordpress": False},
        )
        target = Target.domain("example.com")
        plugin = WpBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        # Should say "Not a WordPress site"
        assert any("WordPress" in f.title for f in result.findings)

    async def test_no_creds_found(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.wp_brute import WpBrutePlugin

        mock_ctx.pipeline["wordpress_scan:example.com"] = PluginResult.success(
            "wordpress_scan", "example.com", data={"is_wordpress": True},
        )
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # XMLRPC returns 405 (not available), wp-login returns 200 but no success
        mock_xmlrpc_resp = MagicMock()
        mock_xmlrpc_resp.status = 405
        mock_xmlrpc_resp.text = AsyncMock(return_value="Method not allowed")

        mock_login_resp = MagicMock()
        mock_login_resp.status = 200
        mock_login_resp.text = AsyncMock(return_value="<html>Invalid login</html>")
        mock_login_resp.headers = MagicMock()
        mock_login_resp.headers.get = MagicMock(return_value="")
        mock_login_resp.headers.getall = MagicMock(return_value=[])

        async def fake_post(url, **kwargs):
            if "xmlrpc.php" in url:
                return mock_xmlrpc_resp
            return mock_login_resp

        mock_ctx.http.post = fake_post

        target = Target.domain("example.com")
        plugin = WpBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 10. WpDeepScanPlugin
# ---------------------------------------------------------------------------
class TestWpDeepScan:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.wp_deep_scan import WpDeepScanPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = WpDeepScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_not_wordpress(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.wp_deep_scan import WpDeepScanPlugin

        mock_ctx.pipeline["wordpress_scan:example.com"] = PluginResult.success(
            "wordpress_scan", "example.com", data={"is_wordpress": False},
        )
        target = Target.domain("example.com")
        plugin = WpDeepScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_no_deep_findings(self, mock_ctx):
        from basilisk.models.result import PluginResult
        from basilisk.plugins.pentesting.wp_deep_scan import WpDeepScanPlugin

        mock_ctx.pipeline["wordpress_scan:example.com"] = PluginResult.success(
            "wordpress_scan", "example.com", data={"is_wordpress": True},
        )
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # All probes return 404
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not Found")
        mock_resp.headers = MagicMock()
        mock_resp.headers.get = MagicMock(return_value="")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)

        target = Target.domain("example.com")
        plugin = WpDeepScanPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 11. ActuatorExploitPlugin
# ---------------------------------------------------------------------------
class TestActuatorExploit:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.actuator_exploit import ActuatorExploitPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = ActuatorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_actuator_endpoints(self, mock_ctx):
        from basilisk.plugins.pentesting.actuator_exploit import ActuatorExploitPlugin

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # All actuator/swagger/graphql probes return 404
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not Found")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)
        mock_ctx.http.post = AsyncMock(return_value=mock_resp)

        plugin = ActuatorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.actuator_exploit import ActuatorExploitPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = ActuatorExploitPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 12. CredentialSprayPlugin
# ---------------------------------------------------------------------------
class TestCredentialSpray:
    async def test_no_http(self, mock_ctx):
        from basilisk.plugins.pentesting.credential_spray import CredentialSprayPlugin

        mock_ctx.http = None
        target = Target.domain("example.com")
        plugin = CredentialSprayPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.status == "error"

    async def test_no_login_forms(self, mock_ctx):
        from basilisk.plugins.pentesting.credential_spray import CredentialSprayPlugin

        target = Target.domain("example.com")
        mock_ctx = _make_inline_scheme_ctx(mock_ctx)

        # All login paths return 404 — no forms found
        mock_resp = MagicMock()
        mock_resp.status = 404
        mock_resp.text = AsyncMock(return_value="Not Found")
        mock_ctx.http.get = AsyncMock(return_value=mock_resp)

        plugin = CredentialSprayPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        info_findings = [f for f in result.findings if f.severity.name == "INFO"]
        assert len(info_findings) >= 1

    async def test_host_not_reachable(self, mock_ctx):
        from basilisk.plugins.pentesting.credential_spray import CredentialSprayPlugin

        target = Target.domain("example.com")
        mock_ctx.state["http_scheme"] = {}
        mock_ctx.http.head = AsyncMock(side_effect=ConnectionError("refused"))

        plugin = CredentialSprayPlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok


# ---------------------------------------------------------------------------
# 13. SshBrutePlugin
# ---------------------------------------------------------------------------
class TestSshBrute:
    async def test_port_22_not_open(self, mock_ctx):
        from basilisk.plugins.pentesting.ssh_brute import SshBrutePlugin

        target = Target.domain("example.com")
        mock_ctx.state["open_ports"] = []
        plugin = SshBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok
        assert any("No SSH port" in f.title for f in result.findings)

    async def test_port_22_closed_dict_format(self, mock_ctx):
        from basilisk.plugins.pentesting.ssh_brute import SshBrutePlugin

        target = Target.domain("example.com")
        mock_ctx.state["open_ports"] = [{"port": 80}, {"port": 443}]
        plugin = SshBrutePlugin()
        result = await plugin.run(target, mock_ctx)
        assert result.ok

    async def test_port_22_open_no_creds(self, mock_ctx):
        from basilisk.plugins.pentesting.ssh_brute import SshBrutePlugin

        target = Target.domain("example.com")
        mock_ctx.state["open_ports"] = [{"port": 22}]

        with (
            patch.object(
                SshBrutePlugin,
                "_grab_banner",
                new_callable=AsyncMock,
                return_value="SSH-2.0-OpenSSH_8.9",
            ),
            patch.object(
                SshBrutePlugin,
                "_try_ssh_auth",
                new_callable=AsyncMock,
                return_value="failed",
            ),
            patch("basilisk.plugins.pentesting.ssh_brute.asyncio.sleep", new_callable=AsyncMock),
        ):
            plugin = SshBrutePlugin()
            result = await plugin.run(target, mock_ctx)
            assert result.ok
            assert result.data["ssh_brute"]["banner"] == "SSH-2.0-OpenSSH_8.9"
            # No credentials found
            assert not result.data["ssh_brute"]["found"]
